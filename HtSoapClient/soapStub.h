/* soapStub.h
   Generated by gSOAP 2.8.108 for HTSAPServer.h

gSOAP XML Web services tools
Copyright (C) 2000-2020, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://server.cdt.com"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 208108
# error "GSOAP VERSION 208108 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class xsd__base64Binary;	/* HTSAPServer.h:151 */
class ns1__Exception;	/* HTSAPServer.h:166 */
class ns1__syncWriteVehicleInfo;	/* HTSAPServer.h:168 */
class ns1__syncWriteVehicleInfoResponse;	/* HTSAPServer.h:170 */
class ns1__writeVehicleInfo;	/* HTSAPServer.h:172 */
class ns1__writeVehicleInfoResponse;	/* HTSAPServer.h:174 */
class ns1__login;	/* HTSAPServer.h:176 */
class ns1__loginResponse;	/* HTSAPServer.h:178 */
class ns1__queryLimitSpeed;	/* HTSAPServer.h:180 */
class ns1__queryLimitSpeedResponse;	/* HTSAPServer.h:182 */
class ns1__queryViolateSpeed;	/* HTSAPServer.h:184 */
class ns1__queryViolateSpeedResponse;	/* HTSAPServer.h:186 */
class ns1__logout;	/* HTSAPServer.h:188 */
class ns1__logoutResponse;	/* HTSAPServer.h:190 */
class ns1__querySyncTime;	/* HTSAPServer.h:192 */
class ns1__querySyncTimeResponse;	/* HTSAPServer.h:194 */
class ns1__writeAlarmInfo;	/* HTSAPServer.h:196 */
class ns1__writeAlarmInfoResponse;	/* HTSAPServer.h:198 */
class ns1__NWriteVehicleInfo;	/* HTSAPServer.h:200 */
class ns1__NWriteVehicleInfoResponse;	/* HTSAPServer.h:202 */
class ns1__NWriteVehicleInfoEx;	/* HTSAPServer.h:204 */
class ns1__NWriteVehicleInfoExResponse;	/* HTSAPServer.h:206 */
class ns1__NSyncWriteVehicleInfo;	/* HTSAPServer.h:208 */
class ns1__NSyncWriteVehicleInfoResponse;	/* HTSAPServer.h:210 */
class ns1__WriteFlux;	/* HTSAPServer.h:212 */
class ns1__WriteFluxResponse;	/* HTSAPServer.h:214 */
class ns1__NWriteDeviceStatus;	/* HTSAPServer.h:216 */
class ns1__NWriteDeviceStatusResponse;	/* HTSAPServer.h:218 */
class ns1__NSyncWriteMobileEPVInfo;	/* HTSAPServer.h:220 */
class ns1__NSyncWriteMobileEPVInfoResponse;	/* HTSAPServer.h:222 */
class ns1__NSyncWriteVioInfo;	/* HTSAPServer.h:224 */
class ns1__NSyncWriteVioInfoResponse;	/* HTSAPServer.h:226 */
class ns1__NWritePassStat;	/* HTSAPServer.h:228 */
class ns1__NWritePassStatResponse;	/* HTSAPServer.h:230 */
class ns1__SyncWriteVehPassInfo;	/* HTSAPServer.h:232 */
class ns1__SyncWriteVehPassInfoResponse;	/* HTSAPServer.h:234 */
class ns1__WriteVehPassInfo;	/* HTSAPServer.h:236 */
class ns1__WriteVehPassInfoResponse;	/* HTSAPServer.h:238 */
class ns1__SyncWriteAreaSpeed;	/* HTSAPServer.h:240 */
class ns1__SyncWriteAreaSpeedResponse;	/* HTSAPServer.h:242 */
class ns1__WriteAreaSpeed;	/* HTSAPServer.h:244 */
class ns1__WriteAreaSpeedResponse;	/* HTSAPServer.h:246 */
struct __ns1__syncWriteVehicleInfo;	/* HTSAPServer.h:2042 */
struct __ns1__writeVehicleInfo;	/* HTSAPServer.h:2112 */
struct __ns1__login;	/* HTSAPServer.h:2182 */
struct __ns1__queryLimitSpeed;	/* HTSAPServer.h:2252 */
struct __ns1__queryViolateSpeed;	/* HTSAPServer.h:2322 */
struct __ns1__logout;	/* HTSAPServer.h:2392 */
struct __ns1__querySyncTime;	/* HTSAPServer.h:2462 */
struct __ns1__writeAlarmInfo;	/* HTSAPServer.h:2532 */
struct __ns1__NWriteVehicleInfo;	/* HTSAPServer.h:2602 */
struct __ns1__NWriteVehicleInfoEx;	/* HTSAPServer.h:2672 */
struct __ns1__NSyncWriteVehicleInfo;	/* HTSAPServer.h:2742 */
struct __ns1__WriteFlux;	/* HTSAPServer.h:2812 */
struct __ns1__NWriteDeviceStatus;	/* HTSAPServer.h:2882 */
struct __ns1__NSyncWriteMobileEPVInfo;	/* HTSAPServer.h:2952 */
struct __ns1__NSyncWriteVioInfo;	/* HTSAPServer.h:3022 */
struct __ns1__NWritePassStat;	/* HTSAPServer.h:3092 */
struct __ns1__SyncWriteVehPassInfo;	/* HTSAPServer.h:3162 */
struct __ns1__WriteVehPassInfo;	/* HTSAPServer.h:3232 */
struct __ns1__SyncWriteAreaSpeed;	/* HTSAPServer.h:3302 */
struct __ns1__WriteAreaSpeed;	/* HTSAPServer.h:3372 */

/* HTSAPServer.h:151 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (8)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XML schema type 'xsd:string'
        char *id;
        /// Optional element 'type' of XML schema type 'xsd:string'
        char *type;
        /// Optional element 'options' of XML schema type 'xsd:string'
        char *options;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__base64Binary); }
      public:
        /// Constructor with default initializations
        xsd__base64Binary() : __ptr(), __size(), id(), type(), options() { }
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:166 */
#ifndef SOAP_TYPE_ns1__Exception
#define SOAP_TYPE_ns1__Exception (12)
/* complex XML schema type 'ns1:Exception': */
class SOAP_CMAC ns1__Exception {
      public:
        /// Optional element 'message' of XML schema type 'xsd:string'
        std::string *message;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Exception
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Exception; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Exception, default initialized and not managed by a soap context
        virtual ns1__Exception *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Exception); }
      public:
        /// Constructor with default initializations
        ns1__Exception() : message(), soap() { }
        virtual ~ns1__Exception() { }
        /// Friend allocator used by soap_new_ns1__Exception(struct soap*, int)
        friend SOAP_FMAC1 ns1__Exception * SOAP_FMAC2 soap_instantiate_ns1__Exception(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:168 */
#ifndef SOAP_TYPE_ns1__syncWriteVehicleInfo
#define SOAP_TYPE_ns1__syncWriteVehicleInfo (13)
/* complex XML schema type 'ns1:syncWriteVehicleInfo': */
class SOAP_CMAC ns1__syncWriteVehicleInfo {
      public:
        /// Required element 'sid' of XML schema type 'xsd:string'
        std::string sid;
        /// Required element 'strDeviceId' of XML schema type 'xsd:string'
        std::string strDeviceId;
        /// Required element 'strVehicleId' of XML schema type 'xsd:string'
        std::string strVehicleId;
        /// Required element 'strDeviceType' of XML schema type 'xsd:string'
        std::string strDeviceType;
        /// Required element 'strDirectionId' of XML schema type 'xsd:string'
        std::string strDirectionId;
        /// Required element 'strDriveWayId' of XML schema type 'xsd:string'
        std::string strDriveWayId;
        /// Required element 'strLicense' of XML schema type 'xsd:string'
        std::string strLicense;
        /// Required element 'strLicenseType' of XML schema type 'xsd:string'
        std::string strLicenseType;
        /// Required element 'strPassDateTime' of XML schema type 'xsd:string'
        std::string strPassDateTime;
        /// Required element 'strRedLightBeginTime' of XML schema type 'xsd:string'
        std::string strRedLightBeginTime;
        /// Required element 'strRedLightLast' of XML schema type 'xsd:string'
        std::string strRedLightLast;
        /// Required element 'lSpeed' of XML schema type 'xsd:long'
        LONG64 lSpeed;
        /// Required element 'lLargeLimitSpeed' of XML schema type 'xsd:long'
        LONG64 lLargeLimitSpeed;
        /// Required element 'lMiniLimitSpeed' of XML schema type 'xsd:long'
        LONG64 lMiniLimitSpeed;
        /// Required element 'strViolationType' of XML schema type 'xsd:string'
        std::string strViolationType;
        /// Required element 'strViolationType2' of XML schema type 'xsd:string'
        std::string strViolationType2;
        /// Required element 'lCarLength' of XML schema type 'xsd:long'
        LONG64 lCarLength;
        /// Required element 'strLicenseColor' of XML schema type 'xsd:string'
        std::string strLicenseColor;
        /// Required element 'strCarType' of XML schema type 'xsd:string'
        std::string strCarType;
        /// Required element 'strPicLocalPath1' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath1;
        /// Required element 'strPicLocalPath2' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath2;
        /// Required element 'strPicLocalPath3' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath3;
        /// Required element 'strPicLocalPath4' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath4;
        /// Required element 'strPicLocalPath5' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath5;
        /// Required element 'strPicLocalPath6' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath6;
        /// Required element 'strPicLocalPath7' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath7;
        /// Required element 'strPicRemotePath' of XML schema type 'xsd:string'
        std::string strPicRemotePath;
        /// Required element 'strViolate' of XML schema type 'xsd:string'
        std::string strViolate;
        /// Required element 'strSendType' of XML schema type 'xsd:string'
        std::string strSendType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__syncWriteVehicleInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__syncWriteVehicleInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__syncWriteVehicleInfo, default initialized and not managed by a soap context
        virtual ns1__syncWriteVehicleInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__syncWriteVehicleInfo); }
      public:
        /// Constructor with default initializations
        ns1__syncWriteVehicleInfo() : sid(), strDeviceId(), strVehicleId(), strDeviceType(), strDirectionId(), strDriveWayId(), strLicense(), strLicenseType(), strPassDateTime(), strRedLightBeginTime(), strRedLightLast(), lSpeed(), lLargeLimitSpeed(), lMiniLimitSpeed(), strViolationType(), strViolationType2(), lCarLength(), strLicenseColor(), strCarType(), strPicLocalPath1(), strPicLocalPath2(), strPicLocalPath3(), strPicLocalPath4(), strPicLocalPath5(), strPicLocalPath6(), strPicLocalPath7(), strPicRemotePath(), strViolate(), strSendType(), soap() { }
        virtual ~ns1__syncWriteVehicleInfo() { }
        /// Friend allocator used by soap_new_ns1__syncWriteVehicleInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__syncWriteVehicleInfo * SOAP_FMAC2 soap_instantiate_ns1__syncWriteVehicleInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:170 */
#ifndef SOAP_TYPE_ns1__syncWriteVehicleInfoResponse
#define SOAP_TYPE_ns1__syncWriteVehicleInfoResponse (14)
/* complex XML schema type 'ns1:syncWriteVehicleInfoResponse': */
class SOAP_CMAC ns1__syncWriteVehicleInfoResponse {
      public:
        /// Optional element 'return' of XML schema type 'xsd:string'
        std::string *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__syncWriteVehicleInfoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__syncWriteVehicleInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__syncWriteVehicleInfoResponse, default initialized and not managed by a soap context
        virtual ns1__syncWriteVehicleInfoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__syncWriteVehicleInfoResponse); }
      public:
        /// Constructor with default initializations
        ns1__syncWriteVehicleInfoResponse() : return_(), soap() { }
        virtual ~ns1__syncWriteVehicleInfoResponse() { }
        /// Friend allocator used by soap_new_ns1__syncWriteVehicleInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__syncWriteVehicleInfoResponse * SOAP_FMAC2 soap_instantiate_ns1__syncWriteVehicleInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:172 */
#ifndef SOAP_TYPE_ns1__writeVehicleInfo
#define SOAP_TYPE_ns1__writeVehicleInfo (15)
/* complex XML schema type 'ns1:writeVehicleInfo': */
class SOAP_CMAC ns1__writeVehicleInfo {
      public:
        /// Required element 'sid' of XML schema type 'xsd:string'
        std::string sid;
        /// Required element 'strDeviceId' of XML schema type 'xsd:string'
        std::string strDeviceId;
        /// Required element 'strVehicleId' of XML schema type 'xsd:string'
        std::string strVehicleId;
        /// Required element 'strDeviceType' of XML schema type 'xsd:string'
        std::string strDeviceType;
        /// Required element 'strDirectionId' of XML schema type 'xsd:string'
        std::string strDirectionId;
        /// Required element 'strDriveWayId' of XML schema type 'xsd:string'
        std::string strDriveWayId;
        /// Required element 'strLicense' of XML schema type 'xsd:string'
        std::string strLicense;
        /// Required element 'strLicenseType' of XML schema type 'xsd:string'
        std::string strLicenseType;
        /// Required element 'strPassDateTime' of XML schema type 'xsd:string'
        std::string strPassDateTime;
        /// Required element 'strRedLightBeginTime' of XML schema type 'xsd:string'
        std::string strRedLightBeginTime;
        /// Required element 'strRedLightLast' of XML schema type 'xsd:string'
        std::string strRedLightLast;
        /// Required element 'lSpeed' of XML schema type 'xsd:long'
        LONG64 lSpeed;
        /// Required element 'lLargeLimitSpeed' of XML schema type 'xsd:long'
        LONG64 lLargeLimitSpeed;
        /// Required element 'lMiniLimitSpeed' of XML schema type 'xsd:long'
        LONG64 lMiniLimitSpeed;
        /// Required element 'strViolationType' of XML schema type 'xsd:string'
        std::string strViolationType;
        /// Required element 'strViolationType2' of XML schema type 'xsd:string'
        std::string strViolationType2;
        /// Required element 'lCarLength' of XML schema type 'xsd:long'
        LONG64 lCarLength;
        /// Required element 'strLicenseColor' of XML schema type 'xsd:string'
        std::string strLicenseColor;
        /// Required element 'strCarType' of XML schema type 'xsd:string'
        std::string strCarType;
        /// Required element 'strPicLocalPath1' of XML schema type 'xsd:string'
        std::string strPicLocalPath1;
        /// Required element 'strPicLocalPath2' of XML schema type 'xsd:string'
        std::string strPicLocalPath2;
        /// Required element 'strPicLocalPath3' of XML schema type 'xsd:string'
        std::string strPicLocalPath3;
        /// Required element 'strPicLocalPath4' of XML schema type 'xsd:string'
        std::string strPicLocalPath4;
        /// Required element 'strPicLocalPath5' of XML schema type 'xsd:string'
        std::string strPicLocalPath5;
        /// Required element 'strPicLocalPath6' of XML schema type 'xsd:string'
        std::string strPicLocalPath6;
        /// Required element 'strPicLocalPath7' of XML schema type 'xsd:string'
        std::string strPicLocalPath7;
        /// Required element 'strPicRemotePath' of XML schema type 'xsd:string'
        std::string strPicRemotePath;
        /// Required element 'strViolate' of XML schema type 'xsd:string'
        std::string strViolate;
        /// Required element 'strSendType' of XML schema type 'xsd:string'
        std::string strSendType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__writeVehicleInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__writeVehicleInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__writeVehicleInfo, default initialized and not managed by a soap context
        virtual ns1__writeVehicleInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__writeVehicleInfo); }
      public:
        /// Constructor with default initializations
        ns1__writeVehicleInfo() : sid(), strDeviceId(), strVehicleId(), strDeviceType(), strDirectionId(), strDriveWayId(), strLicense(), strLicenseType(), strPassDateTime(), strRedLightBeginTime(), strRedLightLast(), lSpeed(), lLargeLimitSpeed(), lMiniLimitSpeed(), strViolationType(), strViolationType2(), lCarLength(), strLicenseColor(), strCarType(), strPicLocalPath1(), strPicLocalPath2(), strPicLocalPath3(), strPicLocalPath4(), strPicLocalPath5(), strPicLocalPath6(), strPicLocalPath7(), strPicRemotePath(), strViolate(), strSendType(), soap() { }
        virtual ~ns1__writeVehicleInfo() { }
        /// Friend allocator used by soap_new_ns1__writeVehicleInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__writeVehicleInfo * SOAP_FMAC2 soap_instantiate_ns1__writeVehicleInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:174 */
#ifndef SOAP_TYPE_ns1__writeVehicleInfoResponse
#define SOAP_TYPE_ns1__writeVehicleInfoResponse (16)
/* complex XML schema type 'ns1:writeVehicleInfoResponse': */
class SOAP_CMAC ns1__writeVehicleInfoResponse {
      public:
        /// Optional element 'return' of XML schema type 'xsd:string'
        std::string *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__writeVehicleInfoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__writeVehicleInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__writeVehicleInfoResponse, default initialized and not managed by a soap context
        virtual ns1__writeVehicleInfoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__writeVehicleInfoResponse); }
      public:
        /// Constructor with default initializations
        ns1__writeVehicleInfoResponse() : return_(), soap() { }
        virtual ~ns1__writeVehicleInfoResponse() { }
        /// Friend allocator used by soap_new_ns1__writeVehicleInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__writeVehicleInfoResponse * SOAP_FMAC2 soap_instantiate_ns1__writeVehicleInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:176 */
#ifndef SOAP_TYPE_ns1__login
#define SOAP_TYPE_ns1__login (17)
/* complex XML schema type 'ns1:login': */
class SOAP_CMAC ns1__login {
      public:
        /// Required element 'strDeviceId' of XML schema type 'xsd:string'
        std::string strDeviceId;
        /// Required element 'strDeviceKey' of XML schema type 'xsd:string'
        std::string strDeviceKey;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__login
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__login; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__login, default initialized and not managed by a soap context
        virtual ns1__login *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__login); }
      public:
        /// Constructor with default initializations
        ns1__login() : strDeviceId(), strDeviceKey(), soap() { }
        virtual ~ns1__login() { }
        /// Friend allocator used by soap_new_ns1__login(struct soap*, int)
        friend SOAP_FMAC1 ns1__login * SOAP_FMAC2 soap_instantiate_ns1__login(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:178 */
#ifndef SOAP_TYPE_ns1__loginResponse
#define SOAP_TYPE_ns1__loginResponse (18)
/* complex XML schema type 'ns1:loginResponse': */
class SOAP_CMAC ns1__loginResponse {
      public:
        /// Optional element 'return' of XML schema type 'xsd:string'
        std::string *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__loginResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__loginResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__loginResponse, default initialized and not managed by a soap context
        virtual ns1__loginResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__loginResponse); }
      public:
        /// Constructor with default initializations
        ns1__loginResponse() : return_(), soap() { }
        virtual ~ns1__loginResponse() { }
        /// Friend allocator used by soap_new_ns1__loginResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__loginResponse * SOAP_FMAC2 soap_instantiate_ns1__loginResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:180 */
#ifndef SOAP_TYPE_ns1__queryLimitSpeed
#define SOAP_TYPE_ns1__queryLimitSpeed (19)
/* complex XML schema type 'ns1:queryLimitSpeed': */
class SOAP_CMAC ns1__queryLimitSpeed {
      public:
        /// Required element 'sid' of XML schema type 'xsd:string'
        std::string sid;
        /// Required element 'strDeviceId' of XML schema type 'xsd:string'
        std::string strDeviceId;
        /// Required element 'strDirectId' of XML schema type 'xsd:string'
        std::string strDirectId;
        /// Required element 'strCarType' of XML schema type 'xsd:string'
        std::string strCarType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__queryLimitSpeed
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__queryLimitSpeed; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__queryLimitSpeed, default initialized and not managed by a soap context
        virtual ns1__queryLimitSpeed *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__queryLimitSpeed); }
      public:
        /// Constructor with default initializations
        ns1__queryLimitSpeed() : sid(), strDeviceId(), strDirectId(), strCarType(), soap() { }
        virtual ~ns1__queryLimitSpeed() { }
        /// Friend allocator used by soap_new_ns1__queryLimitSpeed(struct soap*, int)
        friend SOAP_FMAC1 ns1__queryLimitSpeed * SOAP_FMAC2 soap_instantiate_ns1__queryLimitSpeed(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:182 */
#ifndef SOAP_TYPE_ns1__queryLimitSpeedResponse
#define SOAP_TYPE_ns1__queryLimitSpeedResponse (20)
/* complex XML schema type 'ns1:queryLimitSpeedResponse': */
class SOAP_CMAC ns1__queryLimitSpeedResponse {
      public:
        /// Optional element 'return' of XML schema type 'xsd:string'
        std::string *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__queryLimitSpeedResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__queryLimitSpeedResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__queryLimitSpeedResponse, default initialized and not managed by a soap context
        virtual ns1__queryLimitSpeedResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__queryLimitSpeedResponse); }
      public:
        /// Constructor with default initializations
        ns1__queryLimitSpeedResponse() : return_(), soap() { }
        virtual ~ns1__queryLimitSpeedResponse() { }
        /// Friend allocator used by soap_new_ns1__queryLimitSpeedResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__queryLimitSpeedResponse * SOAP_FMAC2 soap_instantiate_ns1__queryLimitSpeedResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:184 */
#ifndef SOAP_TYPE_ns1__queryViolateSpeed
#define SOAP_TYPE_ns1__queryViolateSpeed (21)
/* complex XML schema type 'ns1:queryViolateSpeed': */
class SOAP_CMAC ns1__queryViolateSpeed {
      public:
        /// Required element 'sid' of XML schema type 'xsd:string'
        std::string sid;
        /// Required element 'strDeviceId' of XML schema type 'xsd:string'
        std::string strDeviceId;
        /// Required element 'strDirectId' of XML schema type 'xsd:string'
        std::string strDirectId;
        /// Required element 'strCarType' of XML schema type 'xsd:string'
        std::string strCarType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__queryViolateSpeed
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__queryViolateSpeed; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__queryViolateSpeed, default initialized and not managed by a soap context
        virtual ns1__queryViolateSpeed *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__queryViolateSpeed); }
      public:
        /// Constructor with default initializations
        ns1__queryViolateSpeed() : sid(), strDeviceId(), strDirectId(), strCarType(), soap() { }
        virtual ~ns1__queryViolateSpeed() { }
        /// Friend allocator used by soap_new_ns1__queryViolateSpeed(struct soap*, int)
        friend SOAP_FMAC1 ns1__queryViolateSpeed * SOAP_FMAC2 soap_instantiate_ns1__queryViolateSpeed(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:186 */
#ifndef SOAP_TYPE_ns1__queryViolateSpeedResponse
#define SOAP_TYPE_ns1__queryViolateSpeedResponse (22)
/* complex XML schema type 'ns1:queryViolateSpeedResponse': */
class SOAP_CMAC ns1__queryViolateSpeedResponse {
      public:
        /// Optional element 'return' of XML schema type 'xsd:string'
        std::string *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__queryViolateSpeedResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__queryViolateSpeedResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__queryViolateSpeedResponse, default initialized and not managed by a soap context
        virtual ns1__queryViolateSpeedResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__queryViolateSpeedResponse); }
      public:
        /// Constructor with default initializations
        ns1__queryViolateSpeedResponse() : return_(), soap() { }
        virtual ~ns1__queryViolateSpeedResponse() { }
        /// Friend allocator used by soap_new_ns1__queryViolateSpeedResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__queryViolateSpeedResponse * SOAP_FMAC2 soap_instantiate_ns1__queryViolateSpeedResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:188 */
#ifndef SOAP_TYPE_ns1__logout
#define SOAP_TYPE_ns1__logout (23)
/* complex XML schema type 'ns1:logout': */
class SOAP_CMAC ns1__logout {
      public:
        /// Required element 'sid' of XML schema type 'xsd:string'
        std::string sid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__logout
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__logout; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__logout, default initialized and not managed by a soap context
        virtual ns1__logout *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__logout); }
      public:
        /// Constructor with default initializations
        ns1__logout() : sid(), soap() { }
        virtual ~ns1__logout() { }
        /// Friend allocator used by soap_new_ns1__logout(struct soap*, int)
        friend SOAP_FMAC1 ns1__logout * SOAP_FMAC2 soap_instantiate_ns1__logout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:190 */
#ifndef SOAP_TYPE_ns1__logoutResponse
#define SOAP_TYPE_ns1__logoutResponse (24)
/* complex XML schema type 'ns1:logoutResponse': */
class SOAP_CMAC ns1__logoutResponse {
      public:
        /// Optional element 'return' of XML schema type 'xsd:string'
        std::string *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__logoutResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__logoutResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__logoutResponse, default initialized and not managed by a soap context
        virtual ns1__logoutResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__logoutResponse); }
      public:
        /// Constructor with default initializations
        ns1__logoutResponse() : return_(), soap() { }
        virtual ~ns1__logoutResponse() { }
        /// Friend allocator used by soap_new_ns1__logoutResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__logoutResponse * SOAP_FMAC2 soap_instantiate_ns1__logoutResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:192 */
#ifndef SOAP_TYPE_ns1__querySyncTime
#define SOAP_TYPE_ns1__querySyncTime (25)
/* complex XML schema type 'ns1:querySyncTime': */
class SOAP_CMAC ns1__querySyncTime {
      public:
        /// Required element 'sid' of XML schema type 'xsd:string'
        std::string sid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__querySyncTime
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__querySyncTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__querySyncTime, default initialized and not managed by a soap context
        virtual ns1__querySyncTime *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__querySyncTime); }
      public:
        /// Constructor with default initializations
        ns1__querySyncTime() : sid(), soap() { }
        virtual ~ns1__querySyncTime() { }
        /// Friend allocator used by soap_new_ns1__querySyncTime(struct soap*, int)
        friend SOAP_FMAC1 ns1__querySyncTime * SOAP_FMAC2 soap_instantiate_ns1__querySyncTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:194 */
#ifndef SOAP_TYPE_ns1__querySyncTimeResponse
#define SOAP_TYPE_ns1__querySyncTimeResponse (26)
/* complex XML schema type 'ns1:querySyncTimeResponse': */
class SOAP_CMAC ns1__querySyncTimeResponse {
      public:
        /// Optional element 'return' of XML schema type 'xsd:string'
        std::string *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__querySyncTimeResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__querySyncTimeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__querySyncTimeResponse, default initialized and not managed by a soap context
        virtual ns1__querySyncTimeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__querySyncTimeResponse); }
      public:
        /// Constructor with default initializations
        ns1__querySyncTimeResponse() : return_(), soap() { }
        virtual ~ns1__querySyncTimeResponse() { }
        /// Friend allocator used by soap_new_ns1__querySyncTimeResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__querySyncTimeResponse * SOAP_FMAC2 soap_instantiate_ns1__querySyncTimeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:196 */
#ifndef SOAP_TYPE_ns1__writeAlarmInfo
#define SOAP_TYPE_ns1__writeAlarmInfo (27)
/* complex XML schema type 'ns1:writeAlarmInfo': */
class SOAP_CMAC ns1__writeAlarmInfo {
      public:
        /// Required element 'sid' of XML schema type 'xsd:string'
        std::string sid;
        /// Required element 'strDeviceId' of XML schema type 'xsd:string'
        std::string strDeviceId;
        /// Required element 'strDirectionId' of XML schema type 'xsd:string'
        std::string strDirectionId;
        /// Required element 'strDircName' of XML schema type 'xsd:string'
        std::string strDircName;
        /// Required element 'strLicense' of XML schema type 'xsd:string'
        std::string strLicense;
        /// Required element 'strLicenseType' of XML schema type 'xsd:string'
        std::string strLicenseType;
        /// Required element 'strPassDateTime' of XML schema type 'xsd:string'
        std::string strPassDateTime;
        /// Required element 'strPicLocalPath1' of XML schema type 'xsd:string'
        std::string strPicLocalPath1;
        /// Required element 'strPicLocalPath2' of XML schema type 'xsd:string'
        std::string strPicLocalPath2;
        /// Required element 'strPicLocalPath3' of XML schema type 'xsd:string'
        std::string strPicLocalPath3;
        /// Required element 'strPicLocalPath4' of XML schema type 'xsd:string'
        std::string strPicLocalPath4;
        /// Required element 'strPicLocalPath5' of XML schema type 'xsd:string'
        std::string strPicLocalPath5;
        /// Required element 'strPicLocalPath6' of XML schema type 'xsd:string'
        std::string strPicLocalPath6;
        /// Required element 'strPicLocalPath7' of XML schema type 'xsd:string'
        std::string strPicLocalPath7;
        /// Required element 'strAlarmDateTime' of XML schema type 'xsd:string'
        std::string strAlarmDateTime;
        /// Required element 'strBriefCaseDescript' of XML schema type 'xsd:string'
        std::string strBriefCaseDescript;
        /// Required element 'strSuspType' of XML schema type 'xsd:string'
        std::string strSuspType;
        /// Required element 'strSuspNo' of XML schema type 'xsd:string'
        std::string strSuspNo;
        /// Required element 'strAlarmLevel' of XML schema type 'xsd:string'
        std::string strAlarmLevel;
        /// Required element 'strPlaceId' of XML schema type 'xsd:string'
        std::string strPlaceId;
        /// Required element 'strPlaceName' of XML schema type 'xsd:string'
        std::string strPlaceName;
        /// Required element 'strReserve1' of XML schema type 'xsd:string'
        std::string strReserve1;
        /// Required element 'strReserve2' of XML schema type 'xsd:string'
        std::string strReserve2;
        /// Required element 'strReserve3' of XML schema type 'xsd:string'
        std::string strReserve3;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__writeAlarmInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__writeAlarmInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__writeAlarmInfo, default initialized and not managed by a soap context
        virtual ns1__writeAlarmInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__writeAlarmInfo); }
      public:
        /// Constructor with default initializations
        ns1__writeAlarmInfo() : sid(), strDeviceId(), strDirectionId(), strDircName(), strLicense(), strLicenseType(), strPassDateTime(), strPicLocalPath1(), strPicLocalPath2(), strPicLocalPath3(), strPicLocalPath4(), strPicLocalPath5(), strPicLocalPath6(), strPicLocalPath7(), strAlarmDateTime(), strBriefCaseDescript(), strSuspType(), strSuspNo(), strAlarmLevel(), strPlaceId(), strPlaceName(), strReserve1(), strReserve2(), strReserve3(), soap() { }
        virtual ~ns1__writeAlarmInfo() { }
        /// Friend allocator used by soap_new_ns1__writeAlarmInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__writeAlarmInfo * SOAP_FMAC2 soap_instantiate_ns1__writeAlarmInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:198 */
#ifndef SOAP_TYPE_ns1__writeAlarmInfoResponse
#define SOAP_TYPE_ns1__writeAlarmInfoResponse (28)
/* complex XML schema type 'ns1:writeAlarmInfoResponse': */
class SOAP_CMAC ns1__writeAlarmInfoResponse {
      public:
        /// Optional element 'return' of XML schema type 'xsd:string'
        std::string *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__writeAlarmInfoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__writeAlarmInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__writeAlarmInfoResponse, default initialized and not managed by a soap context
        virtual ns1__writeAlarmInfoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__writeAlarmInfoResponse); }
      public:
        /// Constructor with default initializations
        ns1__writeAlarmInfoResponse() : return_(), soap() { }
        virtual ~ns1__writeAlarmInfoResponse() { }
        /// Friend allocator used by soap_new_ns1__writeAlarmInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__writeAlarmInfoResponse * SOAP_FMAC2 soap_instantiate_ns1__writeAlarmInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:200 */
#ifndef SOAP_TYPE_ns1__NWriteVehicleInfo
#define SOAP_TYPE_ns1__NWriteVehicleInfo (29)
/* complex XML schema type 'ns1:NWriteVehicleInfo': */
class SOAP_CMAC ns1__NWriteVehicleInfo {
      public:
        /// Required element 'sid' of XML schema type 'xsd:string'
        std::string sid;
        /// Required element 'strDeviceId' of XML schema type 'xsd:string'
        std::string strDeviceId;
        /// Required element 'strVehicleId' of XML schema type 'xsd:string'
        std::string strVehicleId;
        /// Required element 'strDeviceType' of XML schema type 'xsd:string'
        std::string strDeviceType;
        /// Required element 'strDirectionId' of XML schema type 'xsd:string'
        std::string strDirectionId;
        /// Required element 'strDriveWayId' of XML schema type 'xsd:string'
        std::string strDriveWayId;
        /// Required element 'strLicense' of XML schema type 'xsd:string'
        std::string strLicense;
        /// Required element 'strLicenseType' of XML schema type 'xsd:string'
        std::string strLicenseType;
        /// Required element 'strPassDateTime' of XML schema type 'xsd:string'
        std::string strPassDateTime;
        /// Required element 'strRedLightBeginTime' of XML schema type 'xsd:string'
        std::string strRedLightBeginTime;
        /// Required element 'strRedLightLast' of XML schema type 'xsd:string'
        std::string strRedLightLast;
        /// Required element 'lSpeed' of XML schema type 'xsd:long'
        LONG64 lSpeed;
        /// Required element 'lLargeLimitSpeed' of XML schema type 'xsd:long'
        LONG64 lLargeLimitSpeed;
        /// Required element 'lMiniLimitSpeed' of XML schema type 'xsd:long'
        LONG64 lMiniLimitSpeed;
        /// Required element 'strViolationType' of XML schema type 'xsd:string'
        std::string strViolationType;
        /// Required element 'strViolationType2' of XML schema type 'xsd:string'
        std::string strViolationType2;
        /// Required element 'lCarLength' of XML schema type 'xsd:long'
        LONG64 lCarLength;
        /// Required element 'strLicenseColor' of XML schema type 'xsd:string'
        std::string strLicenseColor;
        /// Required element 'strCarType' of XML schema type 'xsd:string'
        std::string strCarType;
        /// Required element 'strPicLocalPath1' of XML schema type 'xsd:string'
        std::string strPicLocalPath1;
        /// Required element 'strPicLocalPath2' of XML schema type 'xsd:string'
        std::string strPicLocalPath2;
        /// Required element 'strPicLocalPath3' of XML schema type 'xsd:string'
        std::string strPicLocalPath3;
        /// Required element 'strPicLocalPath4' of XML schema type 'xsd:string'
        std::string strPicLocalPath4;
        /// Required element 'strPicLocalPath5' of XML schema type 'xsd:string'
        std::string strPicLocalPath5;
        /// Required element 'strPicLocalPath6' of XML schema type 'xsd:string'
        std::string strPicLocalPath6;
        /// Required element 'strPicLocalPath7' of XML schema type 'xsd:string'
        std::string strPicLocalPath7;
        /// Required element 'strPicRemotePath' of XML schema type 'xsd:string'
        std::string strPicRemotePath;
        /// Required element 'strViolate' of XML schema type 'xsd:string'
        std::string strViolate;
        /// Required element 'strSendType' of XML schema type 'xsd:string'
        std::string strSendType;
        /// Required element 'strCarColor' of XML schema type 'xsd:string'
        std::string strCarColor;
        /// Required element 'strReserve1' of XML schema type 'xsd:string'
        std::string strReserve1;
        /// Required element 'strReserve2' of XML schema type 'xsd:string'
        std::string strReserve2;
        /// Required element 'strReserve3' of XML schema type 'xsd:string'
        std::string strReserve3;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__NWriteVehicleInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__NWriteVehicleInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__NWriteVehicleInfo, default initialized and not managed by a soap context
        virtual ns1__NWriteVehicleInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__NWriteVehicleInfo); }
      public:
        /// Constructor with default initializations
        ns1__NWriteVehicleInfo() : sid(), strDeviceId(), strVehicleId(), strDeviceType(), strDirectionId(), strDriveWayId(), strLicense(), strLicenseType(), strPassDateTime(), strRedLightBeginTime(), strRedLightLast(), lSpeed(), lLargeLimitSpeed(), lMiniLimitSpeed(), strViolationType(), strViolationType2(), lCarLength(), strLicenseColor(), strCarType(), strPicLocalPath1(), strPicLocalPath2(), strPicLocalPath3(), strPicLocalPath4(), strPicLocalPath5(), strPicLocalPath6(), strPicLocalPath7(), strPicRemotePath(), strViolate(), strSendType(), strCarColor(), strReserve1(), strReserve2(), strReserve3(), soap() { }
        virtual ~ns1__NWriteVehicleInfo() { }
        /// Friend allocator used by soap_new_ns1__NWriteVehicleInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__NWriteVehicleInfo * SOAP_FMAC2 soap_instantiate_ns1__NWriteVehicleInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:202 */
#ifndef SOAP_TYPE_ns1__NWriteVehicleInfoResponse
#define SOAP_TYPE_ns1__NWriteVehicleInfoResponse (30)
/* complex XML schema type 'ns1:NWriteVehicleInfoResponse': */
class SOAP_CMAC ns1__NWriteVehicleInfoResponse {
      public:
        /// Optional element 'return' of XML schema type 'xsd:string'
        std::string *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__NWriteVehicleInfoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__NWriteVehicleInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__NWriteVehicleInfoResponse, default initialized and not managed by a soap context
        virtual ns1__NWriteVehicleInfoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__NWriteVehicleInfoResponse); }
      public:
        /// Constructor with default initializations
        ns1__NWriteVehicleInfoResponse() : return_(), soap() { }
        virtual ~ns1__NWriteVehicleInfoResponse() { }
        /// Friend allocator used by soap_new_ns1__NWriteVehicleInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__NWriteVehicleInfoResponse * SOAP_FMAC2 soap_instantiate_ns1__NWriteVehicleInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:204 */
#ifndef SOAP_TYPE_ns1__NWriteVehicleInfoEx
#define SOAP_TYPE_ns1__NWriteVehicleInfoEx (31)
/* complex XML schema type 'ns1:NWriteVehicleInfoEx': */
class SOAP_CMAC ns1__NWriteVehicleInfoEx {
      public:
        /// Required element 'sid' of XML schema type 'xsd:string'
        std::string sid;
        /// Required element 'strDeviceId' of XML schema type 'xsd:string'
        std::string strDeviceId;
        /// Required element 'strVehicleId' of XML schema type 'xsd:string'
        std::string strVehicleId;
        /// Required element 'strDeviceType' of XML schema type 'xsd:string'
        std::string strDeviceType;
        /// Required element 'strDirectionId' of XML schema type 'xsd:string'
        std::string strDirectionId;
        /// Required element 'strDriveWayId' of XML schema type 'xsd:string'
        std::string strDriveWayId;
        /// Required element 'strLicense' of XML schema type 'xsd:string'
        std::string strLicense;
        /// Required element 'strLicenseType' of XML schema type 'xsd:string'
        std::string strLicenseType;
        /// Required element 'strPassDateTime' of XML schema type 'xsd:string'
        std::string strPassDateTime;
        /// Required element 'strRedLightBeginTime' of XML schema type 'xsd:string'
        std::string strRedLightBeginTime;
        /// Required element 'strRedLightLast' of XML schema type 'xsd:string'
        std::string strRedLightLast;
        /// Required element 'lSpeed' of XML schema type 'xsd:long'
        LONG64 lSpeed;
        /// Required element 'lLargeLimitSpeed' of XML schema type 'xsd:long'
        LONG64 lLargeLimitSpeed;
        /// Required element 'lMiniLimitSpeed' of XML schema type 'xsd:long'
        LONG64 lMiniLimitSpeed;
        /// Required element 'strViolationType' of XML schema type 'xsd:string'
        std::string strViolationType;
        /// Required element 'strViolationType2' of XML schema type 'xsd:string'
        std::string strViolationType2;
        /// Required element 'lCarLength' of XML schema type 'xsd:long'
        LONG64 lCarLength;
        /// Required element 'strLicenseColor' of XML schema type 'xsd:string'
        std::string strLicenseColor;
        /// Required element 'strCarType' of XML schema type 'xsd:string'
        std::string strCarType;
        /// Required element 'strPicLocalPath1' of XML schema type 'xsd:string'
        std::string strPicLocalPath1;
        /// Required element 'strPicLocalPath2' of XML schema type 'xsd:string'
        std::string strPicLocalPath2;
        /// Required element 'strPicLocalPath3' of XML schema type 'xsd:string'
        std::string strPicLocalPath3;
        /// Required element 'strPicLocalPath4' of XML schema type 'xsd:string'
        std::string strPicLocalPath4;
        /// Required element 'strPicLocalPath5' of XML schema type 'xsd:string'
        std::string strPicLocalPath5;
        /// Required element 'strPicLocalPath6' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath6;
        /// Required element 'strPicLocalPath7' of XML schema type 'xsd:string'
        std::string strPicLocalPath7;
        /// Required element 'strPicRemotePath' of XML schema type 'xsd:string'
        std::string strPicRemotePath;
        /// Required element 'strViolate' of XML schema type 'xsd:string'
        std::string strViolate;
        /// Required element 'strSendType' of XML schema type 'xsd:string'
        std::string strSendType;
        /// Required element 'strCarColor' of XML schema type 'xsd:string'
        std::string strCarColor;
        /// Required element 'strReserve1' of XML schema type 'xsd:string'
        std::string strReserve1;
        /// Required element 'strReserve2' of XML schema type 'xsd:string'
        std::string strReserve2;
        /// Required element 'strReserve3' of XML schema type 'xsd:string'
        std::string strReserve3;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__NWriteVehicleInfoEx
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__NWriteVehicleInfoEx; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__NWriteVehicleInfoEx, default initialized and not managed by a soap context
        virtual ns1__NWriteVehicleInfoEx *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__NWriteVehicleInfoEx); }
      public:
        /// Constructor with default initializations
        ns1__NWriteVehicleInfoEx() : sid(), strDeviceId(), strVehicleId(), strDeviceType(), strDirectionId(), strDriveWayId(), strLicense(), strLicenseType(), strPassDateTime(), strRedLightBeginTime(), strRedLightLast(), lSpeed(), lLargeLimitSpeed(), lMiniLimitSpeed(), strViolationType(), strViolationType2(), lCarLength(), strLicenseColor(), strCarType(), strPicLocalPath1(), strPicLocalPath2(), strPicLocalPath3(), strPicLocalPath4(), strPicLocalPath5(), strPicLocalPath6(), strPicLocalPath7(), strPicRemotePath(), strViolate(), strSendType(), strCarColor(), strReserve1(), strReserve2(), strReserve3(), soap() { }
        virtual ~ns1__NWriteVehicleInfoEx() { }
        /// Friend allocator used by soap_new_ns1__NWriteVehicleInfoEx(struct soap*, int)
        friend SOAP_FMAC1 ns1__NWriteVehicleInfoEx * SOAP_FMAC2 soap_instantiate_ns1__NWriteVehicleInfoEx(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:206 */
#ifndef SOAP_TYPE_ns1__NWriteVehicleInfoExResponse
#define SOAP_TYPE_ns1__NWriteVehicleInfoExResponse (32)
/* complex XML schema type 'ns1:NWriteVehicleInfoExResponse': */
class SOAP_CMAC ns1__NWriteVehicleInfoExResponse {
      public:
        /// Optional element 'return' of XML schema type 'xsd:string'
        std::string *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__NWriteVehicleInfoExResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__NWriteVehicleInfoExResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__NWriteVehicleInfoExResponse, default initialized and not managed by a soap context
        virtual ns1__NWriteVehicleInfoExResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__NWriteVehicleInfoExResponse); }
      public:
        /// Constructor with default initializations
        ns1__NWriteVehicleInfoExResponse() : return_(), soap() { }
        virtual ~ns1__NWriteVehicleInfoExResponse() { }
        /// Friend allocator used by soap_new_ns1__NWriteVehicleInfoExResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__NWriteVehicleInfoExResponse * SOAP_FMAC2 soap_instantiate_ns1__NWriteVehicleInfoExResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:208 */
#ifndef SOAP_TYPE_ns1__NSyncWriteVehicleInfo
#define SOAP_TYPE_ns1__NSyncWriteVehicleInfo (33)
/* complex XML schema type 'ns1:NSyncWriteVehicleInfo': */
class SOAP_CMAC ns1__NSyncWriteVehicleInfo {
      public:
        /// Required element 'sid' of XML schema type 'xsd:string'
        std::string sid;
        /// Required element 'strDeviceId' of XML schema type 'xsd:string'
        std::string strDeviceId;
        /// Required element 'strVehicleId' of XML schema type 'xsd:string'
        std::string strVehicleId;
        /// Required element 'strDeviceType' of XML schema type 'xsd:string'
        std::string strDeviceType;
        /// Required element 'strDirectionId' of XML schema type 'xsd:string'
        std::string strDirectionId;
        /// Required element 'strDriveWayId' of XML schema type 'xsd:string'
        std::string strDriveWayId;
        /// Required element 'strLicense' of XML schema type 'xsd:string'
        std::string strLicense;
        /// Required element 'strLicenseType' of XML schema type 'xsd:string'
        std::string strLicenseType;
        /// Required element 'strPassDateTime' of XML schema type 'xsd:string'
        std::string strPassDateTime;
        /// Required element 'strRedLightBeginTime' of XML schema type 'xsd:string'
        std::string strRedLightBeginTime;
        /// Required element 'strRedLightLast' of XML schema type 'xsd:string'
        std::string strRedLightLast;
        /// Required element 'lSpeed' of XML schema type 'xsd:long'
        LONG64 lSpeed;
        /// Required element 'lLargeLimitSpeed' of XML schema type 'xsd:long'
        LONG64 lLargeLimitSpeed;
        /// Required element 'lMiniLimitSpeed' of XML schema type 'xsd:long'
        LONG64 lMiniLimitSpeed;
        /// Required element 'strViolationType' of XML schema type 'xsd:string'
        std::string strViolationType;
        /// Required element 'strViolationType2' of XML schema type 'xsd:string'
        std::string strViolationType2;
        /// Required element 'lCarLength' of XML schema type 'xsd:long'
        LONG64 lCarLength;
        /// Required element 'strLicenseColor' of XML schema type 'xsd:string'
        std::string strLicenseColor;
        /// Required element 'strCarType' of XML schema type 'xsd:string'
        std::string strCarType;
        /// Required element 'strPicLocalPath1' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath1;
        /// Required element 'strPicLocalPath2' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath2;
        /// Required element 'strPicLocalPath3' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath3;
        /// Required element 'strPicLocalPath4' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath4;
        /// Required element 'strPicLocalPath5' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath5;
        /// Required element 'strPicLocalPath6' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath6;
        /// Required element 'strPicLocalPath7' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath7;
        /// Required element 'strPicRemotePath' of XML schema type 'xsd:string'
        std::string strPicRemotePath;
        /// Required element 'strViolate' of XML schema type 'xsd:string'
        std::string strViolate;
        /// Required element 'strSendType' of XML schema type 'xsd:string'
        std::string strSendType;
        /// Required element 'strCarColor' of XML schema type 'xsd:string'
        std::string strCarColor;
        /// Required element 'strReserve1' of XML schema type 'xsd:string'
        std::string strReserve1;
        /// Required element 'strReserve2' of XML schema type 'xsd:string'
        std::string strReserve2;
        /// Required element 'strReserve3' of XML schema type 'xsd:string'
        std::string strReserve3;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__NSyncWriteVehicleInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__NSyncWriteVehicleInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__NSyncWriteVehicleInfo, default initialized and not managed by a soap context
        virtual ns1__NSyncWriteVehicleInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__NSyncWriteVehicleInfo); }
      public:
        /// Constructor with default initializations
        ns1__NSyncWriteVehicleInfo() : sid(), strDeviceId(), strVehicleId(), strDeviceType(), strDirectionId(), strDriveWayId(), strLicense(), strLicenseType(), strPassDateTime(), strRedLightBeginTime(), strRedLightLast(), lSpeed(), lLargeLimitSpeed(), lMiniLimitSpeed(), strViolationType(), strViolationType2(), lCarLength(), strLicenseColor(), strCarType(), strPicLocalPath1(), strPicLocalPath2(), strPicLocalPath3(), strPicLocalPath4(), strPicLocalPath5(), strPicLocalPath6(), strPicLocalPath7(), strPicRemotePath(), strViolate(), strSendType(), strCarColor(), strReserve1(), strReserve2(), strReserve3(), soap() { }
        virtual ~ns1__NSyncWriteVehicleInfo() { }
        /// Friend allocator used by soap_new_ns1__NSyncWriteVehicleInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__NSyncWriteVehicleInfo * SOAP_FMAC2 soap_instantiate_ns1__NSyncWriteVehicleInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:210 */
#ifndef SOAP_TYPE_ns1__NSyncWriteVehicleInfoResponse
#define SOAP_TYPE_ns1__NSyncWriteVehicleInfoResponse (34)
/* complex XML schema type 'ns1:NSyncWriteVehicleInfoResponse': */
class SOAP_CMAC ns1__NSyncWriteVehicleInfoResponse {
      public:
        /// Optional element 'return' of XML schema type 'xsd:string'
        std::string *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__NSyncWriteVehicleInfoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__NSyncWriteVehicleInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__NSyncWriteVehicleInfoResponse, default initialized and not managed by a soap context
        virtual ns1__NSyncWriteVehicleInfoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__NSyncWriteVehicleInfoResponse); }
      public:
        /// Constructor with default initializations
        ns1__NSyncWriteVehicleInfoResponse() : return_(), soap() { }
        virtual ~ns1__NSyncWriteVehicleInfoResponse() { }
        /// Friend allocator used by soap_new_ns1__NSyncWriteVehicleInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__NSyncWriteVehicleInfoResponse * SOAP_FMAC2 soap_instantiate_ns1__NSyncWriteVehicleInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:212 */
#ifndef SOAP_TYPE_ns1__WriteFlux
#define SOAP_TYPE_ns1__WriteFlux (35)
/* complex XML schema type 'ns1:WriteFlux': */
class SOAP_CMAC ns1__WriteFlux {
      public:
        /// Required element 'sid' of XML schema type 'xsd:string'
        std::string sid;
        /// Required element 'lpszDeviceId' of XML schema type 'xsd:string'
        std::string lpszDeviceId;
        /// Required element 'lpszDiretId' of XML schema type 'xsd:string'
        std::string lpszDiretId;
        /// Required element 'lpszDriveWay' of XML schema type 'xsd:string'
        std::string lpszDriveWay;
        /// Required element 'lpszPeriodBegin' of XML schema type 'xsd:string'
        std::string lpszPeriodBegin;
        /// Required element 'lpszPeriodEnd' of XML schema type 'xsd:string'
        std::string lpszPeriodEnd;
        /// Required element 'lFlux' of XML schema type 'xsd:long'
        LONG64 lFlux;
        /// Required element 'lpszReserve1' of XML schema type 'xsd:string'
        std::string lpszReserve1;
        /// Required element 'lpszReserve2' of XML schema type 'xsd:string'
        std::string lpszReserve2;
        /// Required element 'lpszReserve3' of XML schema type 'xsd:string'
        std::string lpszReserve3;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__WriteFlux
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__WriteFlux; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__WriteFlux, default initialized and not managed by a soap context
        virtual ns1__WriteFlux *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__WriteFlux); }
      public:
        /// Constructor with default initializations
        ns1__WriteFlux() : sid(), lpszDeviceId(), lpszDiretId(), lpszDriveWay(), lpszPeriodBegin(), lpszPeriodEnd(), lFlux(), lpszReserve1(), lpszReserve2(), lpszReserve3(), soap() { }
        virtual ~ns1__WriteFlux() { }
        /// Friend allocator used by soap_new_ns1__WriteFlux(struct soap*, int)
        friend SOAP_FMAC1 ns1__WriteFlux * SOAP_FMAC2 soap_instantiate_ns1__WriteFlux(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:214 */
#ifndef SOAP_TYPE_ns1__WriteFluxResponse
#define SOAP_TYPE_ns1__WriteFluxResponse (36)
/* complex XML schema type 'ns1:WriteFluxResponse': */
class SOAP_CMAC ns1__WriteFluxResponse {
      public:
        /// Optional element 'return' of XML schema type 'xsd:string'
        std::string *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__WriteFluxResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__WriteFluxResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__WriteFluxResponse, default initialized and not managed by a soap context
        virtual ns1__WriteFluxResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__WriteFluxResponse); }
      public:
        /// Constructor with default initializations
        ns1__WriteFluxResponse() : return_(), soap() { }
        virtual ~ns1__WriteFluxResponse() { }
        /// Friend allocator used by soap_new_ns1__WriteFluxResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__WriteFluxResponse * SOAP_FMAC2 soap_instantiate_ns1__WriteFluxResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:216 */
#ifndef SOAP_TYPE_ns1__NWriteDeviceStatus
#define SOAP_TYPE_ns1__NWriteDeviceStatus (37)
/* complex XML schema type 'ns1:NWriteDeviceStatus': */
class SOAP_CMAC ns1__NWriteDeviceStatus {
      public:
        /// Required element 'sid' of XML schema type 'xsd:string'
        std::string sid;
        /// Required element 'strDeviceId' of XML schema type 'xsd:string'
        std::string strDeviceId;
        /// Required element 'strVehDetectorStatus' of XML schema type 'xsd:string'
        std::string strVehDetectorStatus;
        /// Required element 'strVideoDeviceStatus' of XML schema type 'xsd:string'
        std::string strVideoDeviceStatus;
        /// Required element 'strGatherCardStatus' of XML schema type 'xsd:string'
        std::string strGatherCardStatus;
        /// Required element 'strTemperature' of XML schema type 'xsd:string'
        std::string strTemperature;
        /// Required element 'strReserveOne' of XML schema type 'xsd:string'
        std::string strReserveOne;
        /// Required element 'strReserveTwo' of XML schema type 'xsd:string'
        std::string strReserveTwo;
        /// Required element 'strReserveThree' of XML schema type 'xsd:string'
        std::string strReserveThree;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__NWriteDeviceStatus
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__NWriteDeviceStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__NWriteDeviceStatus, default initialized and not managed by a soap context
        virtual ns1__NWriteDeviceStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__NWriteDeviceStatus); }
      public:
        /// Constructor with default initializations
        ns1__NWriteDeviceStatus() : sid(), strDeviceId(), strVehDetectorStatus(), strVideoDeviceStatus(), strGatherCardStatus(), strTemperature(), strReserveOne(), strReserveTwo(), strReserveThree(), soap() { }
        virtual ~ns1__NWriteDeviceStatus() { }
        /// Friend allocator used by soap_new_ns1__NWriteDeviceStatus(struct soap*, int)
        friend SOAP_FMAC1 ns1__NWriteDeviceStatus * SOAP_FMAC2 soap_instantiate_ns1__NWriteDeviceStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:218 */
#ifndef SOAP_TYPE_ns1__NWriteDeviceStatusResponse
#define SOAP_TYPE_ns1__NWriteDeviceStatusResponse (38)
/* complex XML schema type 'ns1:NWriteDeviceStatusResponse': */
class SOAP_CMAC ns1__NWriteDeviceStatusResponse {
      public:
        /// Optional element 'return' of XML schema type 'xsd:string'
        std::string *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__NWriteDeviceStatusResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__NWriteDeviceStatusResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__NWriteDeviceStatusResponse, default initialized and not managed by a soap context
        virtual ns1__NWriteDeviceStatusResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__NWriteDeviceStatusResponse); }
      public:
        /// Constructor with default initializations
        ns1__NWriteDeviceStatusResponse() : return_(), soap() { }
        virtual ~ns1__NWriteDeviceStatusResponse() { }
        /// Friend allocator used by soap_new_ns1__NWriteDeviceStatusResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__NWriteDeviceStatusResponse * SOAP_FMAC2 soap_instantiate_ns1__NWriteDeviceStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:220 */
#ifndef SOAP_TYPE_ns1__NSyncWriteMobileEPVInfo
#define SOAP_TYPE_ns1__NSyncWriteMobileEPVInfo (39)
/* complex XML schema type 'ns1:NSyncWriteMobileEPVInfo': */
class SOAP_CMAC ns1__NSyncWriteMobileEPVInfo {
      public:
        /// Required element 'sid' of XML schema type 'xsd:string'
        std::string sid;
        /// Required element 'strDeviceId' of XML schema type 'xsd:string'
        std::string strDeviceId;
        /// Required element 'strVehicleId' of XML schema type 'xsd:string'
        std::string strVehicleId;
        /// Required element 'strDeviceType' of XML schema type 'xsd:string'
        std::string strDeviceType;
        /// Required element 'strDirectionId' of XML schema type 'xsd:string'
        std::string strDirectionId;
        /// Required element 'strDriveWayId' of XML schema type 'xsd:string'
        std::string strDriveWayId;
        /// Required element 'strLicense' of XML schema type 'xsd:string'
        std::string strLicense;
        /// Required element 'strLicenseType' of XML schema type 'xsd:string'
        std::string strLicenseType;
        /// Required element 'strPassDateTime' of XML schema type 'xsd:string'
        std::string strPassDateTime;
        /// Required element 'strRedLightBeginTime' of XML schema type 'xsd:string'
        std::string strRedLightBeginTime;
        /// Required element 'strRedLightLast' of XML schema type 'xsd:string'
        std::string strRedLightLast;
        /// Required element 'lSpeed' of XML schema type 'xsd:long'
        LONG64 lSpeed;
        /// Required element 'lLargeLimitSpeed' of XML schema type 'xsd:long'
        LONG64 lLargeLimitSpeed;
        /// Required element 'lMiniLimitSpeed' of XML schema type 'xsd:long'
        LONG64 lMiniLimitSpeed;
        /// Required element 'strViolationType' of XML schema type 'xsd:string'
        std::string strViolationType;
        /// Required element 'strViolationType2' of XML schema type 'xsd:string'
        std::string strViolationType2;
        /// Required element 'lCarLength' of XML schema type 'xsd:long'
        LONG64 lCarLength;
        /// Required element 'strLicenseColor' of XML schema type 'xsd:string'
        std::string strLicenseColor;
        /// Required element 'strCarType' of XML schema type 'xsd:string'
        std::string strCarType;
        /// Required element 'strPicLocalPath1' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath1;
        /// Required element 'strPicLocalPath2' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath2;
        /// Required element 'strPicLocalPath3' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath3;
        /// Required element 'strPicLocalPath4' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath4;
        /// Required element 'strPicLocalPath5' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath5;
        /// Required element 'strPicLocalPath6' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath6;
        /// Required element 'strPicLocalPath7' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath7;
        /// Required element 'strPicRemotePath' of XML schema type 'xsd:string'
        std::string strPicRemotePath;
        /// Required element 'strViolate' of XML schema type 'xsd:string'
        std::string strViolate;
        /// Required element 'strSendType' of XML schema type 'xsd:string'
        std::string strSendType;
        /// Required element 'strVioPlaceId' of XML schema type 'xsd:string'
        std::string strVioPlaceId;
        /// Required element 'strVioPlaceName' of XML schema type 'xsd:string'
        std::string strVioPlaceName;
        /// Required element 'strCollectDept' of XML schema type 'xsd:string'
        std::string strCollectDept;
        /// Required element 'strDataSrc' of XML schema type 'xsd:string'
        std::string strDataSrc;
        /// Required element 'lRoadKLMS' of XML schema type 'xsd:long'
        LONG64 lRoadKLMS;
        /// Required element 'lRoadMs' of XML schema type 'xsd:long'
        LONG64 lRoadMs;
        /// Required element 'strCarColor' of XML schema type 'xsd:string'
        std::string strCarColor;
        /// Required element 'strReserve1' of XML schema type 'xsd:string'
        std::string strReserve1;
        /// Required element 'strReserve2' of XML schema type 'xsd:string'
        std::string strReserve2;
        /// Required element 'strReserve3' of XML schema type 'xsd:string'
        std::string strReserve3;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__NSyncWriteMobileEPVInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__NSyncWriteMobileEPVInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__NSyncWriteMobileEPVInfo, default initialized and not managed by a soap context
        virtual ns1__NSyncWriteMobileEPVInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__NSyncWriteMobileEPVInfo); }
      public:
        /// Constructor with default initializations
        ns1__NSyncWriteMobileEPVInfo() : sid(), strDeviceId(), strVehicleId(), strDeviceType(), strDirectionId(), strDriveWayId(), strLicense(), strLicenseType(), strPassDateTime(), strRedLightBeginTime(), strRedLightLast(), lSpeed(), lLargeLimitSpeed(), lMiniLimitSpeed(), strViolationType(), strViolationType2(), lCarLength(), strLicenseColor(), strCarType(), strPicLocalPath1(), strPicLocalPath2(), strPicLocalPath3(), strPicLocalPath4(), strPicLocalPath5(), strPicLocalPath6(), strPicLocalPath7(), strPicRemotePath(), strViolate(), strSendType(), strVioPlaceId(), strVioPlaceName(), strCollectDept(), strDataSrc(), lRoadKLMS(), lRoadMs(), strCarColor(), strReserve1(), strReserve2(), strReserve3(), soap() { }
        virtual ~ns1__NSyncWriteMobileEPVInfo() { }
        /// Friend allocator used by soap_new_ns1__NSyncWriteMobileEPVInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__NSyncWriteMobileEPVInfo * SOAP_FMAC2 soap_instantiate_ns1__NSyncWriteMobileEPVInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:222 */
#ifndef SOAP_TYPE_ns1__NSyncWriteMobileEPVInfoResponse
#define SOAP_TYPE_ns1__NSyncWriteMobileEPVInfoResponse (40)
/* complex XML schema type 'ns1:NSyncWriteMobileEPVInfoResponse': */
class SOAP_CMAC ns1__NSyncWriteMobileEPVInfoResponse {
      public:
        /// Optional element 'return' of XML schema type 'xsd:string'
        std::string *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__NSyncWriteMobileEPVInfoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__NSyncWriteMobileEPVInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__NSyncWriteMobileEPVInfoResponse, default initialized and not managed by a soap context
        virtual ns1__NSyncWriteMobileEPVInfoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__NSyncWriteMobileEPVInfoResponse); }
      public:
        /// Constructor with default initializations
        ns1__NSyncWriteMobileEPVInfoResponse() : return_(), soap() { }
        virtual ~ns1__NSyncWriteMobileEPVInfoResponse() { }
        /// Friend allocator used by soap_new_ns1__NSyncWriteMobileEPVInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__NSyncWriteMobileEPVInfoResponse * SOAP_FMAC2 soap_instantiate_ns1__NSyncWriteMobileEPVInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:224 */
#ifndef SOAP_TYPE_ns1__NSyncWriteVioInfo
#define SOAP_TYPE_ns1__NSyncWriteVioInfo (41)
/* complex XML schema type 'ns1:NSyncWriteVioInfo': */
class SOAP_CMAC ns1__NSyncWriteVioInfo {
      public:
        /// Required element 'sid' of XML schema type 'xsd:string'
        std::string sid;
        /// Required element 'strDeviceId' of XML schema type 'xsd:string'
        std::string strDeviceId;
        /// Required element 'strVehicleId' of XML schema type 'xsd:string'
        std::string strVehicleId;
        /// Required element 'strDeviceType' of XML schema type 'xsd:string'
        std::string strDeviceType;
        /// Required element 'strDirectionId' of XML schema type 'xsd:string'
        std::string strDirectionId;
        /// Required element 'strDriveWayId' of XML schema type 'xsd:string'
        std::string strDriveWayId;
        /// Required element 'strLicense' of XML schema type 'xsd:string'
        std::string strLicense;
        /// Required element 'strLicenseType' of XML schema type 'xsd:string'
        std::string strLicenseType;
        /// Required element 'strPassDateTime' of XML schema type 'xsd:string'
        std::string strPassDateTime;
        /// Required element 'strRedLightBeginTime' of XML schema type 'xsd:string'
        std::string strRedLightBeginTime;
        /// Required element 'strRedLightLast' of XML schema type 'xsd:string'
        std::string strRedLightLast;
        /// Required element 'lSpeed' of XML schema type 'xsd:long'
        LONG64 lSpeed;
        /// Required element 'lLargeLimitSpeed' of XML schema type 'xsd:long'
        LONG64 lLargeLimitSpeed;
        /// Required element 'lMiniLimitSpeed' of XML schema type 'xsd:long'
        LONG64 lMiniLimitSpeed;
        /// Required element 'strViolationType' of XML schema type 'xsd:string'
        std::string strViolationType;
        /// Required element 'strViolationType2' of XML schema type 'xsd:string'
        std::string strViolationType2;
        /// Required element 'lCarLength' of XML schema type 'xsd:long'
        LONG64 lCarLength;
        /// Required element 'strLicenseColor' of XML schema type 'xsd:string'
        std::string strLicenseColor;
        /// Required element 'strCarType' of XML schema type 'xsd:string'
        std::string strCarType;
        /// Required element 'strPicLocalPath1' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath1;
        /// Required element 'strPicLocalPath2' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath2;
        /// Required element 'strPicLocalPath3' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath3;
        /// Required element 'strPicLocalPath4' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath4;
        /// Required element 'strPicLocalPath5' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath5;
        /// Required element 'strPicLocalPath6' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath6;
        /// Required element 'strPicLocalPath7' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary strPicLocalPath7;
        /// Required element 'strPicRemotePath' of XML schema type 'xsd:string'
        std::string strPicRemotePath;
        /// Required element 'strViolate' of XML schema type 'xsd:string'
        std::string strViolate;
        /// Required element 'strSendType' of XML schema type 'xsd:string'
        std::string strSendType;
        /// Required element 'strVioPlaceId' of XML schema type 'xsd:string'
        std::string strVioPlaceId;
        /// Required element 'strVioPlaceName' of XML schema type 'xsd:string'
        std::string strVioPlaceName;
        /// Required element 'strCollectDept' of XML schema type 'xsd:string'
        std::string strCollectDept;
        /// Required element 'strDataSrc' of XML schema type 'xsd:string'
        std::string strDataSrc;
        /// Required element 'lRoadKLMS' of XML schema type 'xsd:long'
        LONG64 lRoadKLMS;
        /// Required element 'lRoadMs' of XML schema type 'xsd:long'
        LONG64 lRoadMs;
        /// Required element 'strCarColor' of XML schema type 'xsd:string'
        std::string strCarColor;
        /// Required element 'strPassDateTime2' of XML schema type 'xsd:string'
        std::string strPassDateTime2;
        /// Required element 'strVioPlaceId2' of XML schema type 'xsd:string'
        std::string strVioPlaceId2;
        /// Required element 'strVioPlaceName2' of XML schema type 'xsd:string'
        std::string strVioPlaceName2;
        /// Required element 'strReserve1' of XML schema type 'xsd:string'
        std::string strReserve1;
        /// Required element 'strReserve2' of XML schema type 'xsd:string'
        std::string strReserve2;
        /// Required element 'strReserve3' of XML schema type 'xsd:string'
        std::string strReserve3;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__NSyncWriteVioInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__NSyncWriteVioInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__NSyncWriteVioInfo, default initialized and not managed by a soap context
        virtual ns1__NSyncWriteVioInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__NSyncWriteVioInfo); }
      public:
        /// Constructor with default initializations
        ns1__NSyncWriteVioInfo() : sid(), strDeviceId(), strVehicleId(), strDeviceType(), strDirectionId(), strDriveWayId(), strLicense(), strLicenseType(), strPassDateTime(), strRedLightBeginTime(), strRedLightLast(), lSpeed(), lLargeLimitSpeed(), lMiniLimitSpeed(), strViolationType(), strViolationType2(), lCarLength(), strLicenseColor(), strCarType(), strPicLocalPath1(), strPicLocalPath2(), strPicLocalPath3(), strPicLocalPath4(), strPicLocalPath5(), strPicLocalPath6(), strPicLocalPath7(), strPicRemotePath(), strViolate(), strSendType(), strVioPlaceId(), strVioPlaceName(), strCollectDept(), strDataSrc(), lRoadKLMS(), lRoadMs(), strCarColor(), strPassDateTime2(), strVioPlaceId2(), strVioPlaceName2(), strReserve1(), strReserve2(), strReserve3(), soap() { }
        virtual ~ns1__NSyncWriteVioInfo() { }
        /// Friend allocator used by soap_new_ns1__NSyncWriteVioInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__NSyncWriteVioInfo * SOAP_FMAC2 soap_instantiate_ns1__NSyncWriteVioInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:226 */
#ifndef SOAP_TYPE_ns1__NSyncWriteVioInfoResponse
#define SOAP_TYPE_ns1__NSyncWriteVioInfoResponse (42)
/* complex XML schema type 'ns1:NSyncWriteVioInfoResponse': */
class SOAP_CMAC ns1__NSyncWriteVioInfoResponse {
      public:
        /// Optional element 'return' of XML schema type 'xsd:string'
        std::string *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__NSyncWriteVioInfoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__NSyncWriteVioInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__NSyncWriteVioInfoResponse, default initialized and not managed by a soap context
        virtual ns1__NSyncWriteVioInfoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__NSyncWriteVioInfoResponse); }
      public:
        /// Constructor with default initializations
        ns1__NSyncWriteVioInfoResponse() : return_(), soap() { }
        virtual ~ns1__NSyncWriteVioInfoResponse() { }
        /// Friend allocator used by soap_new_ns1__NSyncWriteVioInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__NSyncWriteVioInfoResponse * SOAP_FMAC2 soap_instantiate_ns1__NSyncWriteVioInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:228 */
#ifndef SOAP_TYPE_ns1__NWritePassStat
#define SOAP_TYPE_ns1__NWritePassStat (43)
/* complex XML schema type 'ns1:NWritePassStat': */
class SOAP_CMAC ns1__NWritePassStat {
      public:
        /// Required element 'sid' of XML schema type 'xsd:string'
        std::string sid;
        /// Required element 'strDeviceId' of XML schema type 'xsd:string'
        std::string strDeviceId;
        /// Required element 'strDeviceType' of XML schema type 'xsd:string'
        std::string strDeviceType;
        /// Required element 'strDirectionId' of XML schema type 'xsd:string'
        std::string strDirectionId;
        /// Required element 'strDriveWayId' of XML schema type 'xsd:string'
        std::string strDriveWayId;
        /// Required element 'strPassStatTime' of XML schema type 'xsd:string'
        std::string strPassStatTime;
        /// Required element 'lPassCount' of XML schema type 'xsd:long'
        LONG64 lPassCount;
        /// Required element 'lSuccessCount' of XML schema type 'xsd:long'
        LONG64 lSuccessCount;
        /// Required element 'lTimelyCount' of XML schema type 'xsd:long'
        LONG64 lTimelyCount;
        /// Required element 'strReserve1' of XML schema type 'xsd:string'
        std::string strReserve1;
        /// Required element 'strReserve2' of XML schema type 'xsd:string'
        std::string strReserve2;
        /// Required element 'strReserve3' of XML schema type 'xsd:string'
        std::string strReserve3;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__NWritePassStat
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__NWritePassStat; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__NWritePassStat, default initialized and not managed by a soap context
        virtual ns1__NWritePassStat *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__NWritePassStat); }
      public:
        /// Constructor with default initializations
        ns1__NWritePassStat() : sid(), strDeviceId(), strDeviceType(), strDirectionId(), strDriveWayId(), strPassStatTime(), lPassCount(), lSuccessCount(), lTimelyCount(), strReserve1(), strReserve2(), strReserve3(), soap() { }
        virtual ~ns1__NWritePassStat() { }
        /// Friend allocator used by soap_new_ns1__NWritePassStat(struct soap*, int)
        friend SOAP_FMAC1 ns1__NWritePassStat * SOAP_FMAC2 soap_instantiate_ns1__NWritePassStat(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:230 */
#ifndef SOAP_TYPE_ns1__NWritePassStatResponse
#define SOAP_TYPE_ns1__NWritePassStatResponse (44)
/* complex XML schema type 'ns1:NWritePassStatResponse': */
class SOAP_CMAC ns1__NWritePassStatResponse {
      public:
        /// Optional element 'return' of XML schema type 'xsd:string'
        std::string *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__NWritePassStatResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__NWritePassStatResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__NWritePassStatResponse, default initialized and not managed by a soap context
        virtual ns1__NWritePassStatResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__NWritePassStatResponse); }
      public:
        /// Constructor with default initializations
        ns1__NWritePassStatResponse() : return_(), soap() { }
        virtual ~ns1__NWritePassStatResponse() { }
        /// Friend allocator used by soap_new_ns1__NWritePassStatResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__NWritePassStatResponse * SOAP_FMAC2 soap_instantiate_ns1__NWritePassStatResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:232 */
#ifndef SOAP_TYPE_ns1__SyncWriteVehPassInfo
#define SOAP_TYPE_ns1__SyncWriteVehPassInfo (45)
/* complex XML schema type 'ns1:SyncWriteVehPassInfo': */
class SOAP_CMAC ns1__SyncWriteVehPassInfo {
      public:
        /// Required element 'sid' of XML schema type 'xsd:string'
        std::string sid;
        /// Required element 'xmlParam' of XML schema type 'xsd:string'
        std::string xmlParam;
        /// Required element 'pic1' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary pic1;
        /// Required element 'pic2' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary pic2;
        /// Required element 'pic3' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary pic3;
        /// Required element 'pic4' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary pic4;
        /// Required element 'pic5' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary pic5;
        /// Required element 'pic6' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary pic6;
        /// Required element 'video' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary video;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SyncWriteVehPassInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SyncWriteVehPassInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SyncWriteVehPassInfo, default initialized and not managed by a soap context
        virtual ns1__SyncWriteVehPassInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SyncWriteVehPassInfo); }
      public:
        /// Constructor with default initializations
        ns1__SyncWriteVehPassInfo() : sid(), xmlParam(), pic1(), pic2(), pic3(), pic4(), pic5(), pic6(), video(), soap() { }
        virtual ~ns1__SyncWriteVehPassInfo() { }
        /// Friend allocator used by soap_new_ns1__SyncWriteVehPassInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__SyncWriteVehPassInfo * SOAP_FMAC2 soap_instantiate_ns1__SyncWriteVehPassInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:234 */
#ifndef SOAP_TYPE_ns1__SyncWriteVehPassInfoResponse
#define SOAP_TYPE_ns1__SyncWriteVehPassInfoResponse (46)
/* complex XML schema type 'ns1:SyncWriteVehPassInfoResponse': */
class SOAP_CMAC ns1__SyncWriteVehPassInfoResponse {
      public:
        /// Optional element 'return' of XML schema type 'xsd:string'
        std::string *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SyncWriteVehPassInfoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SyncWriteVehPassInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SyncWriteVehPassInfoResponse, default initialized and not managed by a soap context
        virtual ns1__SyncWriteVehPassInfoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SyncWriteVehPassInfoResponse); }
      public:
        /// Constructor with default initializations
        ns1__SyncWriteVehPassInfoResponse() : return_(), soap() { }
        virtual ~ns1__SyncWriteVehPassInfoResponse() { }
        /// Friend allocator used by soap_new_ns1__SyncWriteVehPassInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__SyncWriteVehPassInfoResponse * SOAP_FMAC2 soap_instantiate_ns1__SyncWriteVehPassInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:236 */
#ifndef SOAP_TYPE_ns1__WriteVehPassInfo
#define SOAP_TYPE_ns1__WriteVehPassInfo (47)
/* complex XML schema type 'ns1:WriteVehPassInfo': */
class SOAP_CMAC ns1__WriteVehPassInfo {
      public:
        /// Required element 'sid' of XML schema type 'xsd:string'
        std::string sid;
        /// Required element 'xmlParam' of XML schema type 'xsd:string'
        std::string xmlParam;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__WriteVehPassInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__WriteVehPassInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__WriteVehPassInfo, default initialized and not managed by a soap context
        virtual ns1__WriteVehPassInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__WriteVehPassInfo); }
      public:
        /// Constructor with default initializations
        ns1__WriteVehPassInfo() : sid(), xmlParam(), soap() { }
        virtual ~ns1__WriteVehPassInfo() { }
        /// Friend allocator used by soap_new_ns1__WriteVehPassInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__WriteVehPassInfo * SOAP_FMAC2 soap_instantiate_ns1__WriteVehPassInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:238 */
#ifndef SOAP_TYPE_ns1__WriteVehPassInfoResponse
#define SOAP_TYPE_ns1__WriteVehPassInfoResponse (48)
/* complex XML schema type 'ns1:WriteVehPassInfoResponse': */
class SOAP_CMAC ns1__WriteVehPassInfoResponse {
      public:
        /// Optional element 'return' of XML schema type 'xsd:string'
        std::string *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__WriteVehPassInfoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__WriteVehPassInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__WriteVehPassInfoResponse, default initialized and not managed by a soap context
        virtual ns1__WriteVehPassInfoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__WriteVehPassInfoResponse); }
      public:
        /// Constructor with default initializations
        ns1__WriteVehPassInfoResponse() : return_(), soap() { }
        virtual ~ns1__WriteVehPassInfoResponse() { }
        /// Friend allocator used by soap_new_ns1__WriteVehPassInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__WriteVehPassInfoResponse * SOAP_FMAC2 soap_instantiate_ns1__WriteVehPassInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:240 */
#ifndef SOAP_TYPE_ns1__SyncWriteAreaSpeed
#define SOAP_TYPE_ns1__SyncWriteAreaSpeed (49)
/* complex XML schema type 'ns1:SyncWriteAreaSpeed': */
class SOAP_CMAC ns1__SyncWriteAreaSpeed {
      public:
        /// Required element 'sid' of XML schema type 'xsd:string'
        std::string sid;
        /// Required element 'xmlParam' of XML schema type 'xsd:string'
        std::string xmlParam;
        /// Required element 'pic1' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary pic1;
        /// Required element 'pic2' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary pic2;
        /// Required element 'pic3' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary pic3;
        /// Required element 'pic4' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary pic4;
        /// Required element 'pic5' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary pic5;
        /// Required element 'pic6' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary pic6;
        /// Required element 'video' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary video;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SyncWriteAreaSpeed
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SyncWriteAreaSpeed; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SyncWriteAreaSpeed, default initialized and not managed by a soap context
        virtual ns1__SyncWriteAreaSpeed *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SyncWriteAreaSpeed); }
      public:
        /// Constructor with default initializations
        ns1__SyncWriteAreaSpeed() : sid(), xmlParam(), pic1(), pic2(), pic3(), pic4(), pic5(), pic6(), video(), soap() { }
        virtual ~ns1__SyncWriteAreaSpeed() { }
        /// Friend allocator used by soap_new_ns1__SyncWriteAreaSpeed(struct soap*, int)
        friend SOAP_FMAC1 ns1__SyncWriteAreaSpeed * SOAP_FMAC2 soap_instantiate_ns1__SyncWriteAreaSpeed(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:242 */
#ifndef SOAP_TYPE_ns1__SyncWriteAreaSpeedResponse
#define SOAP_TYPE_ns1__SyncWriteAreaSpeedResponse (50)
/* complex XML schema type 'ns1:SyncWriteAreaSpeedResponse': */
class SOAP_CMAC ns1__SyncWriteAreaSpeedResponse {
      public:
        /// Optional element 'return' of XML schema type 'xsd:string'
        std::string *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SyncWriteAreaSpeedResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SyncWriteAreaSpeedResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SyncWriteAreaSpeedResponse, default initialized and not managed by a soap context
        virtual ns1__SyncWriteAreaSpeedResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SyncWriteAreaSpeedResponse); }
      public:
        /// Constructor with default initializations
        ns1__SyncWriteAreaSpeedResponse() : return_(), soap() { }
        virtual ~ns1__SyncWriteAreaSpeedResponse() { }
        /// Friend allocator used by soap_new_ns1__SyncWriteAreaSpeedResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__SyncWriteAreaSpeedResponse * SOAP_FMAC2 soap_instantiate_ns1__SyncWriteAreaSpeedResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:244 */
#ifndef SOAP_TYPE_ns1__WriteAreaSpeed
#define SOAP_TYPE_ns1__WriteAreaSpeed (51)
/* complex XML schema type 'ns1:WriteAreaSpeed': */
class SOAP_CMAC ns1__WriteAreaSpeed {
      public:
        /// Required element 'sid' of XML schema type 'xsd:string'
        std::string sid;
        /// Required element 'xmlParam' of XML schema type 'xsd:string'
        std::string xmlParam;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__WriteAreaSpeed
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__WriteAreaSpeed; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__WriteAreaSpeed, default initialized and not managed by a soap context
        virtual ns1__WriteAreaSpeed *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__WriteAreaSpeed); }
      public:
        /// Constructor with default initializations
        ns1__WriteAreaSpeed() : sid(), xmlParam(), soap() { }
        virtual ~ns1__WriteAreaSpeed() { }
        /// Friend allocator used by soap_new_ns1__WriteAreaSpeed(struct soap*, int)
        friend SOAP_FMAC1 ns1__WriteAreaSpeed * SOAP_FMAC2 soap_instantiate_ns1__WriteAreaSpeed(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:246 */
#ifndef SOAP_TYPE_ns1__WriteAreaSpeedResponse
#define SOAP_TYPE_ns1__WriteAreaSpeedResponse (52)
/* complex XML schema type 'ns1:WriteAreaSpeedResponse': */
class SOAP_CMAC ns1__WriteAreaSpeedResponse {
      public:
        /// Optional element 'return' of XML schema type 'xsd:string'
        std::string *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__WriteAreaSpeedResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__WriteAreaSpeedResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__WriteAreaSpeedResponse, default initialized and not managed by a soap context
        virtual ns1__WriteAreaSpeedResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__WriteAreaSpeedResponse); }
      public:
        /// Constructor with default initializations
        ns1__WriteAreaSpeedResponse() : return_(), soap() { }
        virtual ~ns1__WriteAreaSpeedResponse() { }
        /// Friend allocator used by soap_new_ns1__WriteAreaSpeedResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__WriteAreaSpeedResponse * SOAP_FMAC2 soap_instantiate_ns1__WriteAreaSpeedResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:2042 */
#ifndef SOAP_TYPE___ns1__syncWriteVehicleInfo
#define SOAP_TYPE___ns1__syncWriteVehicleInfo (60)
/* Wrapper: */
struct SOAP_CMAC __ns1__syncWriteVehicleInfo {
      public:
        /** Optional element 'ns1:syncWriteVehicleInfo' of XML schema type 'ns1:syncWriteVehicleInfo' */
        ns1__syncWriteVehicleInfo *ns1__syncWriteVehicleInfo_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__syncWriteVehicleInfo */
        long soap_type() const { return SOAP_TYPE___ns1__syncWriteVehicleInfo; }
        /** Constructor with member initializations */
        __ns1__syncWriteVehicleInfo() : ns1__syncWriteVehicleInfo_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__syncWriteVehicleInfo * SOAP_FMAC2 soap_instantiate___ns1__syncWriteVehicleInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:2112 */
#ifndef SOAP_TYPE___ns1__writeVehicleInfo
#define SOAP_TYPE___ns1__writeVehicleInfo (64)
/* Wrapper: */
struct SOAP_CMAC __ns1__writeVehicleInfo {
      public:
        /** Optional element 'ns1:writeVehicleInfo' of XML schema type 'ns1:writeVehicleInfo' */
        ns1__writeVehicleInfo *ns1__writeVehicleInfo_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__writeVehicleInfo */
        long soap_type() const { return SOAP_TYPE___ns1__writeVehicleInfo; }
        /** Constructor with member initializations */
        __ns1__writeVehicleInfo() : ns1__writeVehicleInfo_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__writeVehicleInfo * SOAP_FMAC2 soap_instantiate___ns1__writeVehicleInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:2182 */
#ifndef SOAP_TYPE___ns1__login
#define SOAP_TYPE___ns1__login (68)
/* Wrapper: */
struct SOAP_CMAC __ns1__login {
      public:
        /** Optional element 'ns1:login' of XML schema type 'ns1:login' */
        ns1__login *ns1__login_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__login */
        long soap_type() const { return SOAP_TYPE___ns1__login; }
        /** Constructor with member initializations */
        __ns1__login() : ns1__login_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__login * SOAP_FMAC2 soap_instantiate___ns1__login(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:2252 */
#ifndef SOAP_TYPE___ns1__queryLimitSpeed
#define SOAP_TYPE___ns1__queryLimitSpeed (72)
/* Wrapper: */
struct SOAP_CMAC __ns1__queryLimitSpeed {
      public:
        /** Optional element 'ns1:queryLimitSpeed' of XML schema type 'ns1:queryLimitSpeed' */
        ns1__queryLimitSpeed *ns1__queryLimitSpeed_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__queryLimitSpeed */
        long soap_type() const { return SOAP_TYPE___ns1__queryLimitSpeed; }
        /** Constructor with member initializations */
        __ns1__queryLimitSpeed() : ns1__queryLimitSpeed_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__queryLimitSpeed * SOAP_FMAC2 soap_instantiate___ns1__queryLimitSpeed(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:2322 */
#ifndef SOAP_TYPE___ns1__queryViolateSpeed
#define SOAP_TYPE___ns1__queryViolateSpeed (76)
/* Wrapper: */
struct SOAP_CMAC __ns1__queryViolateSpeed {
      public:
        /** Optional element 'ns1:queryViolateSpeed' of XML schema type 'ns1:queryViolateSpeed' */
        ns1__queryViolateSpeed *ns1__queryViolateSpeed_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__queryViolateSpeed */
        long soap_type() const { return SOAP_TYPE___ns1__queryViolateSpeed; }
        /** Constructor with member initializations */
        __ns1__queryViolateSpeed() : ns1__queryViolateSpeed_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__queryViolateSpeed * SOAP_FMAC2 soap_instantiate___ns1__queryViolateSpeed(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:2392 */
#ifndef SOAP_TYPE___ns1__logout
#define SOAP_TYPE___ns1__logout (80)
/* Wrapper: */
struct SOAP_CMAC __ns1__logout {
      public:
        /** Optional element 'ns1:logout' of XML schema type 'ns1:logout' */
        ns1__logout *ns1__logout_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__logout */
        long soap_type() const { return SOAP_TYPE___ns1__logout; }
        /** Constructor with member initializations */
        __ns1__logout() : ns1__logout_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__logout * SOAP_FMAC2 soap_instantiate___ns1__logout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:2462 */
#ifndef SOAP_TYPE___ns1__querySyncTime
#define SOAP_TYPE___ns1__querySyncTime (84)
/* Wrapper: */
struct SOAP_CMAC __ns1__querySyncTime {
      public:
        /** Optional element 'ns1:querySyncTime' of XML schema type 'ns1:querySyncTime' */
        ns1__querySyncTime *ns1__querySyncTime_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__querySyncTime */
        long soap_type() const { return SOAP_TYPE___ns1__querySyncTime; }
        /** Constructor with member initializations */
        __ns1__querySyncTime() : ns1__querySyncTime_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__querySyncTime * SOAP_FMAC2 soap_instantiate___ns1__querySyncTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:2532 */
#ifndef SOAP_TYPE___ns1__writeAlarmInfo
#define SOAP_TYPE___ns1__writeAlarmInfo (88)
/* Wrapper: */
struct SOAP_CMAC __ns1__writeAlarmInfo {
      public:
        /** Optional element 'ns1:writeAlarmInfo' of XML schema type 'ns1:writeAlarmInfo' */
        ns1__writeAlarmInfo *ns1__writeAlarmInfo_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__writeAlarmInfo */
        long soap_type() const { return SOAP_TYPE___ns1__writeAlarmInfo; }
        /** Constructor with member initializations */
        __ns1__writeAlarmInfo() : ns1__writeAlarmInfo_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__writeAlarmInfo * SOAP_FMAC2 soap_instantiate___ns1__writeAlarmInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:2602 */
#ifndef SOAP_TYPE___ns1__NWriteVehicleInfo
#define SOAP_TYPE___ns1__NWriteVehicleInfo (92)
/* Wrapper: */
struct SOAP_CMAC __ns1__NWriteVehicleInfo {
      public:
        /** Optional element 'ns1:NWriteVehicleInfo' of XML schema type 'ns1:NWriteVehicleInfo' */
        ns1__NWriteVehicleInfo *ns1__NWriteVehicleInfo_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__NWriteVehicleInfo */
        long soap_type() const { return SOAP_TYPE___ns1__NWriteVehicleInfo; }
        /** Constructor with member initializations */
        __ns1__NWriteVehicleInfo() : ns1__NWriteVehicleInfo_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__NWriteVehicleInfo * SOAP_FMAC2 soap_instantiate___ns1__NWriteVehicleInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:2672 */
#ifndef SOAP_TYPE___ns1__NWriteVehicleInfoEx
#define SOAP_TYPE___ns1__NWriteVehicleInfoEx (96)
/* Wrapper: */
struct SOAP_CMAC __ns1__NWriteVehicleInfoEx {
      public:
        /** Optional element 'ns1:NWriteVehicleInfoEx' of XML schema type 'ns1:NWriteVehicleInfoEx' */
        ns1__NWriteVehicleInfoEx *ns1__NWriteVehicleInfoEx_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__NWriteVehicleInfoEx */
        long soap_type() const { return SOAP_TYPE___ns1__NWriteVehicleInfoEx; }
        /** Constructor with member initializations */
        __ns1__NWriteVehicleInfoEx() : ns1__NWriteVehicleInfoEx_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__NWriteVehicleInfoEx * SOAP_FMAC2 soap_instantiate___ns1__NWriteVehicleInfoEx(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:2742 */
#ifndef SOAP_TYPE___ns1__NSyncWriteVehicleInfo
#define SOAP_TYPE___ns1__NSyncWriteVehicleInfo (100)
/* Wrapper: */
struct SOAP_CMAC __ns1__NSyncWriteVehicleInfo {
      public:
        /** Optional element 'ns1:NSyncWriteVehicleInfo' of XML schema type 'ns1:NSyncWriteVehicleInfo' */
        ns1__NSyncWriteVehicleInfo *ns1__NSyncWriteVehicleInfo_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__NSyncWriteVehicleInfo */
        long soap_type() const { return SOAP_TYPE___ns1__NSyncWriteVehicleInfo; }
        /** Constructor with member initializations */
        __ns1__NSyncWriteVehicleInfo() : ns1__NSyncWriteVehicleInfo_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__NSyncWriteVehicleInfo * SOAP_FMAC2 soap_instantiate___ns1__NSyncWriteVehicleInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:2812 */
#ifndef SOAP_TYPE___ns1__WriteFlux
#define SOAP_TYPE___ns1__WriteFlux (104)
/* Wrapper: */
struct SOAP_CMAC __ns1__WriteFlux {
      public:
        /** Optional element 'ns1:WriteFlux' of XML schema type 'ns1:WriteFlux' */
        ns1__WriteFlux *ns1__WriteFlux_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__WriteFlux */
        long soap_type() const { return SOAP_TYPE___ns1__WriteFlux; }
        /** Constructor with member initializations */
        __ns1__WriteFlux() : ns1__WriteFlux_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__WriteFlux * SOAP_FMAC2 soap_instantiate___ns1__WriteFlux(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:2882 */
#ifndef SOAP_TYPE___ns1__NWriteDeviceStatus
#define SOAP_TYPE___ns1__NWriteDeviceStatus (108)
/* Wrapper: */
struct SOAP_CMAC __ns1__NWriteDeviceStatus {
      public:
        /** Optional element 'ns1:NWriteDeviceStatus' of XML schema type 'ns1:NWriteDeviceStatus' */
        ns1__NWriteDeviceStatus *ns1__NWriteDeviceStatus_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__NWriteDeviceStatus */
        long soap_type() const { return SOAP_TYPE___ns1__NWriteDeviceStatus; }
        /** Constructor with member initializations */
        __ns1__NWriteDeviceStatus() : ns1__NWriteDeviceStatus_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__NWriteDeviceStatus * SOAP_FMAC2 soap_instantiate___ns1__NWriteDeviceStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:2952 */
#ifndef SOAP_TYPE___ns1__NSyncWriteMobileEPVInfo
#define SOAP_TYPE___ns1__NSyncWriteMobileEPVInfo (112)
/* Wrapper: */
struct SOAP_CMAC __ns1__NSyncWriteMobileEPVInfo {
      public:
        /** Optional element 'ns1:NSyncWriteMobileEPVInfo' of XML schema type 'ns1:NSyncWriteMobileEPVInfo' */
        ns1__NSyncWriteMobileEPVInfo *ns1__NSyncWriteMobileEPVInfo_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__NSyncWriteMobileEPVInfo */
        long soap_type() const { return SOAP_TYPE___ns1__NSyncWriteMobileEPVInfo; }
        /** Constructor with member initializations */
        __ns1__NSyncWriteMobileEPVInfo() : ns1__NSyncWriteMobileEPVInfo_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__NSyncWriteMobileEPVInfo * SOAP_FMAC2 soap_instantiate___ns1__NSyncWriteMobileEPVInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:3022 */
#ifndef SOAP_TYPE___ns1__NSyncWriteVioInfo
#define SOAP_TYPE___ns1__NSyncWriteVioInfo (116)
/* Wrapper: */
struct SOAP_CMAC __ns1__NSyncWriteVioInfo {
      public:
        /** Optional element 'ns1:NSyncWriteVioInfo' of XML schema type 'ns1:NSyncWriteVioInfo' */
        ns1__NSyncWriteVioInfo *ns1__NSyncWriteVioInfo_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__NSyncWriteVioInfo */
        long soap_type() const { return SOAP_TYPE___ns1__NSyncWriteVioInfo; }
        /** Constructor with member initializations */
        __ns1__NSyncWriteVioInfo() : ns1__NSyncWriteVioInfo_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__NSyncWriteVioInfo * SOAP_FMAC2 soap_instantiate___ns1__NSyncWriteVioInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:3092 */
#ifndef SOAP_TYPE___ns1__NWritePassStat
#define SOAP_TYPE___ns1__NWritePassStat (120)
/* Wrapper: */
struct SOAP_CMAC __ns1__NWritePassStat {
      public:
        /** Optional element 'ns1:NWritePassStat' of XML schema type 'ns1:NWritePassStat' */
        ns1__NWritePassStat *ns1__NWritePassStat_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__NWritePassStat */
        long soap_type() const { return SOAP_TYPE___ns1__NWritePassStat; }
        /** Constructor with member initializations */
        __ns1__NWritePassStat() : ns1__NWritePassStat_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__NWritePassStat * SOAP_FMAC2 soap_instantiate___ns1__NWritePassStat(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:3162 */
#ifndef SOAP_TYPE___ns1__SyncWriteVehPassInfo
#define SOAP_TYPE___ns1__SyncWriteVehPassInfo (124)
/* Wrapper: */
struct SOAP_CMAC __ns1__SyncWriteVehPassInfo {
      public:
        /** Optional element 'ns1:SyncWriteVehPassInfo' of XML schema type 'ns1:SyncWriteVehPassInfo' */
        ns1__SyncWriteVehPassInfo *ns1__SyncWriteVehPassInfo_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SyncWriteVehPassInfo */
        long soap_type() const { return SOAP_TYPE___ns1__SyncWriteVehPassInfo; }
        /** Constructor with member initializations */
        __ns1__SyncWriteVehPassInfo() : ns1__SyncWriteVehPassInfo_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SyncWriteVehPassInfo * SOAP_FMAC2 soap_instantiate___ns1__SyncWriteVehPassInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:3232 */
#ifndef SOAP_TYPE___ns1__WriteVehPassInfo
#define SOAP_TYPE___ns1__WriteVehPassInfo (128)
/* Wrapper: */
struct SOAP_CMAC __ns1__WriteVehPassInfo {
      public:
        /** Optional element 'ns1:WriteVehPassInfo' of XML schema type 'ns1:WriteVehPassInfo' */
        ns1__WriteVehPassInfo *ns1__WriteVehPassInfo_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__WriteVehPassInfo */
        long soap_type() const { return SOAP_TYPE___ns1__WriteVehPassInfo; }
        /** Constructor with member initializations */
        __ns1__WriteVehPassInfo() : ns1__WriteVehPassInfo_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__WriteVehPassInfo * SOAP_FMAC2 soap_instantiate___ns1__WriteVehPassInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:3302 */
#ifndef SOAP_TYPE___ns1__SyncWriteAreaSpeed
#define SOAP_TYPE___ns1__SyncWriteAreaSpeed (132)
/* Wrapper: */
struct SOAP_CMAC __ns1__SyncWriteAreaSpeed {
      public:
        /** Optional element 'ns1:SyncWriteAreaSpeed' of XML schema type 'ns1:SyncWriteAreaSpeed' */
        ns1__SyncWriteAreaSpeed *ns1__SyncWriteAreaSpeed_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SyncWriteAreaSpeed */
        long soap_type() const { return SOAP_TYPE___ns1__SyncWriteAreaSpeed; }
        /** Constructor with member initializations */
        __ns1__SyncWriteAreaSpeed() : ns1__SyncWriteAreaSpeed_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SyncWriteAreaSpeed * SOAP_FMAC2 soap_instantiate___ns1__SyncWriteAreaSpeed(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:3372 */
#ifndef SOAP_TYPE___ns1__WriteAreaSpeed
#define SOAP_TYPE___ns1__WriteAreaSpeed (136)
/* Wrapper: */
struct SOAP_CMAC __ns1__WriteAreaSpeed {
      public:
        /** Optional element 'ns1:WriteAreaSpeed' of XML schema type 'ns1:WriteAreaSpeed' */
        ns1__WriteAreaSpeed *ns1__WriteAreaSpeed_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__WriteAreaSpeed */
        long soap_type() const { return SOAP_TYPE___ns1__WriteAreaSpeed; }
        /** Constructor with member initializations */
        __ns1__WriteAreaSpeed() : ns1__WriteAreaSpeed_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__WriteAreaSpeed * SOAP_FMAC2 soap_instantiate___ns1__WriteAreaSpeed(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* HTSAPServer.h:3515 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (137)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* HTSAPServer.h:3515 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (138)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* HTSAPServer.h:3515 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (140)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* HTSAPServer.h:3515 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (143)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* HTSAPServer.h:3515 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (144)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* LONG64 has binding name 'LONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_LONG64
#define SOAP_TYPE_LONG64 (56)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_unsignedByte
#define SOAP_TYPE_unsignedByte (10)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (9)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (53)
#endif

/* ns1__WriteAreaSpeedResponse has binding name 'ns1__WriteAreaSpeedResponse' for type 'ns1:WriteAreaSpeedResponse' */
#ifndef SOAP_TYPE_ns1__WriteAreaSpeedResponse
#define SOAP_TYPE_ns1__WriteAreaSpeedResponse (52)
#endif

/* ns1__WriteAreaSpeed has binding name 'ns1__WriteAreaSpeed' for type 'ns1:WriteAreaSpeed' */
#ifndef SOAP_TYPE_ns1__WriteAreaSpeed
#define SOAP_TYPE_ns1__WriteAreaSpeed (51)
#endif

/* ns1__SyncWriteAreaSpeedResponse has binding name 'ns1__SyncWriteAreaSpeedResponse' for type 'ns1:SyncWriteAreaSpeedResponse' */
#ifndef SOAP_TYPE_ns1__SyncWriteAreaSpeedResponse
#define SOAP_TYPE_ns1__SyncWriteAreaSpeedResponse (50)
#endif

/* ns1__SyncWriteAreaSpeed has binding name 'ns1__SyncWriteAreaSpeed' for type 'ns1:SyncWriteAreaSpeed' */
#ifndef SOAP_TYPE_ns1__SyncWriteAreaSpeed
#define SOAP_TYPE_ns1__SyncWriteAreaSpeed (49)
#endif

/* ns1__WriteVehPassInfoResponse has binding name 'ns1__WriteVehPassInfoResponse' for type 'ns1:WriteVehPassInfoResponse' */
#ifndef SOAP_TYPE_ns1__WriteVehPassInfoResponse
#define SOAP_TYPE_ns1__WriteVehPassInfoResponse (48)
#endif

/* ns1__WriteVehPassInfo has binding name 'ns1__WriteVehPassInfo' for type 'ns1:WriteVehPassInfo' */
#ifndef SOAP_TYPE_ns1__WriteVehPassInfo
#define SOAP_TYPE_ns1__WriteVehPassInfo (47)
#endif

/* ns1__SyncWriteVehPassInfoResponse has binding name 'ns1__SyncWriteVehPassInfoResponse' for type 'ns1:SyncWriteVehPassInfoResponse' */
#ifndef SOAP_TYPE_ns1__SyncWriteVehPassInfoResponse
#define SOAP_TYPE_ns1__SyncWriteVehPassInfoResponse (46)
#endif

/* ns1__SyncWriteVehPassInfo has binding name 'ns1__SyncWriteVehPassInfo' for type 'ns1:SyncWriteVehPassInfo' */
#ifndef SOAP_TYPE_ns1__SyncWriteVehPassInfo
#define SOAP_TYPE_ns1__SyncWriteVehPassInfo (45)
#endif

/* ns1__NWritePassStatResponse has binding name 'ns1__NWritePassStatResponse' for type 'ns1:NWritePassStatResponse' */
#ifndef SOAP_TYPE_ns1__NWritePassStatResponse
#define SOAP_TYPE_ns1__NWritePassStatResponse (44)
#endif

/* ns1__NWritePassStat has binding name 'ns1__NWritePassStat' for type 'ns1:NWritePassStat' */
#ifndef SOAP_TYPE_ns1__NWritePassStat
#define SOAP_TYPE_ns1__NWritePassStat (43)
#endif

/* ns1__NSyncWriteVioInfoResponse has binding name 'ns1__NSyncWriteVioInfoResponse' for type 'ns1:NSyncWriteVioInfoResponse' */
#ifndef SOAP_TYPE_ns1__NSyncWriteVioInfoResponse
#define SOAP_TYPE_ns1__NSyncWriteVioInfoResponse (42)
#endif

/* ns1__NSyncWriteVioInfo has binding name 'ns1__NSyncWriteVioInfo' for type 'ns1:NSyncWriteVioInfo' */
#ifndef SOAP_TYPE_ns1__NSyncWriteVioInfo
#define SOAP_TYPE_ns1__NSyncWriteVioInfo (41)
#endif

/* ns1__NSyncWriteMobileEPVInfoResponse has binding name 'ns1__NSyncWriteMobileEPVInfoResponse' for type 'ns1:NSyncWriteMobileEPVInfoResponse' */
#ifndef SOAP_TYPE_ns1__NSyncWriteMobileEPVInfoResponse
#define SOAP_TYPE_ns1__NSyncWriteMobileEPVInfoResponse (40)
#endif

/* ns1__NSyncWriteMobileEPVInfo has binding name 'ns1__NSyncWriteMobileEPVInfo' for type 'ns1:NSyncWriteMobileEPVInfo' */
#ifndef SOAP_TYPE_ns1__NSyncWriteMobileEPVInfo
#define SOAP_TYPE_ns1__NSyncWriteMobileEPVInfo (39)
#endif

/* ns1__NWriteDeviceStatusResponse has binding name 'ns1__NWriteDeviceStatusResponse' for type 'ns1:NWriteDeviceStatusResponse' */
#ifndef SOAP_TYPE_ns1__NWriteDeviceStatusResponse
#define SOAP_TYPE_ns1__NWriteDeviceStatusResponse (38)
#endif

/* ns1__NWriteDeviceStatus has binding name 'ns1__NWriteDeviceStatus' for type 'ns1:NWriteDeviceStatus' */
#ifndef SOAP_TYPE_ns1__NWriteDeviceStatus
#define SOAP_TYPE_ns1__NWriteDeviceStatus (37)
#endif

/* ns1__WriteFluxResponse has binding name 'ns1__WriteFluxResponse' for type 'ns1:WriteFluxResponse' */
#ifndef SOAP_TYPE_ns1__WriteFluxResponse
#define SOAP_TYPE_ns1__WriteFluxResponse (36)
#endif

/* ns1__WriteFlux has binding name 'ns1__WriteFlux' for type 'ns1:WriteFlux' */
#ifndef SOAP_TYPE_ns1__WriteFlux
#define SOAP_TYPE_ns1__WriteFlux (35)
#endif

/* ns1__NSyncWriteVehicleInfoResponse has binding name 'ns1__NSyncWriteVehicleInfoResponse' for type 'ns1:NSyncWriteVehicleInfoResponse' */
#ifndef SOAP_TYPE_ns1__NSyncWriteVehicleInfoResponse
#define SOAP_TYPE_ns1__NSyncWriteVehicleInfoResponse (34)
#endif

/* ns1__NSyncWriteVehicleInfo has binding name 'ns1__NSyncWriteVehicleInfo' for type 'ns1:NSyncWriteVehicleInfo' */
#ifndef SOAP_TYPE_ns1__NSyncWriteVehicleInfo
#define SOAP_TYPE_ns1__NSyncWriteVehicleInfo (33)
#endif

/* ns1__NWriteVehicleInfoExResponse has binding name 'ns1__NWriteVehicleInfoExResponse' for type 'ns1:NWriteVehicleInfoExResponse' */
#ifndef SOAP_TYPE_ns1__NWriteVehicleInfoExResponse
#define SOAP_TYPE_ns1__NWriteVehicleInfoExResponse (32)
#endif

/* ns1__NWriteVehicleInfoEx has binding name 'ns1__NWriteVehicleInfoEx' for type 'ns1:NWriteVehicleInfoEx' */
#ifndef SOAP_TYPE_ns1__NWriteVehicleInfoEx
#define SOAP_TYPE_ns1__NWriteVehicleInfoEx (31)
#endif

/* ns1__NWriteVehicleInfoResponse has binding name 'ns1__NWriteVehicleInfoResponse' for type 'ns1:NWriteVehicleInfoResponse' */
#ifndef SOAP_TYPE_ns1__NWriteVehicleInfoResponse
#define SOAP_TYPE_ns1__NWriteVehicleInfoResponse (30)
#endif

/* ns1__NWriteVehicleInfo has binding name 'ns1__NWriteVehicleInfo' for type 'ns1:NWriteVehicleInfo' */
#ifndef SOAP_TYPE_ns1__NWriteVehicleInfo
#define SOAP_TYPE_ns1__NWriteVehicleInfo (29)
#endif

/* ns1__writeAlarmInfoResponse has binding name 'ns1__writeAlarmInfoResponse' for type 'ns1:writeAlarmInfoResponse' */
#ifndef SOAP_TYPE_ns1__writeAlarmInfoResponse
#define SOAP_TYPE_ns1__writeAlarmInfoResponse (28)
#endif

/* ns1__writeAlarmInfo has binding name 'ns1__writeAlarmInfo' for type 'ns1:writeAlarmInfo' */
#ifndef SOAP_TYPE_ns1__writeAlarmInfo
#define SOAP_TYPE_ns1__writeAlarmInfo (27)
#endif

/* ns1__querySyncTimeResponse has binding name 'ns1__querySyncTimeResponse' for type 'ns1:querySyncTimeResponse' */
#ifndef SOAP_TYPE_ns1__querySyncTimeResponse
#define SOAP_TYPE_ns1__querySyncTimeResponse (26)
#endif

/* ns1__querySyncTime has binding name 'ns1__querySyncTime' for type 'ns1:querySyncTime' */
#ifndef SOAP_TYPE_ns1__querySyncTime
#define SOAP_TYPE_ns1__querySyncTime (25)
#endif

/* ns1__logoutResponse has binding name 'ns1__logoutResponse' for type 'ns1:logoutResponse' */
#ifndef SOAP_TYPE_ns1__logoutResponse
#define SOAP_TYPE_ns1__logoutResponse (24)
#endif

/* ns1__logout has binding name 'ns1__logout' for type 'ns1:logout' */
#ifndef SOAP_TYPE_ns1__logout
#define SOAP_TYPE_ns1__logout (23)
#endif

/* ns1__queryViolateSpeedResponse has binding name 'ns1__queryViolateSpeedResponse' for type 'ns1:queryViolateSpeedResponse' */
#ifndef SOAP_TYPE_ns1__queryViolateSpeedResponse
#define SOAP_TYPE_ns1__queryViolateSpeedResponse (22)
#endif

/* ns1__queryViolateSpeed has binding name 'ns1__queryViolateSpeed' for type 'ns1:queryViolateSpeed' */
#ifndef SOAP_TYPE_ns1__queryViolateSpeed
#define SOAP_TYPE_ns1__queryViolateSpeed (21)
#endif

/* ns1__queryLimitSpeedResponse has binding name 'ns1__queryLimitSpeedResponse' for type 'ns1:queryLimitSpeedResponse' */
#ifndef SOAP_TYPE_ns1__queryLimitSpeedResponse
#define SOAP_TYPE_ns1__queryLimitSpeedResponse (20)
#endif

/* ns1__queryLimitSpeed has binding name 'ns1__queryLimitSpeed' for type 'ns1:queryLimitSpeed' */
#ifndef SOAP_TYPE_ns1__queryLimitSpeed
#define SOAP_TYPE_ns1__queryLimitSpeed (19)
#endif

/* ns1__loginResponse has binding name 'ns1__loginResponse' for type 'ns1:loginResponse' */
#ifndef SOAP_TYPE_ns1__loginResponse
#define SOAP_TYPE_ns1__loginResponse (18)
#endif

/* ns1__login has binding name 'ns1__login' for type 'ns1:login' */
#ifndef SOAP_TYPE_ns1__login
#define SOAP_TYPE_ns1__login (17)
#endif

/* ns1__writeVehicleInfoResponse has binding name 'ns1__writeVehicleInfoResponse' for type 'ns1:writeVehicleInfoResponse' */
#ifndef SOAP_TYPE_ns1__writeVehicleInfoResponse
#define SOAP_TYPE_ns1__writeVehicleInfoResponse (16)
#endif

/* ns1__writeVehicleInfo has binding name 'ns1__writeVehicleInfo' for type 'ns1:writeVehicleInfo' */
#ifndef SOAP_TYPE_ns1__writeVehicleInfo
#define SOAP_TYPE_ns1__writeVehicleInfo (15)
#endif

/* ns1__syncWriteVehicleInfoResponse has binding name 'ns1__syncWriteVehicleInfoResponse' for type 'ns1:syncWriteVehicleInfoResponse' */
#ifndef SOAP_TYPE_ns1__syncWriteVehicleInfoResponse
#define SOAP_TYPE_ns1__syncWriteVehicleInfoResponse (14)
#endif

/* ns1__syncWriteVehicleInfo has binding name 'ns1__syncWriteVehicleInfo' for type 'ns1:syncWriteVehicleInfo' */
#ifndef SOAP_TYPE_ns1__syncWriteVehicleInfo
#define SOAP_TYPE_ns1__syncWriteVehicleInfo (13)
#endif

/* ns1__Exception has binding name 'ns1__Exception' for type 'ns1:Exception' */
#ifndef SOAP_TYPE_ns1__Exception
#define SOAP_TYPE_ns1__Exception (12)
#endif

/* xsd__base64Binary has binding name 'xsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (8)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (144)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (143)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (140)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (138)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (137)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (146)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (145)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (139)
#endif

/* ns1__WriteAreaSpeed * has binding name 'PointerTons1__WriteAreaSpeed' for type 'ns1:WriteAreaSpeed' */
#ifndef SOAP_TYPE_PointerTons1__WriteAreaSpeed
#define SOAP_TYPE_PointerTons1__WriteAreaSpeed (133)
#endif

/* ns1__SyncWriteAreaSpeed * has binding name 'PointerTons1__SyncWriteAreaSpeed' for type 'ns1:SyncWriteAreaSpeed' */
#ifndef SOAP_TYPE_PointerTons1__SyncWriteAreaSpeed
#define SOAP_TYPE_PointerTons1__SyncWriteAreaSpeed (129)
#endif

/* ns1__WriteVehPassInfo * has binding name 'PointerTons1__WriteVehPassInfo' for type 'ns1:WriteVehPassInfo' */
#ifndef SOAP_TYPE_PointerTons1__WriteVehPassInfo
#define SOAP_TYPE_PointerTons1__WriteVehPassInfo (125)
#endif

/* ns1__SyncWriteVehPassInfo * has binding name 'PointerTons1__SyncWriteVehPassInfo' for type 'ns1:SyncWriteVehPassInfo' */
#ifndef SOAP_TYPE_PointerTons1__SyncWriteVehPassInfo
#define SOAP_TYPE_PointerTons1__SyncWriteVehPassInfo (121)
#endif

/* ns1__NWritePassStat * has binding name 'PointerTons1__NWritePassStat' for type 'ns1:NWritePassStat' */
#ifndef SOAP_TYPE_PointerTons1__NWritePassStat
#define SOAP_TYPE_PointerTons1__NWritePassStat (117)
#endif

/* ns1__NSyncWriteVioInfo * has binding name 'PointerTons1__NSyncWriteVioInfo' for type 'ns1:NSyncWriteVioInfo' */
#ifndef SOAP_TYPE_PointerTons1__NSyncWriteVioInfo
#define SOAP_TYPE_PointerTons1__NSyncWriteVioInfo (113)
#endif

/* ns1__NSyncWriteMobileEPVInfo * has binding name 'PointerTons1__NSyncWriteMobileEPVInfo' for type 'ns1:NSyncWriteMobileEPVInfo' */
#ifndef SOAP_TYPE_PointerTons1__NSyncWriteMobileEPVInfo
#define SOAP_TYPE_PointerTons1__NSyncWriteMobileEPVInfo (109)
#endif

/* ns1__NWriteDeviceStatus * has binding name 'PointerTons1__NWriteDeviceStatus' for type 'ns1:NWriteDeviceStatus' */
#ifndef SOAP_TYPE_PointerTons1__NWriteDeviceStatus
#define SOAP_TYPE_PointerTons1__NWriteDeviceStatus (105)
#endif

/* ns1__WriteFlux * has binding name 'PointerTons1__WriteFlux' for type 'ns1:WriteFlux' */
#ifndef SOAP_TYPE_PointerTons1__WriteFlux
#define SOAP_TYPE_PointerTons1__WriteFlux (101)
#endif

/* ns1__NSyncWriteVehicleInfo * has binding name 'PointerTons1__NSyncWriteVehicleInfo' for type 'ns1:NSyncWriteVehicleInfo' */
#ifndef SOAP_TYPE_PointerTons1__NSyncWriteVehicleInfo
#define SOAP_TYPE_PointerTons1__NSyncWriteVehicleInfo (97)
#endif

/* ns1__NWriteVehicleInfoEx * has binding name 'PointerTons1__NWriteVehicleInfoEx' for type 'ns1:NWriteVehicleInfoEx' */
#ifndef SOAP_TYPE_PointerTons1__NWriteVehicleInfoEx
#define SOAP_TYPE_PointerTons1__NWriteVehicleInfoEx (93)
#endif

/* ns1__NWriteVehicleInfo * has binding name 'PointerTons1__NWriteVehicleInfo' for type 'ns1:NWriteVehicleInfo' */
#ifndef SOAP_TYPE_PointerTons1__NWriteVehicleInfo
#define SOAP_TYPE_PointerTons1__NWriteVehicleInfo (89)
#endif

/* ns1__writeAlarmInfo * has binding name 'PointerTons1__writeAlarmInfo' for type 'ns1:writeAlarmInfo' */
#ifndef SOAP_TYPE_PointerTons1__writeAlarmInfo
#define SOAP_TYPE_PointerTons1__writeAlarmInfo (85)
#endif

/* ns1__querySyncTime * has binding name 'PointerTons1__querySyncTime' for type 'ns1:querySyncTime' */
#ifndef SOAP_TYPE_PointerTons1__querySyncTime
#define SOAP_TYPE_PointerTons1__querySyncTime (81)
#endif

/* ns1__logout * has binding name 'PointerTons1__logout' for type 'ns1:logout' */
#ifndef SOAP_TYPE_PointerTons1__logout
#define SOAP_TYPE_PointerTons1__logout (77)
#endif

/* ns1__queryViolateSpeed * has binding name 'PointerTons1__queryViolateSpeed' for type 'ns1:queryViolateSpeed' */
#ifndef SOAP_TYPE_PointerTons1__queryViolateSpeed
#define SOAP_TYPE_PointerTons1__queryViolateSpeed (73)
#endif

/* ns1__queryLimitSpeed * has binding name 'PointerTons1__queryLimitSpeed' for type 'ns1:queryLimitSpeed' */
#ifndef SOAP_TYPE_PointerTons1__queryLimitSpeed
#define SOAP_TYPE_PointerTons1__queryLimitSpeed (69)
#endif

/* ns1__login * has binding name 'PointerTons1__login' for type 'ns1:login' */
#ifndef SOAP_TYPE_PointerTons1__login
#define SOAP_TYPE_PointerTons1__login (65)
#endif

/* ns1__writeVehicleInfo * has binding name 'PointerTons1__writeVehicleInfo' for type 'ns1:writeVehicleInfo' */
#ifndef SOAP_TYPE_PointerTons1__writeVehicleInfo
#define SOAP_TYPE_PointerTons1__writeVehicleInfo (61)
#endif

/* ns1__syncWriteVehicleInfo * has binding name 'PointerTons1__syncWriteVehicleInfo' for type 'ns1:syncWriteVehicleInfo' */
#ifndef SOAP_TYPE_PointerTons1__syncWriteVehicleInfo
#define SOAP_TYPE_PointerTons1__syncWriteVehicleInfo (57)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (54)
#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_PointerTounsignedByte
#define SOAP_TYPE_PointerTounsignedByte (11)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stub Functions                                            *
 *                                                                            *
\******************************************************************************/

    
    /** Web service synchronous operation 'soap_call___ns1__syncWriteVehicleInfo' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__syncWriteVehicleInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__syncWriteVehicleInfo *ns1__syncWriteVehicleInfo_, ns1__syncWriteVehicleInfoResponse &ns1__syncWriteVehicleInfoResponse_);
    /** Web service asynchronous operation 'soap_send___ns1__syncWriteVehicleInfo' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns1__syncWriteVehicleInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__syncWriteVehicleInfo *ns1__syncWriteVehicleInfo_);
    /** Web service asynchronous operation 'soap_recv___ns1__syncWriteVehicleInfo' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns1__syncWriteVehicleInfo(struct soap *soap, ns1__syncWriteVehicleInfoResponse &ns1__syncWriteVehicleInfoResponse_);
    
    /** Web service synchronous operation 'soap_call___ns1__writeVehicleInfo' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__writeVehicleInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__writeVehicleInfo *ns1__writeVehicleInfo_, ns1__writeVehicleInfoResponse &ns1__writeVehicleInfoResponse_);
    /** Web service asynchronous operation 'soap_send___ns1__writeVehicleInfo' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns1__writeVehicleInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__writeVehicleInfo *ns1__writeVehicleInfo_);
    /** Web service asynchronous operation 'soap_recv___ns1__writeVehicleInfo' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns1__writeVehicleInfo(struct soap *soap, ns1__writeVehicleInfoResponse &ns1__writeVehicleInfoResponse_);
    
    /** Web service synchronous operation 'soap_call___ns1__login' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__login(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__login *ns1__login_, ns1__loginResponse &ns1__loginResponse_);
    /** Web service asynchronous operation 'soap_send___ns1__login' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns1__login(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__login *ns1__login_);
    /** Web service asynchronous operation 'soap_recv___ns1__login' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns1__login(struct soap *soap, ns1__loginResponse &ns1__loginResponse_);
    
    /** Web service synchronous operation 'soap_call___ns1__queryLimitSpeed' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__queryLimitSpeed(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__queryLimitSpeed *ns1__queryLimitSpeed_, ns1__queryLimitSpeedResponse &ns1__queryLimitSpeedResponse_);
    /** Web service asynchronous operation 'soap_send___ns1__queryLimitSpeed' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns1__queryLimitSpeed(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__queryLimitSpeed *ns1__queryLimitSpeed_);
    /** Web service asynchronous operation 'soap_recv___ns1__queryLimitSpeed' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns1__queryLimitSpeed(struct soap *soap, ns1__queryLimitSpeedResponse &ns1__queryLimitSpeedResponse_);
    
    /** Web service synchronous operation 'soap_call___ns1__queryViolateSpeed' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__queryViolateSpeed(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__queryViolateSpeed *ns1__queryViolateSpeed_, ns1__queryViolateSpeedResponse &ns1__queryViolateSpeedResponse_);
    /** Web service asynchronous operation 'soap_send___ns1__queryViolateSpeed' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns1__queryViolateSpeed(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__queryViolateSpeed *ns1__queryViolateSpeed_);
    /** Web service asynchronous operation 'soap_recv___ns1__queryViolateSpeed' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns1__queryViolateSpeed(struct soap *soap, ns1__queryViolateSpeedResponse &ns1__queryViolateSpeedResponse_);
    
    /** Web service synchronous operation 'soap_call___ns1__logout' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__logout(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__logout *ns1__logout_, ns1__logoutResponse &ns1__logoutResponse_);
    /** Web service asynchronous operation 'soap_send___ns1__logout' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns1__logout(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__logout *ns1__logout_);
    /** Web service asynchronous operation 'soap_recv___ns1__logout' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns1__logout(struct soap *soap, ns1__logoutResponse &ns1__logoutResponse_);
    
    /** Web service synchronous operation 'soap_call___ns1__querySyncTime' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__querySyncTime(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__querySyncTime *ns1__querySyncTime_, ns1__querySyncTimeResponse &ns1__querySyncTimeResponse_);
    /** Web service asynchronous operation 'soap_send___ns1__querySyncTime' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns1__querySyncTime(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__querySyncTime *ns1__querySyncTime_);
    /** Web service asynchronous operation 'soap_recv___ns1__querySyncTime' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns1__querySyncTime(struct soap *soap, ns1__querySyncTimeResponse &ns1__querySyncTimeResponse_);
    
    /** Web service synchronous operation 'soap_call___ns1__writeAlarmInfo' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__writeAlarmInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__writeAlarmInfo *ns1__writeAlarmInfo_, ns1__writeAlarmInfoResponse &ns1__writeAlarmInfoResponse_);
    /** Web service asynchronous operation 'soap_send___ns1__writeAlarmInfo' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns1__writeAlarmInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__writeAlarmInfo *ns1__writeAlarmInfo_);
    /** Web service asynchronous operation 'soap_recv___ns1__writeAlarmInfo' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns1__writeAlarmInfo(struct soap *soap, ns1__writeAlarmInfoResponse &ns1__writeAlarmInfoResponse_);
    
    /** Web service synchronous operation 'soap_call___ns1__NWriteVehicleInfo' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__NWriteVehicleInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__NWriteVehicleInfo *ns1__NWriteVehicleInfo_, ns1__NWriteVehicleInfoResponse &ns1__NWriteVehicleInfoResponse_);
    /** Web service asynchronous operation 'soap_send___ns1__NWriteVehicleInfo' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns1__NWriteVehicleInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__NWriteVehicleInfo *ns1__NWriteVehicleInfo_);
    /** Web service asynchronous operation 'soap_recv___ns1__NWriteVehicleInfo' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns1__NWriteVehicleInfo(struct soap *soap, ns1__NWriteVehicleInfoResponse &ns1__NWriteVehicleInfoResponse_);
    
    /** Web service synchronous operation 'soap_call___ns1__NWriteVehicleInfoEx' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__NWriteVehicleInfoEx(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__NWriteVehicleInfoEx *ns1__NWriteVehicleInfoEx_, ns1__NWriteVehicleInfoExResponse &ns1__NWriteVehicleInfoExResponse_);
    /** Web service asynchronous operation 'soap_send___ns1__NWriteVehicleInfoEx' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns1__NWriteVehicleInfoEx(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__NWriteVehicleInfoEx *ns1__NWriteVehicleInfoEx_);
    /** Web service asynchronous operation 'soap_recv___ns1__NWriteVehicleInfoEx' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns1__NWriteVehicleInfoEx(struct soap *soap, ns1__NWriteVehicleInfoExResponse &ns1__NWriteVehicleInfoExResponse_);
    
    /** Web service synchronous operation 'soap_call___ns1__NSyncWriteVehicleInfo' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__NSyncWriteVehicleInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__NSyncWriteVehicleInfo *ns1__NSyncWriteVehicleInfo_, ns1__NSyncWriteVehicleInfoResponse &ns1__NSyncWriteVehicleInfoResponse_);
    /** Web service asynchronous operation 'soap_send___ns1__NSyncWriteVehicleInfo' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns1__NSyncWriteVehicleInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__NSyncWriteVehicleInfo *ns1__NSyncWriteVehicleInfo_);
    /** Web service asynchronous operation 'soap_recv___ns1__NSyncWriteVehicleInfo' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns1__NSyncWriteVehicleInfo(struct soap *soap, ns1__NSyncWriteVehicleInfoResponse &ns1__NSyncWriteVehicleInfoResponse_);
    
    /** Web service synchronous operation 'soap_call___ns1__WriteFlux' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__WriteFlux(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__WriteFlux *ns1__WriteFlux_, ns1__WriteFluxResponse &ns1__WriteFluxResponse_);
    /** Web service asynchronous operation 'soap_send___ns1__WriteFlux' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns1__WriteFlux(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__WriteFlux *ns1__WriteFlux_);
    /** Web service asynchronous operation 'soap_recv___ns1__WriteFlux' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns1__WriteFlux(struct soap *soap, ns1__WriteFluxResponse &ns1__WriteFluxResponse_);
    
    /** Web service synchronous operation 'soap_call___ns1__NWriteDeviceStatus' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__NWriteDeviceStatus(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__NWriteDeviceStatus *ns1__NWriteDeviceStatus_, ns1__NWriteDeviceStatusResponse &ns1__NWriteDeviceStatusResponse_);
    /** Web service asynchronous operation 'soap_send___ns1__NWriteDeviceStatus' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns1__NWriteDeviceStatus(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__NWriteDeviceStatus *ns1__NWriteDeviceStatus_);
    /** Web service asynchronous operation 'soap_recv___ns1__NWriteDeviceStatus' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns1__NWriteDeviceStatus(struct soap *soap, ns1__NWriteDeviceStatusResponse &ns1__NWriteDeviceStatusResponse_);
    
    /** Web service synchronous operation 'soap_call___ns1__NSyncWriteMobileEPVInfo' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__NSyncWriteMobileEPVInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__NSyncWriteMobileEPVInfo *ns1__NSyncWriteMobileEPVInfo_, ns1__NSyncWriteMobileEPVInfoResponse &ns1__NSyncWriteMobileEPVInfoResponse_);
    /** Web service asynchronous operation 'soap_send___ns1__NSyncWriteMobileEPVInfo' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns1__NSyncWriteMobileEPVInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__NSyncWriteMobileEPVInfo *ns1__NSyncWriteMobileEPVInfo_);
    /** Web service asynchronous operation 'soap_recv___ns1__NSyncWriteMobileEPVInfo' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns1__NSyncWriteMobileEPVInfo(struct soap *soap, ns1__NSyncWriteMobileEPVInfoResponse &ns1__NSyncWriteMobileEPVInfoResponse_);
    
    /** Web service synchronous operation 'soap_call___ns1__NSyncWriteVioInfo' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__NSyncWriteVioInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__NSyncWriteVioInfo *ns1__NSyncWriteVioInfo_, ns1__NSyncWriteVioInfoResponse &ns1__NSyncWriteVioInfoResponse_);
    /** Web service asynchronous operation 'soap_send___ns1__NSyncWriteVioInfo' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns1__NSyncWriteVioInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__NSyncWriteVioInfo *ns1__NSyncWriteVioInfo_);
    /** Web service asynchronous operation 'soap_recv___ns1__NSyncWriteVioInfo' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns1__NSyncWriteVioInfo(struct soap *soap, ns1__NSyncWriteVioInfoResponse &ns1__NSyncWriteVioInfoResponse_);
    
    /** Web service synchronous operation 'soap_call___ns1__NWritePassStat' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__NWritePassStat(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__NWritePassStat *ns1__NWritePassStat_, ns1__NWritePassStatResponse &ns1__NWritePassStatResponse_);
    /** Web service asynchronous operation 'soap_send___ns1__NWritePassStat' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns1__NWritePassStat(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__NWritePassStat *ns1__NWritePassStat_);
    /** Web service asynchronous operation 'soap_recv___ns1__NWritePassStat' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns1__NWritePassStat(struct soap *soap, ns1__NWritePassStatResponse &ns1__NWritePassStatResponse_);
    
    /** Web service synchronous operation 'soap_call___ns1__SyncWriteVehPassInfo' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SyncWriteVehPassInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__SyncWriteVehPassInfo *ns1__SyncWriteVehPassInfo_, ns1__SyncWriteVehPassInfoResponse &ns1__SyncWriteVehPassInfoResponse_);
    /** Web service asynchronous operation 'soap_send___ns1__SyncWriteVehPassInfo' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns1__SyncWriteVehPassInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__SyncWriteVehPassInfo *ns1__SyncWriteVehPassInfo_);
    /** Web service asynchronous operation 'soap_recv___ns1__SyncWriteVehPassInfo' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns1__SyncWriteVehPassInfo(struct soap *soap, ns1__SyncWriteVehPassInfoResponse &ns1__SyncWriteVehPassInfoResponse_);
    
    /** Web service synchronous operation 'soap_call___ns1__WriteVehPassInfo' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__WriteVehPassInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__WriteVehPassInfo *ns1__WriteVehPassInfo_, ns1__WriteVehPassInfoResponse &ns1__WriteVehPassInfoResponse_);
    /** Web service asynchronous operation 'soap_send___ns1__WriteVehPassInfo' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns1__WriteVehPassInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__WriteVehPassInfo *ns1__WriteVehPassInfo_);
    /** Web service asynchronous operation 'soap_recv___ns1__WriteVehPassInfo' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns1__WriteVehPassInfo(struct soap *soap, ns1__WriteVehPassInfoResponse &ns1__WriteVehPassInfoResponse_);
    
    /** Web service synchronous operation 'soap_call___ns1__SyncWriteAreaSpeed' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SyncWriteAreaSpeed(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__SyncWriteAreaSpeed *ns1__SyncWriteAreaSpeed_, ns1__SyncWriteAreaSpeedResponse &ns1__SyncWriteAreaSpeedResponse_);
    /** Web service asynchronous operation 'soap_send___ns1__SyncWriteAreaSpeed' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns1__SyncWriteAreaSpeed(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__SyncWriteAreaSpeed *ns1__SyncWriteAreaSpeed_);
    /** Web service asynchronous operation 'soap_recv___ns1__SyncWriteAreaSpeed' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns1__SyncWriteAreaSpeed(struct soap *soap, ns1__SyncWriteAreaSpeedResponse &ns1__SyncWriteAreaSpeedResponse_);
    
    /** Web service synchronous operation 'soap_call___ns1__WriteAreaSpeed' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__WriteAreaSpeed(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__WriteAreaSpeed *ns1__WriteAreaSpeed_, ns1__WriteAreaSpeedResponse &ns1__WriteAreaSpeedResponse_);
    /** Web service asynchronous operation 'soap_send___ns1__WriteAreaSpeed' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns1__WriteAreaSpeed(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__WriteAreaSpeed *ns1__WriteAreaSpeed_);
    /** Web service asynchronous operation 'soap_recv___ns1__WriteAreaSpeed' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns1__WriteAreaSpeed(struct soap *soap, ns1__WriteAreaSpeedResponse &ns1__WriteAreaSpeedResponse_);

#endif

/* End of soapStub.h */
