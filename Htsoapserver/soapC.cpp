/* soapC.cpp
   Generated by gSOAP 2.8.105 for ns.h

gSOAP XML Web services tools
Copyright (C) 2000-2020, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.105 2020-11-11 10:46:13 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
	}
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code == NULL)
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason == NULL)
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
				return NULL;
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	const char **s = soap_faultsubcode(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	const char **s = soap_faultstring(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
			soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
		soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	const char **s = soap_faultdetail(soap);
	return s ? *s : NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, NULL, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, const char *tag, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, tag, NULL, "xsd:long");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, tag, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, tag, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_ns1__WriteAreaSpeedResponse:
		return soap_in_ns1__WriteAreaSpeedResponse(soap, tag, NULL, "ns1:WriteAreaSpeedResponse");
	case SOAP_TYPE_ns1__WriteAreaSpeed:
		return soap_in_ns1__WriteAreaSpeed(soap, tag, NULL, "ns1:WriteAreaSpeed");
	case SOAP_TYPE_ns1__SyncWriteAreaSpeedResponse:
		return soap_in_ns1__SyncWriteAreaSpeedResponse(soap, tag, NULL, "ns1:SyncWriteAreaSpeedResponse");
	case SOAP_TYPE_ns1__SyncWriteAreaSpeed:
		return soap_in_ns1__SyncWriteAreaSpeed(soap, tag, NULL, "ns1:SyncWriteAreaSpeed");
	case SOAP_TYPE_ns1__WriteVehPassInfoResponse:
		return soap_in_ns1__WriteVehPassInfoResponse(soap, tag, NULL, "ns1:WriteVehPassInfoResponse");
	case SOAP_TYPE_ns1__WriteVehPassInfo:
		return soap_in_ns1__WriteVehPassInfo(soap, tag, NULL, "ns1:WriteVehPassInfo");
	case SOAP_TYPE_ns1__SyncWriteVehPassInfoResponse:
		return soap_in_ns1__SyncWriteVehPassInfoResponse(soap, tag, NULL, "ns1:SyncWriteVehPassInfoResponse");
	case SOAP_TYPE_ns1__SyncWriteVehPassInfo:
		return soap_in_ns1__SyncWriteVehPassInfo(soap, tag, NULL, "ns1:SyncWriteVehPassInfo");
	case SOAP_TYPE_ns1__NWritePassStatResponse:
		return soap_in_ns1__NWritePassStatResponse(soap, tag, NULL, "ns1:NWritePassStatResponse");
	case SOAP_TYPE_ns1__NWritePassStat:
		return soap_in_ns1__NWritePassStat(soap, tag, NULL, "ns1:NWritePassStat");
	case SOAP_TYPE_ns1__NSyncWriteVioInfoResponse:
		return soap_in_ns1__NSyncWriteVioInfoResponse(soap, tag, NULL, "ns1:NSyncWriteVioInfoResponse");
	case SOAP_TYPE_ns1__NSyncWriteVioInfo:
		return soap_in_ns1__NSyncWriteVioInfo(soap, tag, NULL, "ns1:NSyncWriteVioInfo");
	case SOAP_TYPE_ns1__NSyncWriteMobileEPVInfoResponse:
		return soap_in_ns1__NSyncWriteMobileEPVInfoResponse(soap, tag, NULL, "ns1:NSyncWriteMobileEPVInfoResponse");
	case SOAP_TYPE_ns1__NSyncWriteMobileEPVInfo:
		return soap_in_ns1__NSyncWriteMobileEPVInfo(soap, tag, NULL, "ns1:NSyncWriteMobileEPVInfo");
	case SOAP_TYPE_ns1__NWriteDeviceStatusResponse:
		return soap_in_ns1__NWriteDeviceStatusResponse(soap, tag, NULL, "ns1:NWriteDeviceStatusResponse");
	case SOAP_TYPE_ns1__NWriteDeviceStatus:
		return soap_in_ns1__NWriteDeviceStatus(soap, tag, NULL, "ns1:NWriteDeviceStatus");
	case SOAP_TYPE_ns1__WriteFluxResponse:
		return soap_in_ns1__WriteFluxResponse(soap, tag, NULL, "ns1:WriteFluxResponse");
	case SOAP_TYPE_ns1__WriteFlux:
		return soap_in_ns1__WriteFlux(soap, tag, NULL, "ns1:WriteFlux");
	case SOAP_TYPE_ns1__NSyncWriteVehicleInfoResponse:
		return soap_in_ns1__NSyncWriteVehicleInfoResponse(soap, tag, NULL, "ns1:NSyncWriteVehicleInfoResponse");
	case SOAP_TYPE_ns1__NSyncWriteVehicleInfo:
		return soap_in_ns1__NSyncWriteVehicleInfo(soap, tag, NULL, "ns1:NSyncWriteVehicleInfo");
	case SOAP_TYPE_ns1__NWriteVehicleInfoExResponse:
		return soap_in_ns1__NWriteVehicleInfoExResponse(soap, tag, NULL, "ns1:NWriteVehicleInfoExResponse");
	case SOAP_TYPE_ns1__NWriteVehicleInfoEx:
		return soap_in_ns1__NWriteVehicleInfoEx(soap, tag, NULL, "ns1:NWriteVehicleInfoEx");
	case SOAP_TYPE_ns1__NWriteVehicleInfoResponse:
		return soap_in_ns1__NWriteVehicleInfoResponse(soap, tag, NULL, "ns1:NWriteVehicleInfoResponse");
	case SOAP_TYPE_ns1__NWriteVehicleInfo:
		return soap_in_ns1__NWriteVehicleInfo(soap, tag, NULL, "ns1:NWriteVehicleInfo");
	case SOAP_TYPE_ns1__writeAlarmInfoResponse:
		return soap_in_ns1__writeAlarmInfoResponse(soap, tag, NULL, "ns1:writeAlarmInfoResponse");
	case SOAP_TYPE_ns1__writeAlarmInfo:
		return soap_in_ns1__writeAlarmInfo(soap, tag, NULL, "ns1:writeAlarmInfo");
	case SOAP_TYPE_ns1__querySyncTimeResponse:
		return soap_in_ns1__querySyncTimeResponse(soap, tag, NULL, "ns1:querySyncTimeResponse");
	case SOAP_TYPE_ns1__querySyncTime:
		return soap_in_ns1__querySyncTime(soap, tag, NULL, "ns1:querySyncTime");
	case SOAP_TYPE_ns1__logoutResponse:
		return soap_in_ns1__logoutResponse(soap, tag, NULL, "ns1:logoutResponse");
	case SOAP_TYPE_ns1__logout:
		return soap_in_ns1__logout(soap, tag, NULL, "ns1:logout");
	case SOAP_TYPE_ns1__queryViolateSpeedResponse:
		return soap_in_ns1__queryViolateSpeedResponse(soap, tag, NULL, "ns1:queryViolateSpeedResponse");
	case SOAP_TYPE_ns1__queryViolateSpeed:
		return soap_in_ns1__queryViolateSpeed(soap, tag, NULL, "ns1:queryViolateSpeed");
	case SOAP_TYPE_ns1__queryLimitSpeedResponse:
		return soap_in_ns1__queryLimitSpeedResponse(soap, tag, NULL, "ns1:queryLimitSpeedResponse");
	case SOAP_TYPE_ns1__queryLimitSpeed:
		return soap_in_ns1__queryLimitSpeed(soap, tag, NULL, "ns1:queryLimitSpeed");
	case SOAP_TYPE_ns1__loginResponse:
		return soap_in_ns1__loginResponse(soap, tag, NULL, "ns1:loginResponse");
	case SOAP_TYPE_ns1__login:
		return soap_in_ns1__login(soap, tag, NULL, "ns1:login");
	case SOAP_TYPE_ns1__writeVehicleInfoResponse:
		return soap_in_ns1__writeVehicleInfoResponse(soap, tag, NULL, "ns1:writeVehicleInfoResponse");
	case SOAP_TYPE_ns1__writeVehicleInfo:
		return soap_in_ns1__writeVehicleInfo(soap, tag, NULL, "ns1:writeVehicleInfo");
	case SOAP_TYPE_ns1__syncWriteVehicleInfoResponse:
		return soap_in_ns1__syncWriteVehicleInfoResponse(soap, tag, NULL, "ns1:syncWriteVehicleInfoResponse");
	case SOAP_TYPE_ns1__syncWriteVehicleInfo:
		return soap_in_ns1__syncWriteVehicleInfo(soap, tag, NULL, "ns1:syncWriteVehicleInfo");
	case SOAP_TYPE_ns1__Exception:
		return soap_in_ns1__Exception(soap, tag, NULL, "ns1:Exception");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, tag, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTons1__WriteAreaSpeed:
		return soap_in_PointerTons1__WriteAreaSpeed(soap, tag, NULL, "ns1:WriteAreaSpeed");
	case SOAP_TYPE_PointerTons1__SyncWriteAreaSpeed:
		return soap_in_PointerTons1__SyncWriteAreaSpeed(soap, tag, NULL, "ns1:SyncWriteAreaSpeed");
	case SOAP_TYPE_PointerTons1__WriteVehPassInfo:
		return soap_in_PointerTons1__WriteVehPassInfo(soap, tag, NULL, "ns1:WriteVehPassInfo");
	case SOAP_TYPE_PointerTons1__SyncWriteVehPassInfo:
		return soap_in_PointerTons1__SyncWriteVehPassInfo(soap, tag, NULL, "ns1:SyncWriteVehPassInfo");
	case SOAP_TYPE_PointerTons1__NWritePassStat:
		return soap_in_PointerTons1__NWritePassStat(soap, tag, NULL, "ns1:NWritePassStat");
	case SOAP_TYPE_PointerTons1__NSyncWriteVioInfo:
		return soap_in_PointerTons1__NSyncWriteVioInfo(soap, tag, NULL, "ns1:NSyncWriteVioInfo");
	case SOAP_TYPE_PointerTons1__NSyncWriteMobileEPVInfo:
		return soap_in_PointerTons1__NSyncWriteMobileEPVInfo(soap, tag, NULL, "ns1:NSyncWriteMobileEPVInfo");
	case SOAP_TYPE_PointerTons1__NWriteDeviceStatus:
		return soap_in_PointerTons1__NWriteDeviceStatus(soap, tag, NULL, "ns1:NWriteDeviceStatus");
	case SOAP_TYPE_PointerTons1__WriteFlux:
		return soap_in_PointerTons1__WriteFlux(soap, tag, NULL, "ns1:WriteFlux");
	case SOAP_TYPE_PointerTons1__NSyncWriteVehicleInfo:
		return soap_in_PointerTons1__NSyncWriteVehicleInfo(soap, tag, NULL, "ns1:NSyncWriteVehicleInfo");
	case SOAP_TYPE_PointerTons1__NWriteVehicleInfoEx:
		return soap_in_PointerTons1__NWriteVehicleInfoEx(soap, tag, NULL, "ns1:NWriteVehicleInfoEx");
	case SOAP_TYPE_PointerTons1__NWriteVehicleInfo:
		return soap_in_PointerTons1__NWriteVehicleInfo(soap, tag, NULL, "ns1:NWriteVehicleInfo");
	case SOAP_TYPE_PointerTons1__writeAlarmInfo:
		return soap_in_PointerTons1__writeAlarmInfo(soap, tag, NULL, "ns1:writeAlarmInfo");
	case SOAP_TYPE_PointerTons1__querySyncTime:
		return soap_in_PointerTons1__querySyncTime(soap, tag, NULL, "ns1:querySyncTime");
	case SOAP_TYPE_PointerTons1__logout:
		return soap_in_PointerTons1__logout(soap, tag, NULL, "ns1:logout");
	case SOAP_TYPE_PointerTons1__queryViolateSpeed:
		return soap_in_PointerTons1__queryViolateSpeed(soap, tag, NULL, "ns1:queryViolateSpeed");
	case SOAP_TYPE_PointerTons1__queryLimitSpeed:
		return soap_in_PointerTons1__queryLimitSpeed(soap, tag, NULL, "ns1:queryLimitSpeed");
	case SOAP_TYPE_PointerTons1__login:
		return soap_in_PointerTons1__login(soap, tag, NULL, "ns1:login");
	case SOAP_TYPE_PointerTons1__writeVehicleInfo:
		return soap_in_PointerTons1__writeVehicleInfo(soap, tag, NULL, "ns1:writeVehicleInfo");
	case SOAP_TYPE_PointerTons1__syncWriteVehicleInfo:
		return soap_in_PointerTons1__syncWriteVehicleInfo(soap, tag, NULL, "ns1:syncWriteVehicleInfo");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, tag, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WriteAreaSpeedResponse"))
		{	*type = SOAP_TYPE_ns1__WriteAreaSpeedResponse;
			return soap_in_ns1__WriteAreaSpeedResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WriteAreaSpeed"))
		{	*type = SOAP_TYPE_ns1__WriteAreaSpeed;
			return soap_in_ns1__WriteAreaSpeed(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SyncWriteAreaSpeedResponse"))
		{	*type = SOAP_TYPE_ns1__SyncWriteAreaSpeedResponse;
			return soap_in_ns1__SyncWriteAreaSpeedResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SyncWriteAreaSpeed"))
		{	*type = SOAP_TYPE_ns1__SyncWriteAreaSpeed;
			return soap_in_ns1__SyncWriteAreaSpeed(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WriteVehPassInfoResponse"))
		{	*type = SOAP_TYPE_ns1__WriteVehPassInfoResponse;
			return soap_in_ns1__WriteVehPassInfoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WriteVehPassInfo"))
		{	*type = SOAP_TYPE_ns1__WriteVehPassInfo;
			return soap_in_ns1__WriteVehPassInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SyncWriteVehPassInfoResponse"))
		{	*type = SOAP_TYPE_ns1__SyncWriteVehPassInfoResponse;
			return soap_in_ns1__SyncWriteVehPassInfoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SyncWriteVehPassInfo"))
		{	*type = SOAP_TYPE_ns1__SyncWriteVehPassInfo;
			return soap_in_ns1__SyncWriteVehPassInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NWritePassStatResponse"))
		{	*type = SOAP_TYPE_ns1__NWritePassStatResponse;
			return soap_in_ns1__NWritePassStatResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NWritePassStat"))
		{	*type = SOAP_TYPE_ns1__NWritePassStat;
			return soap_in_ns1__NWritePassStat(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NSyncWriteVioInfoResponse"))
		{	*type = SOAP_TYPE_ns1__NSyncWriteVioInfoResponse;
			return soap_in_ns1__NSyncWriteVioInfoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NSyncWriteVioInfo"))
		{	*type = SOAP_TYPE_ns1__NSyncWriteVioInfo;
			return soap_in_ns1__NSyncWriteVioInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NSyncWriteMobileEPVInfoResponse"))
		{	*type = SOAP_TYPE_ns1__NSyncWriteMobileEPVInfoResponse;
			return soap_in_ns1__NSyncWriteMobileEPVInfoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NSyncWriteMobileEPVInfo"))
		{	*type = SOAP_TYPE_ns1__NSyncWriteMobileEPVInfo;
			return soap_in_ns1__NSyncWriteMobileEPVInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NWriteDeviceStatusResponse"))
		{	*type = SOAP_TYPE_ns1__NWriteDeviceStatusResponse;
			return soap_in_ns1__NWriteDeviceStatusResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NWriteDeviceStatus"))
		{	*type = SOAP_TYPE_ns1__NWriteDeviceStatus;
			return soap_in_ns1__NWriteDeviceStatus(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WriteFluxResponse"))
		{	*type = SOAP_TYPE_ns1__WriteFluxResponse;
			return soap_in_ns1__WriteFluxResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WriteFlux"))
		{	*type = SOAP_TYPE_ns1__WriteFlux;
			return soap_in_ns1__WriteFlux(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NSyncWriteVehicleInfoResponse"))
		{	*type = SOAP_TYPE_ns1__NSyncWriteVehicleInfoResponse;
			return soap_in_ns1__NSyncWriteVehicleInfoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NSyncWriteVehicleInfo"))
		{	*type = SOAP_TYPE_ns1__NSyncWriteVehicleInfo;
			return soap_in_ns1__NSyncWriteVehicleInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NWriteVehicleInfoExResponse"))
		{	*type = SOAP_TYPE_ns1__NWriteVehicleInfoExResponse;
			return soap_in_ns1__NWriteVehicleInfoExResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NWriteVehicleInfoEx"))
		{	*type = SOAP_TYPE_ns1__NWriteVehicleInfoEx;
			return soap_in_ns1__NWriteVehicleInfoEx(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NWriteVehicleInfoResponse"))
		{	*type = SOAP_TYPE_ns1__NWriteVehicleInfoResponse;
			return soap_in_ns1__NWriteVehicleInfoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NWriteVehicleInfo"))
		{	*type = SOAP_TYPE_ns1__NWriteVehicleInfo;
			return soap_in_ns1__NWriteVehicleInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:writeAlarmInfoResponse"))
		{	*type = SOAP_TYPE_ns1__writeAlarmInfoResponse;
			return soap_in_ns1__writeAlarmInfoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:writeAlarmInfo"))
		{	*type = SOAP_TYPE_ns1__writeAlarmInfo;
			return soap_in_ns1__writeAlarmInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:querySyncTimeResponse"))
		{	*type = SOAP_TYPE_ns1__querySyncTimeResponse;
			return soap_in_ns1__querySyncTimeResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:querySyncTime"))
		{	*type = SOAP_TYPE_ns1__querySyncTime;
			return soap_in_ns1__querySyncTime(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:logoutResponse"))
		{	*type = SOAP_TYPE_ns1__logoutResponse;
			return soap_in_ns1__logoutResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:logout"))
		{	*type = SOAP_TYPE_ns1__logout;
			return soap_in_ns1__logout(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryViolateSpeedResponse"))
		{	*type = SOAP_TYPE_ns1__queryViolateSpeedResponse;
			return soap_in_ns1__queryViolateSpeedResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryViolateSpeed"))
		{	*type = SOAP_TYPE_ns1__queryViolateSpeed;
			return soap_in_ns1__queryViolateSpeed(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryLimitSpeedResponse"))
		{	*type = SOAP_TYPE_ns1__queryLimitSpeedResponse;
			return soap_in_ns1__queryLimitSpeedResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryLimitSpeed"))
		{	*type = SOAP_TYPE_ns1__queryLimitSpeed;
			return soap_in_ns1__queryLimitSpeed(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loginResponse"))
		{	*type = SOAP_TYPE_ns1__loginResponse;
			return soap_in_ns1__loginResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:login"))
		{	*type = SOAP_TYPE_ns1__login;
			return soap_in_ns1__login(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:writeVehicleInfoResponse"))
		{	*type = SOAP_TYPE_ns1__writeVehicleInfoResponse;
			return soap_in_ns1__writeVehicleInfoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:writeVehicleInfo"))
		{	*type = SOAP_TYPE_ns1__writeVehicleInfo;
			return soap_in_ns1__writeVehicleInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:syncWriteVehicleInfoResponse"))
		{	*type = SOAP_TYPE_ns1__syncWriteVehicleInfoResponse;
			return soap_in_ns1__syncWriteVehicleInfoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:syncWriteVehicleInfo"))
		{	*type = SOAP_TYPE_ns1__syncWriteVehicleInfo;
			return soap_in_ns1__syncWriteVehicleInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Exception"))
		{	*type = SOAP_TYPE_ns1__Exception;
			return soap_in_ns1__Exception(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input at level = %u body = %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, NULL, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ns1__WriteAreaSpeedResponse:
		return ((ns1__WriteAreaSpeedResponse *)ptr)->soap_out(soap, tag, id, "ns1:WriteAreaSpeedResponse");
	case SOAP_TYPE_ns1__WriteAreaSpeed:
		return ((ns1__WriteAreaSpeed *)ptr)->soap_out(soap, tag, id, "ns1:WriteAreaSpeed");
	case SOAP_TYPE_ns1__SyncWriteAreaSpeedResponse:
		return ((ns1__SyncWriteAreaSpeedResponse *)ptr)->soap_out(soap, tag, id, "ns1:SyncWriteAreaSpeedResponse");
	case SOAP_TYPE_ns1__SyncWriteAreaSpeed:
		return ((ns1__SyncWriteAreaSpeed *)ptr)->soap_out(soap, tag, id, "ns1:SyncWriteAreaSpeed");
	case SOAP_TYPE_ns1__WriteVehPassInfoResponse:
		return ((ns1__WriteVehPassInfoResponse *)ptr)->soap_out(soap, tag, id, "ns1:WriteVehPassInfoResponse");
	case SOAP_TYPE_ns1__WriteVehPassInfo:
		return ((ns1__WriteVehPassInfo *)ptr)->soap_out(soap, tag, id, "ns1:WriteVehPassInfo");
	case SOAP_TYPE_ns1__SyncWriteVehPassInfoResponse:
		return ((ns1__SyncWriteVehPassInfoResponse *)ptr)->soap_out(soap, tag, id, "ns1:SyncWriteVehPassInfoResponse");
	case SOAP_TYPE_ns1__SyncWriteVehPassInfo:
		return ((ns1__SyncWriteVehPassInfo *)ptr)->soap_out(soap, tag, id, "ns1:SyncWriteVehPassInfo");
	case SOAP_TYPE_ns1__NWritePassStatResponse:
		return ((ns1__NWritePassStatResponse *)ptr)->soap_out(soap, tag, id, "ns1:NWritePassStatResponse");
	case SOAP_TYPE_ns1__NWritePassStat:
		return ((ns1__NWritePassStat *)ptr)->soap_out(soap, tag, id, "ns1:NWritePassStat");
	case SOAP_TYPE_ns1__NSyncWriteVioInfoResponse:
		return ((ns1__NSyncWriteVioInfoResponse *)ptr)->soap_out(soap, tag, id, "ns1:NSyncWriteVioInfoResponse");
	case SOAP_TYPE_ns1__NSyncWriteVioInfo:
		return ((ns1__NSyncWriteVioInfo *)ptr)->soap_out(soap, tag, id, "ns1:NSyncWriteVioInfo");
	case SOAP_TYPE_ns1__NSyncWriteMobileEPVInfoResponse:
		return ((ns1__NSyncWriteMobileEPVInfoResponse *)ptr)->soap_out(soap, tag, id, "ns1:NSyncWriteMobileEPVInfoResponse");
	case SOAP_TYPE_ns1__NSyncWriteMobileEPVInfo:
		return ((ns1__NSyncWriteMobileEPVInfo *)ptr)->soap_out(soap, tag, id, "ns1:NSyncWriteMobileEPVInfo");
	case SOAP_TYPE_ns1__NWriteDeviceStatusResponse:
		return ((ns1__NWriteDeviceStatusResponse *)ptr)->soap_out(soap, tag, id, "ns1:NWriteDeviceStatusResponse");
	case SOAP_TYPE_ns1__NWriteDeviceStatus:
		return ((ns1__NWriteDeviceStatus *)ptr)->soap_out(soap, tag, id, "ns1:NWriteDeviceStatus");
	case SOAP_TYPE_ns1__WriteFluxResponse:
		return ((ns1__WriteFluxResponse *)ptr)->soap_out(soap, tag, id, "ns1:WriteFluxResponse");
	case SOAP_TYPE_ns1__WriteFlux:
		return ((ns1__WriteFlux *)ptr)->soap_out(soap, tag, id, "ns1:WriteFlux");
	case SOAP_TYPE_ns1__NSyncWriteVehicleInfoResponse:
		return ((ns1__NSyncWriteVehicleInfoResponse *)ptr)->soap_out(soap, tag, id, "ns1:NSyncWriteVehicleInfoResponse");
	case SOAP_TYPE_ns1__NSyncWriteVehicleInfo:
		return ((ns1__NSyncWriteVehicleInfo *)ptr)->soap_out(soap, tag, id, "ns1:NSyncWriteVehicleInfo");
	case SOAP_TYPE_ns1__NWriteVehicleInfoExResponse:
		return ((ns1__NWriteVehicleInfoExResponse *)ptr)->soap_out(soap, tag, id, "ns1:NWriteVehicleInfoExResponse");
	case SOAP_TYPE_ns1__NWriteVehicleInfoEx:
		return ((ns1__NWriteVehicleInfoEx *)ptr)->soap_out(soap, tag, id, "ns1:NWriteVehicleInfoEx");
	case SOAP_TYPE_ns1__NWriteVehicleInfoResponse:
		return ((ns1__NWriteVehicleInfoResponse *)ptr)->soap_out(soap, tag, id, "ns1:NWriteVehicleInfoResponse");
	case SOAP_TYPE_ns1__NWriteVehicleInfo:
		return ((ns1__NWriteVehicleInfo *)ptr)->soap_out(soap, tag, id, "ns1:NWriteVehicleInfo");
	case SOAP_TYPE_ns1__writeAlarmInfoResponse:
		return ((ns1__writeAlarmInfoResponse *)ptr)->soap_out(soap, tag, id, "ns1:writeAlarmInfoResponse");
	case SOAP_TYPE_ns1__writeAlarmInfo:
		return ((ns1__writeAlarmInfo *)ptr)->soap_out(soap, tag, id, "ns1:writeAlarmInfo");
	case SOAP_TYPE_ns1__querySyncTimeResponse:
		return ((ns1__querySyncTimeResponse *)ptr)->soap_out(soap, tag, id, "ns1:querySyncTimeResponse");
	case SOAP_TYPE_ns1__querySyncTime:
		return ((ns1__querySyncTime *)ptr)->soap_out(soap, tag, id, "ns1:querySyncTime");
	case SOAP_TYPE_ns1__logoutResponse:
		return ((ns1__logoutResponse *)ptr)->soap_out(soap, tag, id, "ns1:logoutResponse");
	case SOAP_TYPE_ns1__logout:
		return ((ns1__logout *)ptr)->soap_out(soap, tag, id, "ns1:logout");
	case SOAP_TYPE_ns1__queryViolateSpeedResponse:
		return ((ns1__queryViolateSpeedResponse *)ptr)->soap_out(soap, tag, id, "ns1:queryViolateSpeedResponse");
	case SOAP_TYPE_ns1__queryViolateSpeed:
		return ((ns1__queryViolateSpeed *)ptr)->soap_out(soap, tag, id, "ns1:queryViolateSpeed");
	case SOAP_TYPE_ns1__queryLimitSpeedResponse:
		return ((ns1__queryLimitSpeedResponse *)ptr)->soap_out(soap, tag, id, "ns1:queryLimitSpeedResponse");
	case SOAP_TYPE_ns1__queryLimitSpeed:
		return ((ns1__queryLimitSpeed *)ptr)->soap_out(soap, tag, id, "ns1:queryLimitSpeed");
	case SOAP_TYPE_ns1__loginResponse:
		return ((ns1__loginResponse *)ptr)->soap_out(soap, tag, id, "ns1:loginResponse");
	case SOAP_TYPE_ns1__login:
		return ((ns1__login *)ptr)->soap_out(soap, tag, id, "ns1:login");
	case SOAP_TYPE_ns1__writeVehicleInfoResponse:
		return ((ns1__writeVehicleInfoResponse *)ptr)->soap_out(soap, tag, id, "ns1:writeVehicleInfoResponse");
	case SOAP_TYPE_ns1__writeVehicleInfo:
		return ((ns1__writeVehicleInfo *)ptr)->soap_out(soap, tag, id, "ns1:writeVehicleInfo");
	case SOAP_TYPE_ns1__syncWriteVehicleInfoResponse:
		return ((ns1__syncWriteVehicleInfoResponse *)ptr)->soap_out(soap, tag, id, "ns1:syncWriteVehicleInfoResponse");
	case SOAP_TYPE_ns1__syncWriteVehicleInfo:
		return ((ns1__syncWriteVehicleInfo *)ptr)->soap_out(soap, tag, id, "ns1:syncWriteVehicleInfo");
	case SOAP_TYPE_ns1__Exception:
		return ((ns1__Exception *)ptr)->soap_out(soap, tag, id, "ns1:Exception");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_PointerTons1__WriteAreaSpeed:
		return soap_out_PointerTons1__WriteAreaSpeed(soap, tag, id, (ns1__WriteAreaSpeed *const*)ptr, "ns1:WriteAreaSpeed");
	case SOAP_TYPE_PointerTons1__SyncWriteAreaSpeed:
		return soap_out_PointerTons1__SyncWriteAreaSpeed(soap, tag, id, (ns1__SyncWriteAreaSpeed *const*)ptr, "ns1:SyncWriteAreaSpeed");
	case SOAP_TYPE_PointerTons1__WriteVehPassInfo:
		return soap_out_PointerTons1__WriteVehPassInfo(soap, tag, id, (ns1__WriteVehPassInfo *const*)ptr, "ns1:WriteVehPassInfo");
	case SOAP_TYPE_PointerTons1__SyncWriteVehPassInfo:
		return soap_out_PointerTons1__SyncWriteVehPassInfo(soap, tag, id, (ns1__SyncWriteVehPassInfo *const*)ptr, "ns1:SyncWriteVehPassInfo");
	case SOAP_TYPE_PointerTons1__NWritePassStat:
		return soap_out_PointerTons1__NWritePassStat(soap, tag, id, (ns1__NWritePassStat *const*)ptr, "ns1:NWritePassStat");
	case SOAP_TYPE_PointerTons1__NSyncWriteVioInfo:
		return soap_out_PointerTons1__NSyncWriteVioInfo(soap, tag, id, (ns1__NSyncWriteVioInfo *const*)ptr, "ns1:NSyncWriteVioInfo");
	case SOAP_TYPE_PointerTons1__NSyncWriteMobileEPVInfo:
		return soap_out_PointerTons1__NSyncWriteMobileEPVInfo(soap, tag, id, (ns1__NSyncWriteMobileEPVInfo *const*)ptr, "ns1:NSyncWriteMobileEPVInfo");
	case SOAP_TYPE_PointerTons1__NWriteDeviceStatus:
		return soap_out_PointerTons1__NWriteDeviceStatus(soap, tag, id, (ns1__NWriteDeviceStatus *const*)ptr, "ns1:NWriteDeviceStatus");
	case SOAP_TYPE_PointerTons1__WriteFlux:
		return soap_out_PointerTons1__WriteFlux(soap, tag, id, (ns1__WriteFlux *const*)ptr, "ns1:WriteFlux");
	case SOAP_TYPE_PointerTons1__NSyncWriteVehicleInfo:
		return soap_out_PointerTons1__NSyncWriteVehicleInfo(soap, tag, id, (ns1__NSyncWriteVehicleInfo *const*)ptr, "ns1:NSyncWriteVehicleInfo");
	case SOAP_TYPE_PointerTons1__NWriteVehicleInfoEx:
		return soap_out_PointerTons1__NWriteVehicleInfoEx(soap, tag, id, (ns1__NWriteVehicleInfoEx *const*)ptr, "ns1:NWriteVehicleInfoEx");
	case SOAP_TYPE_PointerTons1__NWriteVehicleInfo:
		return soap_out_PointerTons1__NWriteVehicleInfo(soap, tag, id, (ns1__NWriteVehicleInfo *const*)ptr, "ns1:NWriteVehicleInfo");
	case SOAP_TYPE_PointerTons1__writeAlarmInfo:
		return soap_out_PointerTons1__writeAlarmInfo(soap, tag, id, (ns1__writeAlarmInfo *const*)ptr, "ns1:writeAlarmInfo");
	case SOAP_TYPE_PointerTons1__querySyncTime:
		return soap_out_PointerTons1__querySyncTime(soap, tag, id, (ns1__querySyncTime *const*)ptr, "ns1:querySyncTime");
	case SOAP_TYPE_PointerTons1__logout:
		return soap_out_PointerTons1__logout(soap, tag, id, (ns1__logout *const*)ptr, "ns1:logout");
	case SOAP_TYPE_PointerTons1__queryViolateSpeed:
		return soap_out_PointerTons1__queryViolateSpeed(soap, tag, id, (ns1__queryViolateSpeed *const*)ptr, "ns1:queryViolateSpeed");
	case SOAP_TYPE_PointerTons1__queryLimitSpeed:
		return soap_out_PointerTons1__queryLimitSpeed(soap, tag, id, (ns1__queryLimitSpeed *const*)ptr, "ns1:queryLimitSpeed");
	case SOAP_TYPE_PointerTons1__login:
		return soap_out_PointerTons1__login(soap, tag, id, (ns1__login *const*)ptr, "ns1:login");
	case SOAP_TYPE_PointerTons1__writeVehicleInfo:
		return soap_out_PointerTons1__writeVehicleInfo(soap, tag, id, (ns1__writeVehicleInfo *const*)ptr, "ns1:writeVehicleInfo");
	case SOAP_TYPE_PointerTons1__syncWriteVehicleInfo:
		return soap_out_PointerTons1__syncWriteVehicleInfo(soap, tag, id, (ns1__syncWriteVehicleInfo *const*)ptr, "ns1:syncWriteVehicleInfo");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag); /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__WriteAreaSpeedResponse:
		((ns1__WriteAreaSpeedResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__WriteAreaSpeed:
		((ns1__WriteAreaSpeed *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SyncWriteAreaSpeedResponse:
		((ns1__SyncWriteAreaSpeedResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SyncWriteAreaSpeed:
		((ns1__SyncWriteAreaSpeed *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__WriteVehPassInfoResponse:
		((ns1__WriteVehPassInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__WriteVehPassInfo:
		((ns1__WriteVehPassInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SyncWriteVehPassInfoResponse:
		((ns1__SyncWriteVehPassInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SyncWriteVehPassInfo:
		((ns1__SyncWriteVehPassInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__NWritePassStatResponse:
		((ns1__NWritePassStatResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__NWritePassStat:
		((ns1__NWritePassStat *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__NSyncWriteVioInfoResponse:
		((ns1__NSyncWriteVioInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__NSyncWriteVioInfo:
		((ns1__NSyncWriteVioInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__NSyncWriteMobileEPVInfoResponse:
		((ns1__NSyncWriteMobileEPVInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__NSyncWriteMobileEPVInfo:
		((ns1__NSyncWriteMobileEPVInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__NWriteDeviceStatusResponse:
		((ns1__NWriteDeviceStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__NWriteDeviceStatus:
		((ns1__NWriteDeviceStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__WriteFluxResponse:
		((ns1__WriteFluxResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__WriteFlux:
		((ns1__WriteFlux *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__NSyncWriteVehicleInfoResponse:
		((ns1__NSyncWriteVehicleInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__NSyncWriteVehicleInfo:
		((ns1__NSyncWriteVehicleInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__NWriteVehicleInfoExResponse:
		((ns1__NWriteVehicleInfoExResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__NWriteVehicleInfoEx:
		((ns1__NWriteVehicleInfoEx *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__NWriteVehicleInfoResponse:
		((ns1__NWriteVehicleInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__NWriteVehicleInfo:
		((ns1__NWriteVehicleInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__writeAlarmInfoResponse:
		((ns1__writeAlarmInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__writeAlarmInfo:
		((ns1__writeAlarmInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__querySyncTimeResponse:
		((ns1__querySyncTimeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__querySyncTime:
		((ns1__querySyncTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__logoutResponse:
		((ns1__logoutResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__logout:
		((ns1__logout *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__queryViolateSpeedResponse:
		((ns1__queryViolateSpeedResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__queryViolateSpeed:
		((ns1__queryViolateSpeed *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__queryLimitSpeedResponse:
		((ns1__queryLimitSpeedResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__queryLimitSpeed:
		((ns1__queryLimitSpeed *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__loginResponse:
		((ns1__loginResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__login:
		((ns1__login *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__writeVehicleInfoResponse:
		((ns1__writeVehicleInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__writeVehicleInfo:
		((ns1__writeVehicleInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__syncWriteVehicleInfoResponse:
		((ns1__syncWriteVehicleInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__syncWriteVehicleInfo:
		((ns1__syncWriteVehicleInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Exception:
		((ns1__Exception *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__WriteAreaSpeed:
		soap_serialize___ns1__WriteAreaSpeed(soap, (const struct __ns1__WriteAreaSpeed *)ptr);
		break;
	case SOAP_TYPE___ns1__SyncWriteAreaSpeed:
		soap_serialize___ns1__SyncWriteAreaSpeed(soap, (const struct __ns1__SyncWriteAreaSpeed *)ptr);
		break;
	case SOAP_TYPE___ns1__WriteVehPassInfo:
		soap_serialize___ns1__WriteVehPassInfo(soap, (const struct __ns1__WriteVehPassInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__SyncWriteVehPassInfo:
		soap_serialize___ns1__SyncWriteVehPassInfo(soap, (const struct __ns1__SyncWriteVehPassInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__NWritePassStat:
		soap_serialize___ns1__NWritePassStat(soap, (const struct __ns1__NWritePassStat *)ptr);
		break;
	case SOAP_TYPE___ns1__NSyncWriteVioInfo:
		soap_serialize___ns1__NSyncWriteVioInfo(soap, (const struct __ns1__NSyncWriteVioInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__NSyncWriteMobileEPVInfo:
		soap_serialize___ns1__NSyncWriteMobileEPVInfo(soap, (const struct __ns1__NSyncWriteMobileEPVInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__NWriteDeviceStatus:
		soap_serialize___ns1__NWriteDeviceStatus(soap, (const struct __ns1__NWriteDeviceStatus *)ptr);
		break;
	case SOAP_TYPE___ns1__WriteFlux:
		soap_serialize___ns1__WriteFlux(soap, (const struct __ns1__WriteFlux *)ptr);
		break;
	case SOAP_TYPE___ns1__NSyncWriteVehicleInfo:
		soap_serialize___ns1__NSyncWriteVehicleInfo(soap, (const struct __ns1__NSyncWriteVehicleInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__NWriteVehicleInfoEx:
		soap_serialize___ns1__NWriteVehicleInfoEx(soap, (const struct __ns1__NWriteVehicleInfoEx *)ptr);
		break;
	case SOAP_TYPE___ns1__NWriteVehicleInfo:
		soap_serialize___ns1__NWriteVehicleInfo(soap, (const struct __ns1__NWriteVehicleInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__writeAlarmInfo:
		soap_serialize___ns1__writeAlarmInfo(soap, (const struct __ns1__writeAlarmInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__querySyncTime:
		soap_serialize___ns1__querySyncTime(soap, (const struct __ns1__querySyncTime *)ptr);
		break;
	case SOAP_TYPE___ns1__logout:
		soap_serialize___ns1__logout(soap, (const struct __ns1__logout *)ptr);
		break;
	case SOAP_TYPE___ns1__queryViolateSpeed:
		soap_serialize___ns1__queryViolateSpeed(soap, (const struct __ns1__queryViolateSpeed *)ptr);
		break;
	case SOAP_TYPE___ns1__queryLimitSpeed:
		soap_serialize___ns1__queryLimitSpeed(soap, (const struct __ns1__queryLimitSpeed *)ptr);
		break;
	case SOAP_TYPE___ns1__login:
		soap_serialize___ns1__login(soap, (const struct __ns1__login *)ptr);
		break;
	case SOAP_TYPE___ns1__writeVehicleInfo:
		soap_serialize___ns1__writeVehicleInfo(soap, (const struct __ns1__writeVehicleInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__syncWriteVehicleInfo:
		soap_serialize___ns1__syncWriteVehicleInfo(soap, (const struct __ns1__syncWriteVehicleInfo *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__WriteAreaSpeed:
		soap_serialize_PointerTons1__WriteAreaSpeed(soap, (ns1__WriteAreaSpeed *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SyncWriteAreaSpeed:
		soap_serialize_PointerTons1__SyncWriteAreaSpeed(soap, (ns1__SyncWriteAreaSpeed *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__WriteVehPassInfo:
		soap_serialize_PointerTons1__WriteVehPassInfo(soap, (ns1__WriteVehPassInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SyncWriteVehPassInfo:
		soap_serialize_PointerTons1__SyncWriteVehPassInfo(soap, (ns1__SyncWriteVehPassInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__NWritePassStat:
		soap_serialize_PointerTons1__NWritePassStat(soap, (ns1__NWritePassStat *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__NSyncWriteVioInfo:
		soap_serialize_PointerTons1__NSyncWriteVioInfo(soap, (ns1__NSyncWriteVioInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__NSyncWriteMobileEPVInfo:
		soap_serialize_PointerTons1__NSyncWriteMobileEPVInfo(soap, (ns1__NSyncWriteMobileEPVInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__NWriteDeviceStatus:
		soap_serialize_PointerTons1__NWriteDeviceStatus(soap, (ns1__NWriteDeviceStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__WriteFlux:
		soap_serialize_PointerTons1__WriteFlux(soap, (ns1__WriteFlux *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__NSyncWriteVehicleInfo:
		soap_serialize_PointerTons1__NSyncWriteVehicleInfo(soap, (ns1__NSyncWriteVehicleInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__NWriteVehicleInfoEx:
		soap_serialize_PointerTons1__NWriteVehicleInfoEx(soap, (ns1__NWriteVehicleInfoEx *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__NWriteVehicleInfo:
		soap_serialize_PointerTons1__NWriteVehicleInfo(soap, (ns1__NWriteVehicleInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__writeAlarmInfo:
		soap_serialize_PointerTons1__writeAlarmInfo(soap, (ns1__writeAlarmInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__querySyncTime:
		soap_serialize_PointerTons1__querySyncTime(soap, (ns1__querySyncTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__logout:
		soap_serialize_PointerTons1__logout(soap, (ns1__logout *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__queryViolateSpeed:
		soap_serialize_PointerTons1__queryViolateSpeed(soap, (ns1__queryViolateSpeed *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__queryLimitSpeed:
		soap_serialize_PointerTons1__queryLimitSpeed(soap, (ns1__queryLimitSpeed *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__login:
		soap_serialize_PointerTons1__login(soap, (ns1__login *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__writeVehicleInfo:
		soap_serialize_PointerTons1__writeVehicleInfo(soap, (ns1__writeVehicleInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__syncWriteVehicleInfo:
		soap_serialize_PointerTons1__syncWriteVehicleInfo(soap, (ns1__syncWriteVehicleInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Exception:
		return (void*)soap_instantiate_ns1__Exception(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__syncWriteVehicleInfo:
		return (void*)soap_instantiate_ns1__syncWriteVehicleInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__syncWriteVehicleInfoResponse:
		return (void*)soap_instantiate_ns1__syncWriteVehicleInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__writeVehicleInfo:
		return (void*)soap_instantiate_ns1__writeVehicleInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__writeVehicleInfoResponse:
		return (void*)soap_instantiate_ns1__writeVehicleInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__login:
		return (void*)soap_instantiate_ns1__login(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__loginResponse:
		return (void*)soap_instantiate_ns1__loginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__queryLimitSpeed:
		return (void*)soap_instantiate_ns1__queryLimitSpeed(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__queryLimitSpeedResponse:
		return (void*)soap_instantiate_ns1__queryLimitSpeedResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__queryViolateSpeed:
		return (void*)soap_instantiate_ns1__queryViolateSpeed(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__queryViolateSpeedResponse:
		return (void*)soap_instantiate_ns1__queryViolateSpeedResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__logout:
		return (void*)soap_instantiate_ns1__logout(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__logoutResponse:
		return (void*)soap_instantiate_ns1__logoutResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__querySyncTime:
		return (void*)soap_instantiate_ns1__querySyncTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__querySyncTimeResponse:
		return (void*)soap_instantiate_ns1__querySyncTimeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__writeAlarmInfo:
		return (void*)soap_instantiate_ns1__writeAlarmInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__writeAlarmInfoResponse:
		return (void*)soap_instantiate_ns1__writeAlarmInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NWriteVehicleInfo:
		return (void*)soap_instantiate_ns1__NWriteVehicleInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NWriteVehicleInfoResponse:
		return (void*)soap_instantiate_ns1__NWriteVehicleInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NWriteVehicleInfoEx:
		return (void*)soap_instantiate_ns1__NWriteVehicleInfoEx(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NWriteVehicleInfoExResponse:
		return (void*)soap_instantiate_ns1__NWriteVehicleInfoExResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NSyncWriteVehicleInfo:
		return (void*)soap_instantiate_ns1__NSyncWriteVehicleInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NSyncWriteVehicleInfoResponse:
		return (void*)soap_instantiate_ns1__NSyncWriteVehicleInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__WriteFlux:
		return (void*)soap_instantiate_ns1__WriteFlux(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__WriteFluxResponse:
		return (void*)soap_instantiate_ns1__WriteFluxResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NWriteDeviceStatus:
		return (void*)soap_instantiate_ns1__NWriteDeviceStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NWriteDeviceStatusResponse:
		return (void*)soap_instantiate_ns1__NWriteDeviceStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NSyncWriteMobileEPVInfo:
		return (void*)soap_instantiate_ns1__NSyncWriteMobileEPVInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NSyncWriteMobileEPVInfoResponse:
		return (void*)soap_instantiate_ns1__NSyncWriteMobileEPVInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NSyncWriteVioInfo:
		return (void*)soap_instantiate_ns1__NSyncWriteVioInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NSyncWriteVioInfoResponse:
		return (void*)soap_instantiate_ns1__NSyncWriteVioInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NWritePassStat:
		return (void*)soap_instantiate_ns1__NWritePassStat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NWritePassStatResponse:
		return (void*)soap_instantiate_ns1__NWritePassStatResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SyncWriteVehPassInfo:
		return (void*)soap_instantiate_ns1__SyncWriteVehPassInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SyncWriteVehPassInfoResponse:
		return (void*)soap_instantiate_ns1__SyncWriteVehPassInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__WriteVehPassInfo:
		return (void*)soap_instantiate_ns1__WriteVehPassInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__WriteVehPassInfoResponse:
		return (void*)soap_instantiate_ns1__WriteVehPassInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SyncWriteAreaSpeed:
		return (void*)soap_instantiate_ns1__SyncWriteAreaSpeed(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SyncWriteAreaSpeedResponse:
		return (void*)soap_instantiate_ns1__SyncWriteAreaSpeedResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__WriteAreaSpeed:
		return (void*)soap_instantiate_ns1__WriteAreaSpeed(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__WriteAreaSpeedResponse:
		return (void*)soap_instantiate_ns1__WriteAreaSpeedResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__syncWriteVehicleInfo:
		return (void*)soap_instantiate___ns1__syncWriteVehicleInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__writeVehicleInfo:
		return (void*)soap_instantiate___ns1__writeVehicleInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__login:
		return (void*)soap_instantiate___ns1__login(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__queryLimitSpeed:
		return (void*)soap_instantiate___ns1__queryLimitSpeed(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__queryViolateSpeed:
		return (void*)soap_instantiate___ns1__queryViolateSpeed(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__logout:
		return (void*)soap_instantiate___ns1__logout(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__querySyncTime:
		return (void*)soap_instantiate___ns1__querySyncTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__writeAlarmInfo:
		return (void*)soap_instantiate___ns1__writeAlarmInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__NWriteVehicleInfo:
		return (void*)soap_instantiate___ns1__NWriteVehicleInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__NWriteVehicleInfoEx:
		return (void*)soap_instantiate___ns1__NWriteVehicleInfoEx(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__NSyncWriteVehicleInfo:
		return (void*)soap_instantiate___ns1__NSyncWriteVehicleInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__WriteFlux:
		return (void*)soap_instantiate___ns1__WriteFlux(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__NWriteDeviceStatus:
		return (void*)soap_instantiate___ns1__NWriteDeviceStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__NSyncWriteMobileEPVInfo:
		return (void*)soap_instantiate___ns1__NSyncWriteMobileEPVInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__NSyncWriteVioInfo:
		return (void*)soap_instantiate___ns1__NSyncWriteVioInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__NWritePassStat:
		return (void*)soap_instantiate___ns1__NWritePassStat(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SyncWriteVehPassInfo:
		return (void*)soap_instantiate___ns1__SyncWriteVehPassInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__WriteVehPassInfo:
		return (void*)soap_instantiate___ns1__WriteVehPassInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SyncWriteAreaSpeed:
		return (void*)soap_instantiate___ns1__SyncWriteAreaSpeed(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__WriteAreaSpeed:
		return (void*)soap_instantiate___ns1__WriteAreaSpeed(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap *soap, struct soap_clist *p)
{
	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__base64Binary*>(p->ptr), xsd__base64Binary);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__base64Binary*>(p->ptr), xsd__base64Binary);
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__Exception:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Exception*>(p->ptr), ns1__Exception);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Exception*>(p->ptr), ns1__Exception);
		break;
	case SOAP_TYPE_ns1__syncWriteVehicleInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__syncWriteVehicleInfo*>(p->ptr), ns1__syncWriteVehicleInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__syncWriteVehicleInfo*>(p->ptr), ns1__syncWriteVehicleInfo);
		break;
	case SOAP_TYPE_ns1__syncWriteVehicleInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__syncWriteVehicleInfoResponse*>(p->ptr), ns1__syncWriteVehicleInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__syncWriteVehicleInfoResponse*>(p->ptr), ns1__syncWriteVehicleInfoResponse);
		break;
	case SOAP_TYPE_ns1__writeVehicleInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__writeVehicleInfo*>(p->ptr), ns1__writeVehicleInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__writeVehicleInfo*>(p->ptr), ns1__writeVehicleInfo);
		break;
	case SOAP_TYPE_ns1__writeVehicleInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__writeVehicleInfoResponse*>(p->ptr), ns1__writeVehicleInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__writeVehicleInfoResponse*>(p->ptr), ns1__writeVehicleInfoResponse);
		break;
	case SOAP_TYPE_ns1__login:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__login*>(p->ptr), ns1__login);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__login*>(p->ptr), ns1__login);
		break;
	case SOAP_TYPE_ns1__loginResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__loginResponse*>(p->ptr), ns1__loginResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__loginResponse*>(p->ptr), ns1__loginResponse);
		break;
	case SOAP_TYPE_ns1__queryLimitSpeed:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__queryLimitSpeed*>(p->ptr), ns1__queryLimitSpeed);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__queryLimitSpeed*>(p->ptr), ns1__queryLimitSpeed);
		break;
	case SOAP_TYPE_ns1__queryLimitSpeedResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__queryLimitSpeedResponse*>(p->ptr), ns1__queryLimitSpeedResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__queryLimitSpeedResponse*>(p->ptr), ns1__queryLimitSpeedResponse);
		break;
	case SOAP_TYPE_ns1__queryViolateSpeed:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__queryViolateSpeed*>(p->ptr), ns1__queryViolateSpeed);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__queryViolateSpeed*>(p->ptr), ns1__queryViolateSpeed);
		break;
	case SOAP_TYPE_ns1__queryViolateSpeedResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__queryViolateSpeedResponse*>(p->ptr), ns1__queryViolateSpeedResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__queryViolateSpeedResponse*>(p->ptr), ns1__queryViolateSpeedResponse);
		break;
	case SOAP_TYPE_ns1__logout:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__logout*>(p->ptr), ns1__logout);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__logout*>(p->ptr), ns1__logout);
		break;
	case SOAP_TYPE_ns1__logoutResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__logoutResponse*>(p->ptr), ns1__logoutResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__logoutResponse*>(p->ptr), ns1__logoutResponse);
		break;
	case SOAP_TYPE_ns1__querySyncTime:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__querySyncTime*>(p->ptr), ns1__querySyncTime);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__querySyncTime*>(p->ptr), ns1__querySyncTime);
		break;
	case SOAP_TYPE_ns1__querySyncTimeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__querySyncTimeResponse*>(p->ptr), ns1__querySyncTimeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__querySyncTimeResponse*>(p->ptr), ns1__querySyncTimeResponse);
		break;
	case SOAP_TYPE_ns1__writeAlarmInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__writeAlarmInfo*>(p->ptr), ns1__writeAlarmInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__writeAlarmInfo*>(p->ptr), ns1__writeAlarmInfo);
		break;
	case SOAP_TYPE_ns1__writeAlarmInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__writeAlarmInfoResponse*>(p->ptr), ns1__writeAlarmInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__writeAlarmInfoResponse*>(p->ptr), ns1__writeAlarmInfoResponse);
		break;
	case SOAP_TYPE_ns1__NWriteVehicleInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__NWriteVehicleInfo*>(p->ptr), ns1__NWriteVehicleInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__NWriteVehicleInfo*>(p->ptr), ns1__NWriteVehicleInfo);
		break;
	case SOAP_TYPE_ns1__NWriteVehicleInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__NWriteVehicleInfoResponse*>(p->ptr), ns1__NWriteVehicleInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__NWriteVehicleInfoResponse*>(p->ptr), ns1__NWriteVehicleInfoResponse);
		break;
	case SOAP_TYPE_ns1__NWriteVehicleInfoEx:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__NWriteVehicleInfoEx*>(p->ptr), ns1__NWriteVehicleInfoEx);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__NWriteVehicleInfoEx*>(p->ptr), ns1__NWriteVehicleInfoEx);
		break;
	case SOAP_TYPE_ns1__NWriteVehicleInfoExResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__NWriteVehicleInfoExResponse*>(p->ptr), ns1__NWriteVehicleInfoExResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__NWriteVehicleInfoExResponse*>(p->ptr), ns1__NWriteVehicleInfoExResponse);
		break;
	case SOAP_TYPE_ns1__NSyncWriteVehicleInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__NSyncWriteVehicleInfo*>(p->ptr), ns1__NSyncWriteVehicleInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__NSyncWriteVehicleInfo*>(p->ptr), ns1__NSyncWriteVehicleInfo);
		break;
	case SOAP_TYPE_ns1__NSyncWriteVehicleInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__NSyncWriteVehicleInfoResponse*>(p->ptr), ns1__NSyncWriteVehicleInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__NSyncWriteVehicleInfoResponse*>(p->ptr), ns1__NSyncWriteVehicleInfoResponse);
		break;
	case SOAP_TYPE_ns1__WriteFlux:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__WriteFlux*>(p->ptr), ns1__WriteFlux);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__WriteFlux*>(p->ptr), ns1__WriteFlux);
		break;
	case SOAP_TYPE_ns1__WriteFluxResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__WriteFluxResponse*>(p->ptr), ns1__WriteFluxResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__WriteFluxResponse*>(p->ptr), ns1__WriteFluxResponse);
		break;
	case SOAP_TYPE_ns1__NWriteDeviceStatus:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__NWriteDeviceStatus*>(p->ptr), ns1__NWriteDeviceStatus);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__NWriteDeviceStatus*>(p->ptr), ns1__NWriteDeviceStatus);
		break;
	case SOAP_TYPE_ns1__NWriteDeviceStatusResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__NWriteDeviceStatusResponse*>(p->ptr), ns1__NWriteDeviceStatusResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__NWriteDeviceStatusResponse*>(p->ptr), ns1__NWriteDeviceStatusResponse);
		break;
	case SOAP_TYPE_ns1__NSyncWriteMobileEPVInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__NSyncWriteMobileEPVInfo*>(p->ptr), ns1__NSyncWriteMobileEPVInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__NSyncWriteMobileEPVInfo*>(p->ptr), ns1__NSyncWriteMobileEPVInfo);
		break;
	case SOAP_TYPE_ns1__NSyncWriteMobileEPVInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__NSyncWriteMobileEPVInfoResponse*>(p->ptr), ns1__NSyncWriteMobileEPVInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__NSyncWriteMobileEPVInfoResponse*>(p->ptr), ns1__NSyncWriteMobileEPVInfoResponse);
		break;
	case SOAP_TYPE_ns1__NSyncWriteVioInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__NSyncWriteVioInfo*>(p->ptr), ns1__NSyncWriteVioInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__NSyncWriteVioInfo*>(p->ptr), ns1__NSyncWriteVioInfo);
		break;
	case SOAP_TYPE_ns1__NSyncWriteVioInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__NSyncWriteVioInfoResponse*>(p->ptr), ns1__NSyncWriteVioInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__NSyncWriteVioInfoResponse*>(p->ptr), ns1__NSyncWriteVioInfoResponse);
		break;
	case SOAP_TYPE_ns1__NWritePassStat:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__NWritePassStat*>(p->ptr), ns1__NWritePassStat);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__NWritePassStat*>(p->ptr), ns1__NWritePassStat);
		break;
	case SOAP_TYPE_ns1__NWritePassStatResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__NWritePassStatResponse*>(p->ptr), ns1__NWritePassStatResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__NWritePassStatResponse*>(p->ptr), ns1__NWritePassStatResponse);
		break;
	case SOAP_TYPE_ns1__SyncWriteVehPassInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SyncWriteVehPassInfo*>(p->ptr), ns1__SyncWriteVehPassInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SyncWriteVehPassInfo*>(p->ptr), ns1__SyncWriteVehPassInfo);
		break;
	case SOAP_TYPE_ns1__SyncWriteVehPassInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SyncWriteVehPassInfoResponse*>(p->ptr), ns1__SyncWriteVehPassInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SyncWriteVehPassInfoResponse*>(p->ptr), ns1__SyncWriteVehPassInfoResponse);
		break;
	case SOAP_TYPE_ns1__WriteVehPassInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__WriteVehPassInfo*>(p->ptr), ns1__WriteVehPassInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__WriteVehPassInfo*>(p->ptr), ns1__WriteVehPassInfo);
		break;
	case SOAP_TYPE_ns1__WriteVehPassInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__WriteVehPassInfoResponse*>(p->ptr), ns1__WriteVehPassInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__WriteVehPassInfoResponse*>(p->ptr), ns1__WriteVehPassInfoResponse);
		break;
	case SOAP_TYPE_ns1__SyncWriteAreaSpeed:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SyncWriteAreaSpeed*>(p->ptr), ns1__SyncWriteAreaSpeed);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SyncWriteAreaSpeed*>(p->ptr), ns1__SyncWriteAreaSpeed);
		break;
	case SOAP_TYPE_ns1__SyncWriteAreaSpeedResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SyncWriteAreaSpeedResponse*>(p->ptr), ns1__SyncWriteAreaSpeedResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SyncWriteAreaSpeedResponse*>(p->ptr), ns1__SyncWriteAreaSpeedResponse);
		break;
	case SOAP_TYPE_ns1__WriteAreaSpeed:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__WriteAreaSpeed*>(p->ptr), ns1__WriteAreaSpeed);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__WriteAreaSpeed*>(p->ptr), ns1__WriteAreaSpeed);
		break;
	case SOAP_TYPE_ns1__WriteAreaSpeedResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__WriteAreaSpeedResponse*>(p->ptr), ns1__WriteAreaSpeedResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__WriteAreaSpeedResponse*>(p->ptr), ns1__WriteAreaSpeedResponse);
		break;
	case SOAP_TYPE___ns1__syncWriteVehicleInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__syncWriteVehicleInfo*>(p->ptr), struct __ns1__syncWriteVehicleInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__syncWriteVehicleInfo*>(p->ptr), struct __ns1__syncWriteVehicleInfo);
		break;
	case SOAP_TYPE___ns1__writeVehicleInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__writeVehicleInfo*>(p->ptr), struct __ns1__writeVehicleInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__writeVehicleInfo*>(p->ptr), struct __ns1__writeVehicleInfo);
		break;
	case SOAP_TYPE___ns1__login:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__login*>(p->ptr), struct __ns1__login);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__login*>(p->ptr), struct __ns1__login);
		break;
	case SOAP_TYPE___ns1__queryLimitSpeed:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__queryLimitSpeed*>(p->ptr), struct __ns1__queryLimitSpeed);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__queryLimitSpeed*>(p->ptr), struct __ns1__queryLimitSpeed);
		break;
	case SOAP_TYPE___ns1__queryViolateSpeed:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__queryViolateSpeed*>(p->ptr), struct __ns1__queryViolateSpeed);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__queryViolateSpeed*>(p->ptr), struct __ns1__queryViolateSpeed);
		break;
	case SOAP_TYPE___ns1__logout:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__logout*>(p->ptr), struct __ns1__logout);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__logout*>(p->ptr), struct __ns1__logout);
		break;
	case SOAP_TYPE___ns1__querySyncTime:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__querySyncTime*>(p->ptr), struct __ns1__querySyncTime);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__querySyncTime*>(p->ptr), struct __ns1__querySyncTime);
		break;
	case SOAP_TYPE___ns1__writeAlarmInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__writeAlarmInfo*>(p->ptr), struct __ns1__writeAlarmInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__writeAlarmInfo*>(p->ptr), struct __ns1__writeAlarmInfo);
		break;
	case SOAP_TYPE___ns1__NWriteVehicleInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__NWriteVehicleInfo*>(p->ptr), struct __ns1__NWriteVehicleInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__NWriteVehicleInfo*>(p->ptr), struct __ns1__NWriteVehicleInfo);
		break;
	case SOAP_TYPE___ns1__NWriteVehicleInfoEx:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__NWriteVehicleInfoEx*>(p->ptr), struct __ns1__NWriteVehicleInfoEx);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__NWriteVehicleInfoEx*>(p->ptr), struct __ns1__NWriteVehicleInfoEx);
		break;
	case SOAP_TYPE___ns1__NSyncWriteVehicleInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__NSyncWriteVehicleInfo*>(p->ptr), struct __ns1__NSyncWriteVehicleInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__NSyncWriteVehicleInfo*>(p->ptr), struct __ns1__NSyncWriteVehicleInfo);
		break;
	case SOAP_TYPE___ns1__WriteFlux:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__WriteFlux*>(p->ptr), struct __ns1__WriteFlux);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__WriteFlux*>(p->ptr), struct __ns1__WriteFlux);
		break;
	case SOAP_TYPE___ns1__NWriteDeviceStatus:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__NWriteDeviceStatus*>(p->ptr), struct __ns1__NWriteDeviceStatus);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__NWriteDeviceStatus*>(p->ptr), struct __ns1__NWriteDeviceStatus);
		break;
	case SOAP_TYPE___ns1__NSyncWriteMobileEPVInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__NSyncWriteMobileEPVInfo*>(p->ptr), struct __ns1__NSyncWriteMobileEPVInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__NSyncWriteMobileEPVInfo*>(p->ptr), struct __ns1__NSyncWriteMobileEPVInfo);
		break;
	case SOAP_TYPE___ns1__NSyncWriteVioInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__NSyncWriteVioInfo*>(p->ptr), struct __ns1__NSyncWriteVioInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__NSyncWriteVioInfo*>(p->ptr), struct __ns1__NSyncWriteVioInfo);
		break;
	case SOAP_TYPE___ns1__NWritePassStat:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__NWritePassStat*>(p->ptr), struct __ns1__NWritePassStat);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__NWritePassStat*>(p->ptr), struct __ns1__NWritePassStat);
		break;
	case SOAP_TYPE___ns1__SyncWriteVehPassInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__SyncWriteVehPassInfo*>(p->ptr), struct __ns1__SyncWriteVehPassInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__SyncWriteVehPassInfo*>(p->ptr), struct __ns1__SyncWriteVehPassInfo);
		break;
	case SOAP_TYPE___ns1__WriteVehPassInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__WriteVehPassInfo*>(p->ptr), struct __ns1__WriteVehPassInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__WriteVehPassInfo*>(p->ptr), struct __ns1__WriteVehPassInfo);
		break;
	case SOAP_TYPE___ns1__SyncWriteAreaSpeed:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__SyncWriteAreaSpeed*>(p->ptr), struct __ns1__SyncWriteAreaSpeed);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__SyncWriteAreaSpeed*>(p->ptr), struct __ns1__SyncWriteAreaSpeed);
		break;
	case SOAP_TYPE___ns1__WriteAreaSpeed:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__WriteAreaSpeed*>(p->ptr), struct __ns1__WriteAreaSpeed);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__WriteAreaSpeed*>(p->ptr), struct __ns1__WriteAreaSpeed);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	(void)t; (void)b; /* appease -Wall -Werror */
	return 0;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_xsd__base64Binary:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__base64Binary type=%d location=%p object=%p\n", t, p, q));
		*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__Exception:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Exception type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Exception*)p = *(ns1__Exception*)q;
		break;
	case SOAP_TYPE_ns1__syncWriteVehicleInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__syncWriteVehicleInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns1__syncWriteVehicleInfo*)p = *(ns1__syncWriteVehicleInfo*)q;
		break;
	case SOAP_TYPE_ns1__syncWriteVehicleInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__syncWriteVehicleInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__syncWriteVehicleInfoResponse*)p = *(ns1__syncWriteVehicleInfoResponse*)q;
		break;
	case SOAP_TYPE_ns1__writeVehicleInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__writeVehicleInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns1__writeVehicleInfo*)p = *(ns1__writeVehicleInfo*)q;
		break;
	case SOAP_TYPE_ns1__writeVehicleInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__writeVehicleInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__writeVehicleInfoResponse*)p = *(ns1__writeVehicleInfoResponse*)q;
		break;
	case SOAP_TYPE_ns1__login:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__login type=%d location=%p object=%p\n", t, p, q));
		*(ns1__login*)p = *(ns1__login*)q;
		break;
	case SOAP_TYPE_ns1__loginResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__loginResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__loginResponse*)p = *(ns1__loginResponse*)q;
		break;
	case SOAP_TYPE_ns1__queryLimitSpeed:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__queryLimitSpeed type=%d location=%p object=%p\n", t, p, q));
		*(ns1__queryLimitSpeed*)p = *(ns1__queryLimitSpeed*)q;
		break;
	case SOAP_TYPE_ns1__queryLimitSpeedResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__queryLimitSpeedResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__queryLimitSpeedResponse*)p = *(ns1__queryLimitSpeedResponse*)q;
		break;
	case SOAP_TYPE_ns1__queryViolateSpeed:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__queryViolateSpeed type=%d location=%p object=%p\n", t, p, q));
		*(ns1__queryViolateSpeed*)p = *(ns1__queryViolateSpeed*)q;
		break;
	case SOAP_TYPE_ns1__queryViolateSpeedResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__queryViolateSpeedResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__queryViolateSpeedResponse*)p = *(ns1__queryViolateSpeedResponse*)q;
		break;
	case SOAP_TYPE_ns1__logout:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__logout type=%d location=%p object=%p\n", t, p, q));
		*(ns1__logout*)p = *(ns1__logout*)q;
		break;
	case SOAP_TYPE_ns1__logoutResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__logoutResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__logoutResponse*)p = *(ns1__logoutResponse*)q;
		break;
	case SOAP_TYPE_ns1__querySyncTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__querySyncTime type=%d location=%p object=%p\n", t, p, q));
		*(ns1__querySyncTime*)p = *(ns1__querySyncTime*)q;
		break;
	case SOAP_TYPE_ns1__querySyncTimeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__querySyncTimeResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__querySyncTimeResponse*)p = *(ns1__querySyncTimeResponse*)q;
		break;
	case SOAP_TYPE_ns1__writeAlarmInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__writeAlarmInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns1__writeAlarmInfo*)p = *(ns1__writeAlarmInfo*)q;
		break;
	case SOAP_TYPE_ns1__writeAlarmInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__writeAlarmInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__writeAlarmInfoResponse*)p = *(ns1__writeAlarmInfoResponse*)q;
		break;
	case SOAP_TYPE_ns1__NWriteVehicleInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__NWriteVehicleInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns1__NWriteVehicleInfo*)p = *(ns1__NWriteVehicleInfo*)q;
		break;
	case SOAP_TYPE_ns1__NWriteVehicleInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__NWriteVehicleInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__NWriteVehicleInfoResponse*)p = *(ns1__NWriteVehicleInfoResponse*)q;
		break;
	case SOAP_TYPE_ns1__NWriteVehicleInfoEx:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__NWriteVehicleInfoEx type=%d location=%p object=%p\n", t, p, q));
		*(ns1__NWriteVehicleInfoEx*)p = *(ns1__NWriteVehicleInfoEx*)q;
		break;
	case SOAP_TYPE_ns1__NWriteVehicleInfoExResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__NWriteVehicleInfoExResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__NWriteVehicleInfoExResponse*)p = *(ns1__NWriteVehicleInfoExResponse*)q;
		break;
	case SOAP_TYPE_ns1__NSyncWriteVehicleInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__NSyncWriteVehicleInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns1__NSyncWriteVehicleInfo*)p = *(ns1__NSyncWriteVehicleInfo*)q;
		break;
	case SOAP_TYPE_ns1__NSyncWriteVehicleInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__NSyncWriteVehicleInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__NSyncWriteVehicleInfoResponse*)p = *(ns1__NSyncWriteVehicleInfoResponse*)q;
		break;
	case SOAP_TYPE_ns1__WriteFlux:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__WriteFlux type=%d location=%p object=%p\n", t, p, q));
		*(ns1__WriteFlux*)p = *(ns1__WriteFlux*)q;
		break;
	case SOAP_TYPE_ns1__WriteFluxResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__WriteFluxResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__WriteFluxResponse*)p = *(ns1__WriteFluxResponse*)q;
		break;
	case SOAP_TYPE_ns1__NWriteDeviceStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__NWriteDeviceStatus type=%d location=%p object=%p\n", t, p, q));
		*(ns1__NWriteDeviceStatus*)p = *(ns1__NWriteDeviceStatus*)q;
		break;
	case SOAP_TYPE_ns1__NWriteDeviceStatusResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__NWriteDeviceStatusResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__NWriteDeviceStatusResponse*)p = *(ns1__NWriteDeviceStatusResponse*)q;
		break;
	case SOAP_TYPE_ns1__NSyncWriteMobileEPVInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__NSyncWriteMobileEPVInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns1__NSyncWriteMobileEPVInfo*)p = *(ns1__NSyncWriteMobileEPVInfo*)q;
		break;
	case SOAP_TYPE_ns1__NSyncWriteMobileEPVInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__NSyncWriteMobileEPVInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__NSyncWriteMobileEPVInfoResponse*)p = *(ns1__NSyncWriteMobileEPVInfoResponse*)q;
		break;
	case SOAP_TYPE_ns1__NSyncWriteVioInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__NSyncWriteVioInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns1__NSyncWriteVioInfo*)p = *(ns1__NSyncWriteVioInfo*)q;
		break;
	case SOAP_TYPE_ns1__NSyncWriteVioInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__NSyncWriteVioInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__NSyncWriteVioInfoResponse*)p = *(ns1__NSyncWriteVioInfoResponse*)q;
		break;
	case SOAP_TYPE_ns1__NWritePassStat:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__NWritePassStat type=%d location=%p object=%p\n", t, p, q));
		*(ns1__NWritePassStat*)p = *(ns1__NWritePassStat*)q;
		break;
	case SOAP_TYPE_ns1__NWritePassStatResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__NWritePassStatResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__NWritePassStatResponse*)p = *(ns1__NWritePassStatResponse*)q;
		break;
	case SOAP_TYPE_ns1__SyncWriteVehPassInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SyncWriteVehPassInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SyncWriteVehPassInfo*)p = *(ns1__SyncWriteVehPassInfo*)q;
		break;
	case SOAP_TYPE_ns1__SyncWriteVehPassInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SyncWriteVehPassInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SyncWriteVehPassInfoResponse*)p = *(ns1__SyncWriteVehPassInfoResponse*)q;
		break;
	case SOAP_TYPE_ns1__WriteVehPassInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__WriteVehPassInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns1__WriteVehPassInfo*)p = *(ns1__WriteVehPassInfo*)q;
		break;
	case SOAP_TYPE_ns1__WriteVehPassInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__WriteVehPassInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__WriteVehPassInfoResponse*)p = *(ns1__WriteVehPassInfoResponse*)q;
		break;
	case SOAP_TYPE_ns1__SyncWriteAreaSpeed:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SyncWriteAreaSpeed type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SyncWriteAreaSpeed*)p = *(ns1__SyncWriteAreaSpeed*)q;
		break;
	case SOAP_TYPE_ns1__SyncWriteAreaSpeedResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SyncWriteAreaSpeedResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SyncWriteAreaSpeedResponse*)p = *(ns1__SyncWriteAreaSpeedResponse*)q;
		break;
	case SOAP_TYPE_ns1__WriteAreaSpeed:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__WriteAreaSpeed type=%d location=%p object=%p\n", t, p, q));
		*(ns1__WriteAreaSpeed*)p = *(ns1__WriteAreaSpeed*)q;
		break;
	case SOAP_TYPE_ns1__WriteAreaSpeedResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__WriteAreaSpeedResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns1__WriteAreaSpeedResponse*)p = *(ns1__WriteAreaSpeedResponse*)q;
		break;
	case SOAP_TYPE___ns1__syncWriteVehicleInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__syncWriteVehicleInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__syncWriteVehicleInfo*)p = *(struct __ns1__syncWriteVehicleInfo*)q;
		break;
	case SOAP_TYPE___ns1__writeVehicleInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__writeVehicleInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__writeVehicleInfo*)p = *(struct __ns1__writeVehicleInfo*)q;
		break;
	case SOAP_TYPE___ns1__login:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__login type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__login*)p = *(struct __ns1__login*)q;
		break;
	case SOAP_TYPE___ns1__queryLimitSpeed:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__queryLimitSpeed type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__queryLimitSpeed*)p = *(struct __ns1__queryLimitSpeed*)q;
		break;
	case SOAP_TYPE___ns1__queryViolateSpeed:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__queryViolateSpeed type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__queryViolateSpeed*)p = *(struct __ns1__queryViolateSpeed*)q;
		break;
	case SOAP_TYPE___ns1__logout:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__logout type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__logout*)p = *(struct __ns1__logout*)q;
		break;
	case SOAP_TYPE___ns1__querySyncTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__querySyncTime type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__querySyncTime*)p = *(struct __ns1__querySyncTime*)q;
		break;
	case SOAP_TYPE___ns1__writeAlarmInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__writeAlarmInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__writeAlarmInfo*)p = *(struct __ns1__writeAlarmInfo*)q;
		break;
	case SOAP_TYPE___ns1__NWriteVehicleInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__NWriteVehicleInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__NWriteVehicleInfo*)p = *(struct __ns1__NWriteVehicleInfo*)q;
		break;
	case SOAP_TYPE___ns1__NWriteVehicleInfoEx:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__NWriteVehicleInfoEx type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__NWriteVehicleInfoEx*)p = *(struct __ns1__NWriteVehicleInfoEx*)q;
		break;
	case SOAP_TYPE___ns1__NSyncWriteVehicleInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__NSyncWriteVehicleInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__NSyncWriteVehicleInfo*)p = *(struct __ns1__NSyncWriteVehicleInfo*)q;
		break;
	case SOAP_TYPE___ns1__WriteFlux:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__WriteFlux type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__WriteFlux*)p = *(struct __ns1__WriteFlux*)q;
		break;
	case SOAP_TYPE___ns1__NWriteDeviceStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__NWriteDeviceStatus type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__NWriteDeviceStatus*)p = *(struct __ns1__NWriteDeviceStatus*)q;
		break;
	case SOAP_TYPE___ns1__NSyncWriteMobileEPVInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__NSyncWriteMobileEPVInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__NSyncWriteMobileEPVInfo*)p = *(struct __ns1__NSyncWriteMobileEPVInfo*)q;
		break;
	case SOAP_TYPE___ns1__NSyncWriteVioInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__NSyncWriteVioInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__NSyncWriteVioInfo*)p = *(struct __ns1__NSyncWriteVioInfo*)q;
		break;
	case SOAP_TYPE___ns1__NWritePassStat:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__NWritePassStat type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__NWritePassStat*)p = *(struct __ns1__NWritePassStat*)q;
		break;
	case SOAP_TYPE___ns1__SyncWriteVehPassInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SyncWriteVehPassInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SyncWriteVehPassInfo*)p = *(struct __ns1__SyncWriteVehPassInfo*)q;
		break;
	case SOAP_TYPE___ns1__WriteVehPassInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__WriteVehPassInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__WriteVehPassInfo*)p = *(struct __ns1__WriteVehPassInfo*)q;
		break;
	case SOAP_TYPE___ns1__SyncWriteAreaSpeed:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SyncWriteAreaSpeed type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SyncWriteAreaSpeed*)p = *(struct __ns1__SyncWriteAreaSpeed*)q;
		break;
	case SOAP_TYPE___ns1__WriteAreaSpeed:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__WriteAreaSpeed type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__WriteAreaSpeed*)p = *(struct __ns1__WriteAreaSpeed*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	a = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return a;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_new_LONG64(struct soap *soap, int n)
{
	LONG64 *a = static_cast<LONG64 *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(LONG64)));
	for (LONG64 *p = a; p && n--; ++p)
		soap_default_LONG64(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	if (soap_out_LONG64(soap, tag ? tag : "long", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	a = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return a;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_new_unsignedByte(struct soap *soap, int n)
{
	unsigned char *a = static_cast<unsigned char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned char)));
	for (unsigned char *p = a; p && n--; ++p)
		soap_default_unsignedByte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	if (soap_out_unsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	a = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return a;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_new_unsignedInt(struct soap *soap, int n)
{
	unsigned int *a = static_cast<unsigned int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned int)));
	for (unsigned int *p = a; p && n--; ++p)
		soap_default_unsignedInt(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out_unsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__WriteAreaSpeedResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__WriteAreaSpeedResponse::return_ = NULL;
}

void ns1__WriteAreaSpeedResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__WriteAreaSpeedResponse::return_);
#endif
}

int ns1__WriteAreaSpeedResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__WriteAreaSpeedResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__WriteAreaSpeedResponse(struct soap *soap, const char *tag, int id, const ns1__WriteAreaSpeedResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__WriteAreaSpeedResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->ns1__WriteAreaSpeedResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__WriteAreaSpeedResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__WriteAreaSpeedResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__WriteAreaSpeedResponse * SOAP_FMAC4 soap_in_ns1__WriteAreaSpeedResponse(struct soap *soap, const char *tag, ns1__WriteAreaSpeedResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__WriteAreaSpeedResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__WriteAreaSpeedResponse, sizeof(ns1__WriteAreaSpeedResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__WriteAreaSpeedResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__WriteAreaSpeedResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->ns1__WriteAreaSpeedResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__WriteAreaSpeedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__WriteAreaSpeedResponse, SOAP_TYPE_ns1__WriteAreaSpeedResponse, sizeof(ns1__WriteAreaSpeedResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__WriteAreaSpeedResponse * SOAP_FMAC2 soap_instantiate_ns1__WriteAreaSpeedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__WriteAreaSpeedResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__WriteAreaSpeedResponse *p;
	size_t k = sizeof(ns1__WriteAreaSpeedResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__WriteAreaSpeedResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__WriteAreaSpeedResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__WriteAreaSpeedResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__WriteAreaSpeedResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__WriteAreaSpeedResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__WriteAreaSpeedResponse(soap, tag ? tag : "ns1:WriteAreaSpeedResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__WriteAreaSpeedResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__WriteAreaSpeedResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__WriteAreaSpeedResponse * SOAP_FMAC4 soap_get_ns1__WriteAreaSpeedResponse(struct soap *soap, ns1__WriteAreaSpeedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__WriteAreaSpeedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__WriteAreaSpeed::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__WriteAreaSpeed::sid);
	soap_default_std__string(soap, &this->ns1__WriteAreaSpeed::xmlParam);
}

void ns1__WriteAreaSpeed::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__WriteAreaSpeed::sid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__WriteAreaSpeed::sid);
	soap_embedded(soap, &this->ns1__WriteAreaSpeed::xmlParam, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__WriteAreaSpeed::xmlParam);
#endif
}

int ns1__WriteAreaSpeed::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__WriteAreaSpeed(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__WriteAreaSpeed(struct soap *soap, const char *tag, int id, const ns1__WriteAreaSpeed *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__WriteAreaSpeed), type))
		return soap->error;
	if (soap_out_std__string(soap, "sid", -1, &a->ns1__WriteAreaSpeed::sid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "xmlParam", -1, &a->ns1__WriteAreaSpeed::xmlParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__WriteAreaSpeed::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__WriteAreaSpeed(soap, tag, this, type);
}

SOAP_FMAC3 ns1__WriteAreaSpeed * SOAP_FMAC4 soap_in_ns1__WriteAreaSpeed(struct soap *soap, const char *tag, ns1__WriteAreaSpeed *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__WriteAreaSpeed*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__WriteAreaSpeed, sizeof(ns1__WriteAreaSpeed), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__WriteAreaSpeed)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__WriteAreaSpeed *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sid1 = 1;
	size_t soap_flag_xmlParam1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sid", &a->ns1__WriteAreaSpeed::sid, "xsd:string"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap_flag_xmlParam1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "xmlParam", &a->ns1__WriteAreaSpeed::xmlParam, "xsd:string"))
				{	soap_flag_xmlParam1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid1 > 0 || soap_flag_xmlParam1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__WriteAreaSpeed *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__WriteAreaSpeed, SOAP_TYPE_ns1__WriteAreaSpeed, sizeof(ns1__WriteAreaSpeed), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__WriteAreaSpeed * SOAP_FMAC2 soap_instantiate_ns1__WriteAreaSpeed(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__WriteAreaSpeed(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__WriteAreaSpeed *p;
	size_t k = sizeof(ns1__WriteAreaSpeed);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__WriteAreaSpeed, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__WriteAreaSpeed);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__WriteAreaSpeed, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__WriteAreaSpeed location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__WriteAreaSpeed::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__WriteAreaSpeed(soap, tag ? tag : "ns1:WriteAreaSpeed", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__WriteAreaSpeed::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__WriteAreaSpeed(soap, this, tag, type);
}

SOAP_FMAC3 ns1__WriteAreaSpeed * SOAP_FMAC4 soap_get_ns1__WriteAreaSpeed(struct soap *soap, ns1__WriteAreaSpeed *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__WriteAreaSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SyncWriteAreaSpeedResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SyncWriteAreaSpeedResponse::return_ = NULL;
}

void ns1__SyncWriteAreaSpeedResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__SyncWriteAreaSpeedResponse::return_);
#endif
}

int ns1__SyncWriteAreaSpeedResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SyncWriteAreaSpeedResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SyncWriteAreaSpeedResponse(struct soap *soap, const char *tag, int id, const ns1__SyncWriteAreaSpeedResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SyncWriteAreaSpeedResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->ns1__SyncWriteAreaSpeedResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SyncWriteAreaSpeedResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SyncWriteAreaSpeedResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SyncWriteAreaSpeedResponse * SOAP_FMAC4 soap_in_ns1__SyncWriteAreaSpeedResponse(struct soap *soap, const char *tag, ns1__SyncWriteAreaSpeedResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SyncWriteAreaSpeedResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SyncWriteAreaSpeedResponse, sizeof(ns1__SyncWriteAreaSpeedResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SyncWriteAreaSpeedResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SyncWriteAreaSpeedResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->ns1__SyncWriteAreaSpeedResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SyncWriteAreaSpeedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SyncWriteAreaSpeedResponse, SOAP_TYPE_ns1__SyncWriteAreaSpeedResponse, sizeof(ns1__SyncWriteAreaSpeedResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SyncWriteAreaSpeedResponse * SOAP_FMAC2 soap_instantiate_ns1__SyncWriteAreaSpeedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SyncWriteAreaSpeedResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SyncWriteAreaSpeedResponse *p;
	size_t k = sizeof(ns1__SyncWriteAreaSpeedResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SyncWriteAreaSpeedResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SyncWriteAreaSpeedResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SyncWriteAreaSpeedResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SyncWriteAreaSpeedResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SyncWriteAreaSpeedResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SyncWriteAreaSpeedResponse(soap, tag ? tag : "ns1:SyncWriteAreaSpeedResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SyncWriteAreaSpeedResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SyncWriteAreaSpeedResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SyncWriteAreaSpeedResponse * SOAP_FMAC4 soap_get_ns1__SyncWriteAreaSpeedResponse(struct soap *soap, ns1__SyncWriteAreaSpeedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SyncWriteAreaSpeedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SyncWriteAreaSpeed::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__SyncWriteAreaSpeed::sid);
	soap_default_std__string(soap, &this->ns1__SyncWriteAreaSpeed::xmlParam);
	this->ns1__SyncWriteAreaSpeed::pic1.xsd__base64Binary::soap_default(soap);
	this->ns1__SyncWriteAreaSpeed::pic2.xsd__base64Binary::soap_default(soap);
	this->ns1__SyncWriteAreaSpeed::pic3.xsd__base64Binary::soap_default(soap);
	this->ns1__SyncWriteAreaSpeed::pic4.xsd__base64Binary::soap_default(soap);
	this->ns1__SyncWriteAreaSpeed::pic5.xsd__base64Binary::soap_default(soap);
	this->ns1__SyncWriteAreaSpeed::pic6.xsd__base64Binary::soap_default(soap);
	this->ns1__SyncWriteAreaSpeed::video.xsd__base64Binary::soap_default(soap);
}

void ns1__SyncWriteAreaSpeed::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__SyncWriteAreaSpeed::sid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SyncWriteAreaSpeed::sid);
	soap_embedded(soap, &this->ns1__SyncWriteAreaSpeed::xmlParam, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SyncWriteAreaSpeed::xmlParam);
	this->ns1__SyncWriteAreaSpeed::pic1.soap_serialize(soap);
	this->ns1__SyncWriteAreaSpeed::pic2.soap_serialize(soap);
	this->ns1__SyncWriteAreaSpeed::pic3.soap_serialize(soap);
	this->ns1__SyncWriteAreaSpeed::pic4.soap_serialize(soap);
	this->ns1__SyncWriteAreaSpeed::pic5.soap_serialize(soap);
	this->ns1__SyncWriteAreaSpeed::pic6.soap_serialize(soap);
	this->ns1__SyncWriteAreaSpeed::video.soap_serialize(soap);
#endif
}

int ns1__SyncWriteAreaSpeed::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SyncWriteAreaSpeed(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SyncWriteAreaSpeed(struct soap *soap, const char *tag, int id, const ns1__SyncWriteAreaSpeed *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SyncWriteAreaSpeed), type))
		return soap->error;
	if (soap_out_std__string(soap, "sid", -1, &a->ns1__SyncWriteAreaSpeed::sid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "xmlParam", -1, &a->ns1__SyncWriteAreaSpeed::xmlParam, ""))
		return soap->error;
	if ((a->ns1__SyncWriteAreaSpeed::pic1).soap_out(soap, "pic1", -1, ""))
		return soap->error;
	if ((a->ns1__SyncWriteAreaSpeed::pic2).soap_out(soap, "pic2", -1, ""))
		return soap->error;
	if ((a->ns1__SyncWriteAreaSpeed::pic3).soap_out(soap, "pic3", -1, ""))
		return soap->error;
	if ((a->ns1__SyncWriteAreaSpeed::pic4).soap_out(soap, "pic4", -1, ""))
		return soap->error;
	if ((a->ns1__SyncWriteAreaSpeed::pic5).soap_out(soap, "pic5", -1, ""))
		return soap->error;
	if ((a->ns1__SyncWriteAreaSpeed::pic6).soap_out(soap, "pic6", -1, ""))
		return soap->error;
	if ((a->ns1__SyncWriteAreaSpeed::video).soap_out(soap, "video", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SyncWriteAreaSpeed::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SyncWriteAreaSpeed(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SyncWriteAreaSpeed * SOAP_FMAC4 soap_in_ns1__SyncWriteAreaSpeed(struct soap *soap, const char *tag, ns1__SyncWriteAreaSpeed *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SyncWriteAreaSpeed*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SyncWriteAreaSpeed, sizeof(ns1__SyncWriteAreaSpeed), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SyncWriteAreaSpeed)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SyncWriteAreaSpeed *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sid1 = 1;
	size_t soap_flag_xmlParam1 = 1;
	size_t soap_flag_pic11 = 1;
	size_t soap_flag_pic21 = 1;
	size_t soap_flag_pic31 = 1;
	size_t soap_flag_pic41 = 1;
	size_t soap_flag_pic51 = 1;
	size_t soap_flag_pic61 = 1;
	size_t soap_flag_video1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sid", &a->ns1__SyncWriteAreaSpeed::sid, "xsd:string"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap_flag_xmlParam1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "xmlParam", &a->ns1__SyncWriteAreaSpeed::xmlParam, "xsd:string"))
				{	soap_flag_xmlParam1--;
					continue;
				}
			}
			if (soap_flag_pic11 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__SyncWriteAreaSpeed::pic1).soap_in(soap, "pic1", "xsd:base64Binary"))
				{	soap_flag_pic11--;
					continue;
				}
			}
			if (soap_flag_pic21 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__SyncWriteAreaSpeed::pic2).soap_in(soap, "pic2", "xsd:base64Binary"))
				{	soap_flag_pic21--;
					continue;
				}
			}
			if (soap_flag_pic31 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__SyncWriteAreaSpeed::pic3).soap_in(soap, "pic3", "xsd:base64Binary"))
				{	soap_flag_pic31--;
					continue;
				}
			}
			if (soap_flag_pic41 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__SyncWriteAreaSpeed::pic4).soap_in(soap, "pic4", "xsd:base64Binary"))
				{	soap_flag_pic41--;
					continue;
				}
			}
			if (soap_flag_pic51 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__SyncWriteAreaSpeed::pic5).soap_in(soap, "pic5", "xsd:base64Binary"))
				{	soap_flag_pic51--;
					continue;
				}
			}
			if (soap_flag_pic61 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__SyncWriteAreaSpeed::pic6).soap_in(soap, "pic6", "xsd:base64Binary"))
				{	soap_flag_pic61--;
					continue;
				}
			}
			if (soap_flag_video1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__SyncWriteAreaSpeed::video).soap_in(soap, "video", "xsd:base64Binary"))
				{	soap_flag_video1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid1 > 0 || soap_flag_xmlParam1 > 0 || soap_flag_pic11 > 0 || soap_flag_pic21 > 0 || soap_flag_pic31 > 0 || soap_flag_pic41 > 0 || soap_flag_pic51 > 0 || soap_flag_pic61 > 0 || soap_flag_video1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SyncWriteAreaSpeed *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SyncWriteAreaSpeed, SOAP_TYPE_ns1__SyncWriteAreaSpeed, sizeof(ns1__SyncWriteAreaSpeed), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SyncWriteAreaSpeed * SOAP_FMAC2 soap_instantiate_ns1__SyncWriteAreaSpeed(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SyncWriteAreaSpeed(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SyncWriteAreaSpeed *p;
	size_t k = sizeof(ns1__SyncWriteAreaSpeed);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SyncWriteAreaSpeed, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SyncWriteAreaSpeed);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SyncWriteAreaSpeed, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SyncWriteAreaSpeed location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SyncWriteAreaSpeed::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SyncWriteAreaSpeed(soap, tag ? tag : "ns1:SyncWriteAreaSpeed", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SyncWriteAreaSpeed::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SyncWriteAreaSpeed(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SyncWriteAreaSpeed * SOAP_FMAC4 soap_get_ns1__SyncWriteAreaSpeed(struct soap *soap, ns1__SyncWriteAreaSpeed *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SyncWriteAreaSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__WriteVehPassInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__WriteVehPassInfoResponse::return_ = NULL;
}

void ns1__WriteVehPassInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__WriteVehPassInfoResponse::return_);
#endif
}

int ns1__WriteVehPassInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__WriteVehPassInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__WriteVehPassInfoResponse(struct soap *soap, const char *tag, int id, const ns1__WriteVehPassInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__WriteVehPassInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->ns1__WriteVehPassInfoResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__WriteVehPassInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__WriteVehPassInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__WriteVehPassInfoResponse * SOAP_FMAC4 soap_in_ns1__WriteVehPassInfoResponse(struct soap *soap, const char *tag, ns1__WriteVehPassInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__WriteVehPassInfoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__WriteVehPassInfoResponse, sizeof(ns1__WriteVehPassInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__WriteVehPassInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__WriteVehPassInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->ns1__WriteVehPassInfoResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__WriteVehPassInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__WriteVehPassInfoResponse, SOAP_TYPE_ns1__WriteVehPassInfoResponse, sizeof(ns1__WriteVehPassInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__WriteVehPassInfoResponse * SOAP_FMAC2 soap_instantiate_ns1__WriteVehPassInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__WriteVehPassInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__WriteVehPassInfoResponse *p;
	size_t k = sizeof(ns1__WriteVehPassInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__WriteVehPassInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__WriteVehPassInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__WriteVehPassInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__WriteVehPassInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__WriteVehPassInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__WriteVehPassInfoResponse(soap, tag ? tag : "ns1:WriteVehPassInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__WriteVehPassInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__WriteVehPassInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__WriteVehPassInfoResponse * SOAP_FMAC4 soap_get_ns1__WriteVehPassInfoResponse(struct soap *soap, ns1__WriteVehPassInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__WriteVehPassInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__WriteVehPassInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__WriteVehPassInfo::sid);
	soap_default_std__string(soap, &this->ns1__WriteVehPassInfo::xmlParam);
}

void ns1__WriteVehPassInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__WriteVehPassInfo::sid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__WriteVehPassInfo::sid);
	soap_embedded(soap, &this->ns1__WriteVehPassInfo::xmlParam, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__WriteVehPassInfo::xmlParam);
#endif
}

int ns1__WriteVehPassInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__WriteVehPassInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__WriteVehPassInfo(struct soap *soap, const char *tag, int id, const ns1__WriteVehPassInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__WriteVehPassInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "sid", -1, &a->ns1__WriteVehPassInfo::sid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "xmlParam", -1, &a->ns1__WriteVehPassInfo::xmlParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__WriteVehPassInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__WriteVehPassInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__WriteVehPassInfo * SOAP_FMAC4 soap_in_ns1__WriteVehPassInfo(struct soap *soap, const char *tag, ns1__WriteVehPassInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__WriteVehPassInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__WriteVehPassInfo, sizeof(ns1__WriteVehPassInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__WriteVehPassInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__WriteVehPassInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sid1 = 1;
	size_t soap_flag_xmlParam1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sid", &a->ns1__WriteVehPassInfo::sid, "xsd:string"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap_flag_xmlParam1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "xmlParam", &a->ns1__WriteVehPassInfo::xmlParam, "xsd:string"))
				{	soap_flag_xmlParam1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid1 > 0 || soap_flag_xmlParam1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__WriteVehPassInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__WriteVehPassInfo, SOAP_TYPE_ns1__WriteVehPassInfo, sizeof(ns1__WriteVehPassInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__WriteVehPassInfo * SOAP_FMAC2 soap_instantiate_ns1__WriteVehPassInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__WriteVehPassInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__WriteVehPassInfo *p;
	size_t k = sizeof(ns1__WriteVehPassInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__WriteVehPassInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__WriteVehPassInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__WriteVehPassInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__WriteVehPassInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__WriteVehPassInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__WriteVehPassInfo(soap, tag ? tag : "ns1:WriteVehPassInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__WriteVehPassInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__WriteVehPassInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__WriteVehPassInfo * SOAP_FMAC4 soap_get_ns1__WriteVehPassInfo(struct soap *soap, ns1__WriteVehPassInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__WriteVehPassInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SyncWriteVehPassInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SyncWriteVehPassInfoResponse::return_ = NULL;
}

void ns1__SyncWriteVehPassInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__SyncWriteVehPassInfoResponse::return_);
#endif
}

int ns1__SyncWriteVehPassInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SyncWriteVehPassInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SyncWriteVehPassInfoResponse(struct soap *soap, const char *tag, int id, const ns1__SyncWriteVehPassInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SyncWriteVehPassInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->ns1__SyncWriteVehPassInfoResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SyncWriteVehPassInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SyncWriteVehPassInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SyncWriteVehPassInfoResponse * SOAP_FMAC4 soap_in_ns1__SyncWriteVehPassInfoResponse(struct soap *soap, const char *tag, ns1__SyncWriteVehPassInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SyncWriteVehPassInfoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SyncWriteVehPassInfoResponse, sizeof(ns1__SyncWriteVehPassInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SyncWriteVehPassInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SyncWriteVehPassInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->ns1__SyncWriteVehPassInfoResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SyncWriteVehPassInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SyncWriteVehPassInfoResponse, SOAP_TYPE_ns1__SyncWriteVehPassInfoResponse, sizeof(ns1__SyncWriteVehPassInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SyncWriteVehPassInfoResponse * SOAP_FMAC2 soap_instantiate_ns1__SyncWriteVehPassInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SyncWriteVehPassInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SyncWriteVehPassInfoResponse *p;
	size_t k = sizeof(ns1__SyncWriteVehPassInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SyncWriteVehPassInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SyncWriteVehPassInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SyncWriteVehPassInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SyncWriteVehPassInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SyncWriteVehPassInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SyncWriteVehPassInfoResponse(soap, tag ? tag : "ns1:SyncWriteVehPassInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SyncWriteVehPassInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SyncWriteVehPassInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SyncWriteVehPassInfoResponse * SOAP_FMAC4 soap_get_ns1__SyncWriteVehPassInfoResponse(struct soap *soap, ns1__SyncWriteVehPassInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SyncWriteVehPassInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SyncWriteVehPassInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__SyncWriteVehPassInfo::sid);
	soap_default_std__string(soap, &this->ns1__SyncWriteVehPassInfo::xmlParam);
	this->ns1__SyncWriteVehPassInfo::pic1.xsd__base64Binary::soap_default(soap);
	this->ns1__SyncWriteVehPassInfo::pic2.xsd__base64Binary::soap_default(soap);
	this->ns1__SyncWriteVehPassInfo::pic3.xsd__base64Binary::soap_default(soap);
	this->ns1__SyncWriteVehPassInfo::pic4.xsd__base64Binary::soap_default(soap);
	this->ns1__SyncWriteVehPassInfo::pic5.xsd__base64Binary::soap_default(soap);
	this->ns1__SyncWriteVehPassInfo::pic6.xsd__base64Binary::soap_default(soap);
	this->ns1__SyncWriteVehPassInfo::video.xsd__base64Binary::soap_default(soap);
}

void ns1__SyncWriteVehPassInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__SyncWriteVehPassInfo::sid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SyncWriteVehPassInfo::sid);
	soap_embedded(soap, &this->ns1__SyncWriteVehPassInfo::xmlParam, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SyncWriteVehPassInfo::xmlParam);
	this->ns1__SyncWriteVehPassInfo::pic1.soap_serialize(soap);
	this->ns1__SyncWriteVehPassInfo::pic2.soap_serialize(soap);
	this->ns1__SyncWriteVehPassInfo::pic3.soap_serialize(soap);
	this->ns1__SyncWriteVehPassInfo::pic4.soap_serialize(soap);
	this->ns1__SyncWriteVehPassInfo::pic5.soap_serialize(soap);
	this->ns1__SyncWriteVehPassInfo::pic6.soap_serialize(soap);
	this->ns1__SyncWriteVehPassInfo::video.soap_serialize(soap);
#endif
}

int ns1__SyncWriteVehPassInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SyncWriteVehPassInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SyncWriteVehPassInfo(struct soap *soap, const char *tag, int id, const ns1__SyncWriteVehPassInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SyncWriteVehPassInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "sid", -1, &a->ns1__SyncWriteVehPassInfo::sid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "xmlParam", -1, &a->ns1__SyncWriteVehPassInfo::xmlParam, ""))
		return soap->error;
	if ((a->ns1__SyncWriteVehPassInfo::pic1).soap_out(soap, "pic1", -1, ""))
		return soap->error;
	if ((a->ns1__SyncWriteVehPassInfo::pic2).soap_out(soap, "pic2", -1, ""))
		return soap->error;
	if ((a->ns1__SyncWriteVehPassInfo::pic3).soap_out(soap, "pic3", -1, ""))
		return soap->error;
	if ((a->ns1__SyncWriteVehPassInfo::pic4).soap_out(soap, "pic4", -1, ""))
		return soap->error;
	if ((a->ns1__SyncWriteVehPassInfo::pic5).soap_out(soap, "pic5", -1, ""))
		return soap->error;
	if ((a->ns1__SyncWriteVehPassInfo::pic6).soap_out(soap, "pic6", -1, ""))
		return soap->error;
	if ((a->ns1__SyncWriteVehPassInfo::video).soap_out(soap, "video", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SyncWriteVehPassInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__SyncWriteVehPassInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SyncWriteVehPassInfo * SOAP_FMAC4 soap_in_ns1__SyncWriteVehPassInfo(struct soap *soap, const char *tag, ns1__SyncWriteVehPassInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SyncWriteVehPassInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SyncWriteVehPassInfo, sizeof(ns1__SyncWriteVehPassInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SyncWriteVehPassInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SyncWriteVehPassInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sid1 = 1;
	size_t soap_flag_xmlParam1 = 1;
	size_t soap_flag_pic11 = 1;
	size_t soap_flag_pic21 = 1;
	size_t soap_flag_pic31 = 1;
	size_t soap_flag_pic41 = 1;
	size_t soap_flag_pic51 = 1;
	size_t soap_flag_pic61 = 1;
	size_t soap_flag_video1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sid", &a->ns1__SyncWriteVehPassInfo::sid, "xsd:string"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap_flag_xmlParam1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "xmlParam", &a->ns1__SyncWriteVehPassInfo::xmlParam, "xsd:string"))
				{	soap_flag_xmlParam1--;
					continue;
				}
			}
			if (soap_flag_pic11 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__SyncWriteVehPassInfo::pic1).soap_in(soap, "pic1", "xsd:base64Binary"))
				{	soap_flag_pic11--;
					continue;
				}
			}
			if (soap_flag_pic21 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__SyncWriteVehPassInfo::pic2).soap_in(soap, "pic2", "xsd:base64Binary"))
				{	soap_flag_pic21--;
					continue;
				}
			}
			if (soap_flag_pic31 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__SyncWriteVehPassInfo::pic3).soap_in(soap, "pic3", "xsd:base64Binary"))
				{	soap_flag_pic31--;
					continue;
				}
			}
			if (soap_flag_pic41 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__SyncWriteVehPassInfo::pic4).soap_in(soap, "pic4", "xsd:base64Binary"))
				{	soap_flag_pic41--;
					continue;
				}
			}
			if (soap_flag_pic51 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__SyncWriteVehPassInfo::pic5).soap_in(soap, "pic5", "xsd:base64Binary"))
				{	soap_flag_pic51--;
					continue;
				}
			}
			if (soap_flag_pic61 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__SyncWriteVehPassInfo::pic6).soap_in(soap, "pic6", "xsd:base64Binary"))
				{	soap_flag_pic61--;
					continue;
				}
			}
			if (soap_flag_video1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__SyncWriteVehPassInfo::video).soap_in(soap, "video", "xsd:base64Binary"))
				{	soap_flag_video1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid1 > 0 || soap_flag_xmlParam1 > 0 || soap_flag_pic11 > 0 || soap_flag_pic21 > 0 || soap_flag_pic31 > 0 || soap_flag_pic41 > 0 || soap_flag_pic51 > 0 || soap_flag_pic61 > 0 || soap_flag_video1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SyncWriteVehPassInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SyncWriteVehPassInfo, SOAP_TYPE_ns1__SyncWriteVehPassInfo, sizeof(ns1__SyncWriteVehPassInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SyncWriteVehPassInfo * SOAP_FMAC2 soap_instantiate_ns1__SyncWriteVehPassInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SyncWriteVehPassInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SyncWriteVehPassInfo *p;
	size_t k = sizeof(ns1__SyncWriteVehPassInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SyncWriteVehPassInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SyncWriteVehPassInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SyncWriteVehPassInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SyncWriteVehPassInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SyncWriteVehPassInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SyncWriteVehPassInfo(soap, tag ? tag : "ns1:SyncWriteVehPassInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SyncWriteVehPassInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SyncWriteVehPassInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SyncWriteVehPassInfo * SOAP_FMAC4 soap_get_ns1__SyncWriteVehPassInfo(struct soap *soap, ns1__SyncWriteVehPassInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SyncWriteVehPassInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__NWritePassStatResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__NWritePassStatResponse::return_ = NULL;
}

void ns1__NWritePassStatResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__NWritePassStatResponse::return_);
#endif
}

int ns1__NWritePassStatResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NWritePassStatResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NWritePassStatResponse(struct soap *soap, const char *tag, int id, const ns1__NWritePassStatResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NWritePassStatResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->ns1__NWritePassStatResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__NWritePassStatResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__NWritePassStatResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NWritePassStatResponse * SOAP_FMAC4 soap_in_ns1__NWritePassStatResponse(struct soap *soap, const char *tag, ns1__NWritePassStatResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NWritePassStatResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NWritePassStatResponse, sizeof(ns1__NWritePassStatResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__NWritePassStatResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__NWritePassStatResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->ns1__NWritePassStatResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__NWritePassStatResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NWritePassStatResponse, SOAP_TYPE_ns1__NWritePassStatResponse, sizeof(ns1__NWritePassStatResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__NWritePassStatResponse * SOAP_FMAC2 soap_instantiate_ns1__NWritePassStatResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NWritePassStatResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__NWritePassStatResponse *p;
	size_t k = sizeof(ns1__NWritePassStatResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__NWritePassStatResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__NWritePassStatResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__NWritePassStatResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__NWritePassStatResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__NWritePassStatResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__NWritePassStatResponse(soap, tag ? tag : "ns1:NWritePassStatResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NWritePassStatResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NWritePassStatResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NWritePassStatResponse * SOAP_FMAC4 soap_get_ns1__NWritePassStatResponse(struct soap *soap, ns1__NWritePassStatResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NWritePassStatResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__NWritePassStat::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__NWritePassStat::sid);
	soap_default_std__string(soap, &this->ns1__NWritePassStat::strDeviceId);
	soap_default_std__string(soap, &this->ns1__NWritePassStat::strDeviceType);
	soap_default_std__string(soap, &this->ns1__NWritePassStat::strDirectionId);
	soap_default_std__string(soap, &this->ns1__NWritePassStat::strDriveWayId);
	soap_default_std__string(soap, &this->ns1__NWritePassStat::strPassStatTime);
	soap_default_LONG64(soap, &this->ns1__NWritePassStat::lPassCount);
	soap_default_LONG64(soap, &this->ns1__NWritePassStat::lSuccessCount);
	soap_default_LONG64(soap, &this->ns1__NWritePassStat::lTimelyCount);
	soap_default_std__string(soap, &this->ns1__NWritePassStat::strReserve1);
	soap_default_std__string(soap, &this->ns1__NWritePassStat::strReserve2);
	soap_default_std__string(soap, &this->ns1__NWritePassStat::strReserve3);
}

void ns1__NWritePassStat::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__NWritePassStat::sid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWritePassStat::sid);
	soap_embedded(soap, &this->ns1__NWritePassStat::strDeviceId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWritePassStat::strDeviceId);
	soap_embedded(soap, &this->ns1__NWritePassStat::strDeviceType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWritePassStat::strDeviceType);
	soap_embedded(soap, &this->ns1__NWritePassStat::strDirectionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWritePassStat::strDirectionId);
	soap_embedded(soap, &this->ns1__NWritePassStat::strDriveWayId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWritePassStat::strDriveWayId);
	soap_embedded(soap, &this->ns1__NWritePassStat::strPassStatTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWritePassStat::strPassStatTime);
	soap_embedded(soap, &this->ns1__NWritePassStat::strReserve1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWritePassStat::strReserve1);
	soap_embedded(soap, &this->ns1__NWritePassStat::strReserve2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWritePassStat::strReserve2);
	soap_embedded(soap, &this->ns1__NWritePassStat::strReserve3, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWritePassStat::strReserve3);
#endif
}

int ns1__NWritePassStat::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NWritePassStat(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NWritePassStat(struct soap *soap, const char *tag, int id, const ns1__NWritePassStat *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NWritePassStat), type))
		return soap->error;
	if (soap_out_std__string(soap, "sid", -1, &a->ns1__NWritePassStat::sid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDeviceId", -1, &a->ns1__NWritePassStat::strDeviceId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDeviceType", -1, &a->ns1__NWritePassStat::strDeviceType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDirectionId", -1, &a->ns1__NWritePassStat::strDirectionId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDriveWayId", -1, &a->ns1__NWritePassStat::strDriveWayId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPassStatTime", -1, &a->ns1__NWritePassStat::strPassStatTime, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lPassCount", -1, &a->ns1__NWritePassStat::lPassCount, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lSuccessCount", -1, &a->ns1__NWritePassStat::lSuccessCount, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lTimelyCount", -1, &a->ns1__NWritePassStat::lTimelyCount, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strReserve1", -1, &a->ns1__NWritePassStat::strReserve1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strReserve2", -1, &a->ns1__NWritePassStat::strReserve2, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strReserve3", -1, &a->ns1__NWritePassStat::strReserve3, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__NWritePassStat::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__NWritePassStat(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NWritePassStat * SOAP_FMAC4 soap_in_ns1__NWritePassStat(struct soap *soap, const char *tag, ns1__NWritePassStat *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NWritePassStat*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NWritePassStat, sizeof(ns1__NWritePassStat), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__NWritePassStat)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__NWritePassStat *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sid1 = 1;
	size_t soap_flag_strDeviceId1 = 1;
	size_t soap_flag_strDeviceType1 = 1;
	size_t soap_flag_strDirectionId1 = 1;
	size_t soap_flag_strDriveWayId1 = 1;
	size_t soap_flag_strPassStatTime1 = 1;
	size_t soap_flag_lPassCount1 = 1;
	size_t soap_flag_lSuccessCount1 = 1;
	size_t soap_flag_lTimelyCount1 = 1;
	size_t soap_flag_strReserve11 = 1;
	size_t soap_flag_strReserve21 = 1;
	size_t soap_flag_strReserve31 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sid", &a->ns1__NWritePassStat::sid, "xsd:string"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap_flag_strDeviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDeviceId", &a->ns1__NWritePassStat::strDeviceId, "xsd:string"))
				{	soap_flag_strDeviceId1--;
					continue;
				}
			}
			if (soap_flag_strDeviceType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDeviceType", &a->ns1__NWritePassStat::strDeviceType, "xsd:string"))
				{	soap_flag_strDeviceType1--;
					continue;
				}
			}
			if (soap_flag_strDirectionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDirectionId", &a->ns1__NWritePassStat::strDirectionId, "xsd:string"))
				{	soap_flag_strDirectionId1--;
					continue;
				}
			}
			if (soap_flag_strDriveWayId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDriveWayId", &a->ns1__NWritePassStat::strDriveWayId, "xsd:string"))
				{	soap_flag_strDriveWayId1--;
					continue;
				}
			}
			if (soap_flag_strPassStatTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPassStatTime", &a->ns1__NWritePassStat::strPassStatTime, "xsd:string"))
				{	soap_flag_strPassStatTime1--;
					continue;
				}
			}
			if (soap_flag_lPassCount1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lPassCount", &a->ns1__NWritePassStat::lPassCount, "xsd:long"))
				{	soap_flag_lPassCount1--;
					continue;
				}
			}
			if (soap_flag_lSuccessCount1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lSuccessCount", &a->ns1__NWritePassStat::lSuccessCount, "xsd:long"))
				{	soap_flag_lSuccessCount1--;
					continue;
				}
			}
			if (soap_flag_lTimelyCount1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lTimelyCount", &a->ns1__NWritePassStat::lTimelyCount, "xsd:long"))
				{	soap_flag_lTimelyCount1--;
					continue;
				}
			}
			if (soap_flag_strReserve11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strReserve1", &a->ns1__NWritePassStat::strReserve1, "xsd:string"))
				{	soap_flag_strReserve11--;
					continue;
				}
			}
			if (soap_flag_strReserve21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strReserve2", &a->ns1__NWritePassStat::strReserve2, "xsd:string"))
				{	soap_flag_strReserve21--;
					continue;
				}
			}
			if (soap_flag_strReserve31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strReserve3", &a->ns1__NWritePassStat::strReserve3, "xsd:string"))
				{	soap_flag_strReserve31--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid1 > 0 || soap_flag_strDeviceId1 > 0 || soap_flag_strDeviceType1 > 0 || soap_flag_strDirectionId1 > 0 || soap_flag_strDriveWayId1 > 0 || soap_flag_strPassStatTime1 > 0 || soap_flag_lPassCount1 > 0 || soap_flag_lSuccessCount1 > 0 || soap_flag_lTimelyCount1 > 0 || soap_flag_strReserve11 > 0 || soap_flag_strReserve21 > 0 || soap_flag_strReserve31 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__NWritePassStat *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NWritePassStat, SOAP_TYPE_ns1__NWritePassStat, sizeof(ns1__NWritePassStat), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__NWritePassStat * SOAP_FMAC2 soap_instantiate_ns1__NWritePassStat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NWritePassStat(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__NWritePassStat *p;
	size_t k = sizeof(ns1__NWritePassStat);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__NWritePassStat, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__NWritePassStat);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__NWritePassStat, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__NWritePassStat location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__NWritePassStat::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__NWritePassStat(soap, tag ? tag : "ns1:NWritePassStat", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NWritePassStat::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NWritePassStat(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NWritePassStat * SOAP_FMAC4 soap_get_ns1__NWritePassStat(struct soap *soap, ns1__NWritePassStat *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NWritePassStat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__NSyncWriteVioInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__NSyncWriteVioInfoResponse::return_ = NULL;
}

void ns1__NSyncWriteVioInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__NSyncWriteVioInfoResponse::return_);
#endif
}

int ns1__NSyncWriteVioInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NSyncWriteVioInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NSyncWriteVioInfoResponse(struct soap *soap, const char *tag, int id, const ns1__NSyncWriteVioInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NSyncWriteVioInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->ns1__NSyncWriteVioInfoResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__NSyncWriteVioInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__NSyncWriteVioInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NSyncWriteVioInfoResponse * SOAP_FMAC4 soap_in_ns1__NSyncWriteVioInfoResponse(struct soap *soap, const char *tag, ns1__NSyncWriteVioInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NSyncWriteVioInfoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NSyncWriteVioInfoResponse, sizeof(ns1__NSyncWriteVioInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__NSyncWriteVioInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__NSyncWriteVioInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->ns1__NSyncWriteVioInfoResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__NSyncWriteVioInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NSyncWriteVioInfoResponse, SOAP_TYPE_ns1__NSyncWriteVioInfoResponse, sizeof(ns1__NSyncWriteVioInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__NSyncWriteVioInfoResponse * SOAP_FMAC2 soap_instantiate_ns1__NSyncWriteVioInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NSyncWriteVioInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__NSyncWriteVioInfoResponse *p;
	size_t k = sizeof(ns1__NSyncWriteVioInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__NSyncWriteVioInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__NSyncWriteVioInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__NSyncWriteVioInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__NSyncWriteVioInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__NSyncWriteVioInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__NSyncWriteVioInfoResponse(soap, tag ? tag : "ns1:NSyncWriteVioInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NSyncWriteVioInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NSyncWriteVioInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NSyncWriteVioInfoResponse * SOAP_FMAC4 soap_get_ns1__NSyncWriteVioInfoResponse(struct soap *soap, ns1__NSyncWriteVioInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NSyncWriteVioInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__NSyncWriteVioInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::sid);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strDeviceId);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strVehicleId);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strDeviceType);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strDirectionId);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strDriveWayId);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strLicense);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strLicenseType);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strPassDateTime);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strRedLightBeginTime);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strRedLightLast);
	soap_default_LONG64(soap, &this->ns1__NSyncWriteVioInfo::lSpeed);
	soap_default_LONG64(soap, &this->ns1__NSyncWriteVioInfo::lLargeLimitSpeed);
	soap_default_LONG64(soap, &this->ns1__NSyncWriteVioInfo::lMiniLimitSpeed);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strViolationType);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strViolationType2);
	soap_default_LONG64(soap, &this->ns1__NSyncWriteVioInfo::lCarLength);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strLicenseColor);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strCarType);
	this->ns1__NSyncWriteVioInfo::strPicLocalPath1.xsd__base64Binary::soap_default(soap);
	this->ns1__NSyncWriteVioInfo::strPicLocalPath2.xsd__base64Binary::soap_default(soap);
	this->ns1__NSyncWriteVioInfo::strPicLocalPath3.xsd__base64Binary::soap_default(soap);
	this->ns1__NSyncWriteVioInfo::strPicLocalPath4.xsd__base64Binary::soap_default(soap);
	this->ns1__NSyncWriteVioInfo::strPicLocalPath5.xsd__base64Binary::soap_default(soap);
	this->ns1__NSyncWriteVioInfo::strPicLocalPath6.xsd__base64Binary::soap_default(soap);
	this->ns1__NSyncWriteVioInfo::strPicLocalPath7.xsd__base64Binary::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strPicRemotePath);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strViolate);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strSendType);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strVioPlaceId);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strVioPlaceName);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strCollectDept);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strDataSrc);
	soap_default_LONG64(soap, &this->ns1__NSyncWriteVioInfo::lRoadKLMS);
	soap_default_LONG64(soap, &this->ns1__NSyncWriteVioInfo::lRoadMs);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strCarColor);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strPassDateTime2);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strVioPlaceId2);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strVioPlaceName2);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strReserve1);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strReserve2);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVioInfo::strReserve3);
}

void ns1__NSyncWriteVioInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::sid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::sid);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strDeviceId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strDeviceId);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strVehicleId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strVehicleId);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strDeviceType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strDeviceType);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strDirectionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strDirectionId);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strDriveWayId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strDriveWayId);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strLicense, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strLicense);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strLicenseType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strLicenseType);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strPassDateTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strPassDateTime);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strRedLightBeginTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strRedLightBeginTime);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strRedLightLast, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strRedLightLast);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strViolationType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strViolationType);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strViolationType2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strViolationType2);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strLicenseColor, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strLicenseColor);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strCarType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strCarType);
	this->ns1__NSyncWriteVioInfo::strPicLocalPath1.soap_serialize(soap);
	this->ns1__NSyncWriteVioInfo::strPicLocalPath2.soap_serialize(soap);
	this->ns1__NSyncWriteVioInfo::strPicLocalPath3.soap_serialize(soap);
	this->ns1__NSyncWriteVioInfo::strPicLocalPath4.soap_serialize(soap);
	this->ns1__NSyncWriteVioInfo::strPicLocalPath5.soap_serialize(soap);
	this->ns1__NSyncWriteVioInfo::strPicLocalPath6.soap_serialize(soap);
	this->ns1__NSyncWriteVioInfo::strPicLocalPath7.soap_serialize(soap);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strPicRemotePath, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strPicRemotePath);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strViolate, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strViolate);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strSendType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strSendType);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strVioPlaceId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strVioPlaceId);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strVioPlaceName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strVioPlaceName);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strCollectDept, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strCollectDept);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strDataSrc, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strDataSrc);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strCarColor, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strCarColor);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strPassDateTime2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strPassDateTime2);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strVioPlaceId2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strVioPlaceId2);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strVioPlaceName2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strVioPlaceName2);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strReserve1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strReserve1);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strReserve2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strReserve2);
	soap_embedded(soap, &this->ns1__NSyncWriteVioInfo::strReserve3, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVioInfo::strReserve3);
#endif
}

int ns1__NSyncWriteVioInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NSyncWriteVioInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NSyncWriteVioInfo(struct soap *soap, const char *tag, int id, const ns1__NSyncWriteVioInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NSyncWriteVioInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "sid", -1, &a->ns1__NSyncWriteVioInfo::sid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDeviceId", -1, &a->ns1__NSyncWriteVioInfo::strDeviceId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strVehicleId", -1, &a->ns1__NSyncWriteVioInfo::strVehicleId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDeviceType", -1, &a->ns1__NSyncWriteVioInfo::strDeviceType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDirectionId", -1, &a->ns1__NSyncWriteVioInfo::strDirectionId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDriveWayId", -1, &a->ns1__NSyncWriteVioInfo::strDriveWayId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strLicense", -1, &a->ns1__NSyncWriteVioInfo::strLicense, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strLicenseType", -1, &a->ns1__NSyncWriteVioInfo::strLicenseType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPassDateTime", -1, &a->ns1__NSyncWriteVioInfo::strPassDateTime, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strRedLightBeginTime", -1, &a->ns1__NSyncWriteVioInfo::strRedLightBeginTime, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strRedLightLast", -1, &a->ns1__NSyncWriteVioInfo::strRedLightLast, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lSpeed", -1, &a->ns1__NSyncWriteVioInfo::lSpeed, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lLargeLimitSpeed", -1, &a->ns1__NSyncWriteVioInfo::lLargeLimitSpeed, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lMiniLimitSpeed", -1, &a->ns1__NSyncWriteVioInfo::lMiniLimitSpeed, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strViolationType", -1, &a->ns1__NSyncWriteVioInfo::strViolationType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strViolationType2", -1, &a->ns1__NSyncWriteVioInfo::strViolationType2, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lCarLength", -1, &a->ns1__NSyncWriteVioInfo::lCarLength, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strLicenseColor", -1, &a->ns1__NSyncWriteVioInfo::strLicenseColor, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strCarType", -1, &a->ns1__NSyncWriteVioInfo::strCarType, ""))
		return soap->error;
	if ((a->ns1__NSyncWriteVioInfo::strPicLocalPath1).soap_out(soap, "strPicLocalPath1", -1, ""))
		return soap->error;
	if ((a->ns1__NSyncWriteVioInfo::strPicLocalPath2).soap_out(soap, "strPicLocalPath2", -1, ""))
		return soap->error;
	if ((a->ns1__NSyncWriteVioInfo::strPicLocalPath3).soap_out(soap, "strPicLocalPath3", -1, ""))
		return soap->error;
	if ((a->ns1__NSyncWriteVioInfo::strPicLocalPath4).soap_out(soap, "strPicLocalPath4", -1, ""))
		return soap->error;
	if ((a->ns1__NSyncWriteVioInfo::strPicLocalPath5).soap_out(soap, "strPicLocalPath5", -1, ""))
		return soap->error;
	if ((a->ns1__NSyncWriteVioInfo::strPicLocalPath6).soap_out(soap, "strPicLocalPath6", -1, ""))
		return soap->error;
	if ((a->ns1__NSyncWriteVioInfo::strPicLocalPath7).soap_out(soap, "strPicLocalPath7", -1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicRemotePath", -1, &a->ns1__NSyncWriteVioInfo::strPicRemotePath, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strViolate", -1, &a->ns1__NSyncWriteVioInfo::strViolate, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strSendType", -1, &a->ns1__NSyncWriteVioInfo::strSendType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strVioPlaceId", -1, &a->ns1__NSyncWriteVioInfo::strVioPlaceId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strVioPlaceName", -1, &a->ns1__NSyncWriteVioInfo::strVioPlaceName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strCollectDept", -1, &a->ns1__NSyncWriteVioInfo::strCollectDept, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDataSrc", -1, &a->ns1__NSyncWriteVioInfo::strDataSrc, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lRoadKLMS", -1, &a->ns1__NSyncWriteVioInfo::lRoadKLMS, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lRoadMs", -1, &a->ns1__NSyncWriteVioInfo::lRoadMs, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strCarColor", -1, &a->ns1__NSyncWriteVioInfo::strCarColor, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPassDateTime2", -1, &a->ns1__NSyncWriteVioInfo::strPassDateTime2, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strVioPlaceId2", -1, &a->ns1__NSyncWriteVioInfo::strVioPlaceId2, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strVioPlaceName2", -1, &a->ns1__NSyncWriteVioInfo::strVioPlaceName2, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strReserve1", -1, &a->ns1__NSyncWriteVioInfo::strReserve1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strReserve2", -1, &a->ns1__NSyncWriteVioInfo::strReserve2, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strReserve3", -1, &a->ns1__NSyncWriteVioInfo::strReserve3, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__NSyncWriteVioInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__NSyncWriteVioInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NSyncWriteVioInfo * SOAP_FMAC4 soap_in_ns1__NSyncWriteVioInfo(struct soap *soap, const char *tag, ns1__NSyncWriteVioInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NSyncWriteVioInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NSyncWriteVioInfo, sizeof(ns1__NSyncWriteVioInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__NSyncWriteVioInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__NSyncWriteVioInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sid1 = 1;
	size_t soap_flag_strDeviceId1 = 1;
	size_t soap_flag_strVehicleId1 = 1;
	size_t soap_flag_strDeviceType1 = 1;
	size_t soap_flag_strDirectionId1 = 1;
	size_t soap_flag_strDriveWayId1 = 1;
	size_t soap_flag_strLicense1 = 1;
	size_t soap_flag_strLicenseType1 = 1;
	size_t soap_flag_strPassDateTime1 = 1;
	size_t soap_flag_strRedLightBeginTime1 = 1;
	size_t soap_flag_strRedLightLast1 = 1;
	size_t soap_flag_lSpeed1 = 1;
	size_t soap_flag_lLargeLimitSpeed1 = 1;
	size_t soap_flag_lMiniLimitSpeed1 = 1;
	size_t soap_flag_strViolationType1 = 1;
	size_t soap_flag_strViolationType21 = 1;
	size_t soap_flag_lCarLength1 = 1;
	size_t soap_flag_strLicenseColor1 = 1;
	size_t soap_flag_strCarType1 = 1;
	size_t soap_flag_strPicLocalPath11 = 1;
	size_t soap_flag_strPicLocalPath21 = 1;
	size_t soap_flag_strPicLocalPath31 = 1;
	size_t soap_flag_strPicLocalPath41 = 1;
	size_t soap_flag_strPicLocalPath51 = 1;
	size_t soap_flag_strPicLocalPath61 = 1;
	size_t soap_flag_strPicLocalPath71 = 1;
	size_t soap_flag_strPicRemotePath1 = 1;
	size_t soap_flag_strViolate1 = 1;
	size_t soap_flag_strSendType1 = 1;
	size_t soap_flag_strVioPlaceId1 = 1;
	size_t soap_flag_strVioPlaceName1 = 1;
	size_t soap_flag_strCollectDept1 = 1;
	size_t soap_flag_strDataSrc1 = 1;
	size_t soap_flag_lRoadKLMS1 = 1;
	size_t soap_flag_lRoadMs1 = 1;
	size_t soap_flag_strCarColor1 = 1;
	size_t soap_flag_strPassDateTime21 = 1;
	size_t soap_flag_strVioPlaceId21 = 1;
	size_t soap_flag_strVioPlaceName21 = 1;
	size_t soap_flag_strReserve11 = 1;
	size_t soap_flag_strReserve21 = 1;
	size_t soap_flag_strReserve31 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sid", &a->ns1__NSyncWriteVioInfo::sid, "xsd:string"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap_flag_strDeviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDeviceId", &a->ns1__NSyncWriteVioInfo::strDeviceId, "xsd:string"))
				{	soap_flag_strDeviceId1--;
					continue;
				}
			}
			if (soap_flag_strVehicleId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strVehicleId", &a->ns1__NSyncWriteVioInfo::strVehicleId, "xsd:string"))
				{	soap_flag_strVehicleId1--;
					continue;
				}
			}
			if (soap_flag_strDeviceType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDeviceType", &a->ns1__NSyncWriteVioInfo::strDeviceType, "xsd:string"))
				{	soap_flag_strDeviceType1--;
					continue;
				}
			}
			if (soap_flag_strDirectionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDirectionId", &a->ns1__NSyncWriteVioInfo::strDirectionId, "xsd:string"))
				{	soap_flag_strDirectionId1--;
					continue;
				}
			}
			if (soap_flag_strDriveWayId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDriveWayId", &a->ns1__NSyncWriteVioInfo::strDriveWayId, "xsd:string"))
				{	soap_flag_strDriveWayId1--;
					continue;
				}
			}
			if (soap_flag_strLicense1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strLicense", &a->ns1__NSyncWriteVioInfo::strLicense, "xsd:string"))
				{	soap_flag_strLicense1--;
					continue;
				}
			}
			if (soap_flag_strLicenseType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strLicenseType", &a->ns1__NSyncWriteVioInfo::strLicenseType, "xsd:string"))
				{	soap_flag_strLicenseType1--;
					continue;
				}
			}
			if (soap_flag_strPassDateTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPassDateTime", &a->ns1__NSyncWriteVioInfo::strPassDateTime, "xsd:string"))
				{	soap_flag_strPassDateTime1--;
					continue;
				}
			}
			if (soap_flag_strRedLightBeginTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strRedLightBeginTime", &a->ns1__NSyncWriteVioInfo::strRedLightBeginTime, "xsd:string"))
				{	soap_flag_strRedLightBeginTime1--;
					continue;
				}
			}
			if (soap_flag_strRedLightLast1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strRedLightLast", &a->ns1__NSyncWriteVioInfo::strRedLightLast, "xsd:string"))
				{	soap_flag_strRedLightLast1--;
					continue;
				}
			}
			if (soap_flag_lSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lSpeed", &a->ns1__NSyncWriteVioInfo::lSpeed, "xsd:long"))
				{	soap_flag_lSpeed1--;
					continue;
				}
			}
			if (soap_flag_lLargeLimitSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lLargeLimitSpeed", &a->ns1__NSyncWriteVioInfo::lLargeLimitSpeed, "xsd:long"))
				{	soap_flag_lLargeLimitSpeed1--;
					continue;
				}
			}
			if (soap_flag_lMiniLimitSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lMiniLimitSpeed", &a->ns1__NSyncWriteVioInfo::lMiniLimitSpeed, "xsd:long"))
				{	soap_flag_lMiniLimitSpeed1--;
					continue;
				}
			}
			if (soap_flag_strViolationType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strViolationType", &a->ns1__NSyncWriteVioInfo::strViolationType, "xsd:string"))
				{	soap_flag_strViolationType1--;
					continue;
				}
			}
			if (soap_flag_strViolationType21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strViolationType2", &a->ns1__NSyncWriteVioInfo::strViolationType2, "xsd:string"))
				{	soap_flag_strViolationType21--;
					continue;
				}
			}
			if (soap_flag_lCarLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lCarLength", &a->ns1__NSyncWriteVioInfo::lCarLength, "xsd:long"))
				{	soap_flag_lCarLength1--;
					continue;
				}
			}
			if (soap_flag_strLicenseColor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strLicenseColor", &a->ns1__NSyncWriteVioInfo::strLicenseColor, "xsd:string"))
				{	soap_flag_strLicenseColor1--;
					continue;
				}
			}
			if (soap_flag_strCarType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strCarType", &a->ns1__NSyncWriteVioInfo::strCarType, "xsd:string"))
				{	soap_flag_strCarType1--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath11 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__NSyncWriteVioInfo::strPicLocalPath1).soap_in(soap, "strPicLocalPath1", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath11--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath21 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__NSyncWriteVioInfo::strPicLocalPath2).soap_in(soap, "strPicLocalPath2", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath21--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath31 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__NSyncWriteVioInfo::strPicLocalPath3).soap_in(soap, "strPicLocalPath3", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath31--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath41 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__NSyncWriteVioInfo::strPicLocalPath4).soap_in(soap, "strPicLocalPath4", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath41--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath51 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__NSyncWriteVioInfo::strPicLocalPath5).soap_in(soap, "strPicLocalPath5", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath51--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath61 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__NSyncWriteVioInfo::strPicLocalPath6).soap_in(soap, "strPicLocalPath6", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath61--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath71 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__NSyncWriteVioInfo::strPicLocalPath7).soap_in(soap, "strPicLocalPath7", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath71--;
					continue;
				}
			}
			if (soap_flag_strPicRemotePath1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicRemotePath", &a->ns1__NSyncWriteVioInfo::strPicRemotePath, "xsd:string"))
				{	soap_flag_strPicRemotePath1--;
					continue;
				}
			}
			if (soap_flag_strViolate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strViolate", &a->ns1__NSyncWriteVioInfo::strViolate, "xsd:string"))
				{	soap_flag_strViolate1--;
					continue;
				}
			}
			if (soap_flag_strSendType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strSendType", &a->ns1__NSyncWriteVioInfo::strSendType, "xsd:string"))
				{	soap_flag_strSendType1--;
					continue;
				}
			}
			if (soap_flag_strVioPlaceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strVioPlaceId", &a->ns1__NSyncWriteVioInfo::strVioPlaceId, "xsd:string"))
				{	soap_flag_strVioPlaceId1--;
					continue;
				}
			}
			if (soap_flag_strVioPlaceName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strVioPlaceName", &a->ns1__NSyncWriteVioInfo::strVioPlaceName, "xsd:string"))
				{	soap_flag_strVioPlaceName1--;
					continue;
				}
			}
			if (soap_flag_strCollectDept1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strCollectDept", &a->ns1__NSyncWriteVioInfo::strCollectDept, "xsd:string"))
				{	soap_flag_strCollectDept1--;
					continue;
				}
			}
			if (soap_flag_strDataSrc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDataSrc", &a->ns1__NSyncWriteVioInfo::strDataSrc, "xsd:string"))
				{	soap_flag_strDataSrc1--;
					continue;
				}
			}
			if (soap_flag_lRoadKLMS1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lRoadKLMS", &a->ns1__NSyncWriteVioInfo::lRoadKLMS, "xsd:long"))
				{	soap_flag_lRoadKLMS1--;
					continue;
				}
			}
			if (soap_flag_lRoadMs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lRoadMs", &a->ns1__NSyncWriteVioInfo::lRoadMs, "xsd:long"))
				{	soap_flag_lRoadMs1--;
					continue;
				}
			}
			if (soap_flag_strCarColor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strCarColor", &a->ns1__NSyncWriteVioInfo::strCarColor, "xsd:string"))
				{	soap_flag_strCarColor1--;
					continue;
				}
			}
			if (soap_flag_strPassDateTime21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPassDateTime2", &a->ns1__NSyncWriteVioInfo::strPassDateTime2, "xsd:string"))
				{	soap_flag_strPassDateTime21--;
					continue;
				}
			}
			if (soap_flag_strVioPlaceId21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strVioPlaceId2", &a->ns1__NSyncWriteVioInfo::strVioPlaceId2, "xsd:string"))
				{	soap_flag_strVioPlaceId21--;
					continue;
				}
			}
			if (soap_flag_strVioPlaceName21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strVioPlaceName2", &a->ns1__NSyncWriteVioInfo::strVioPlaceName2, "xsd:string"))
				{	soap_flag_strVioPlaceName21--;
					continue;
				}
			}
			if (soap_flag_strReserve11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strReserve1", &a->ns1__NSyncWriteVioInfo::strReserve1, "xsd:string"))
				{	soap_flag_strReserve11--;
					continue;
				}
			}
			if (soap_flag_strReserve21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strReserve2", &a->ns1__NSyncWriteVioInfo::strReserve2, "xsd:string"))
				{	soap_flag_strReserve21--;
					continue;
				}
			}
			if (soap_flag_strReserve31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strReserve3", &a->ns1__NSyncWriteVioInfo::strReserve3, "xsd:string"))
				{	soap_flag_strReserve31--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid1 > 0 || soap_flag_strDeviceId1 > 0 || soap_flag_strVehicleId1 > 0 || soap_flag_strDeviceType1 > 0 || soap_flag_strDirectionId1 > 0 || soap_flag_strDriveWayId1 > 0 || soap_flag_strLicense1 > 0 || soap_flag_strLicenseType1 > 0 || soap_flag_strPassDateTime1 > 0 || soap_flag_strRedLightBeginTime1 > 0 || soap_flag_strRedLightLast1 > 0 || soap_flag_lSpeed1 > 0 || soap_flag_lLargeLimitSpeed1 > 0 || soap_flag_lMiniLimitSpeed1 > 0 || soap_flag_strViolationType1 > 0 || soap_flag_strViolationType21 > 0 || soap_flag_lCarLength1 > 0 || soap_flag_strLicenseColor1 > 0 || soap_flag_strCarType1 > 0 || soap_flag_strPicLocalPath11 > 0 || soap_flag_strPicLocalPath21 > 0 || soap_flag_strPicLocalPath31 > 0 || soap_flag_strPicLocalPath41 > 0 || soap_flag_strPicLocalPath51 > 0 || soap_flag_strPicLocalPath61 > 0 || soap_flag_strPicLocalPath71 > 0 || soap_flag_strPicRemotePath1 > 0 || soap_flag_strViolate1 > 0 || soap_flag_strSendType1 > 0 || soap_flag_strVioPlaceId1 > 0 || soap_flag_strVioPlaceName1 > 0 || soap_flag_strCollectDept1 > 0 || soap_flag_strDataSrc1 > 0 || soap_flag_lRoadKLMS1 > 0 || soap_flag_lRoadMs1 > 0 || soap_flag_strCarColor1 > 0 || soap_flag_strPassDateTime21 > 0 || soap_flag_strVioPlaceId21 > 0 || soap_flag_strVioPlaceName21 > 0 || soap_flag_strReserve11 > 0 || soap_flag_strReserve21 > 0 || soap_flag_strReserve31 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__NSyncWriteVioInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NSyncWriteVioInfo, SOAP_TYPE_ns1__NSyncWriteVioInfo, sizeof(ns1__NSyncWriteVioInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__NSyncWriteVioInfo * SOAP_FMAC2 soap_instantiate_ns1__NSyncWriteVioInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NSyncWriteVioInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__NSyncWriteVioInfo *p;
	size_t k = sizeof(ns1__NSyncWriteVioInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__NSyncWriteVioInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__NSyncWriteVioInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__NSyncWriteVioInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__NSyncWriteVioInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__NSyncWriteVioInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__NSyncWriteVioInfo(soap, tag ? tag : "ns1:NSyncWriteVioInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NSyncWriteVioInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NSyncWriteVioInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NSyncWriteVioInfo * SOAP_FMAC4 soap_get_ns1__NSyncWriteVioInfo(struct soap *soap, ns1__NSyncWriteVioInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NSyncWriteVioInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__NSyncWriteMobileEPVInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__NSyncWriteMobileEPVInfoResponse::return_ = NULL;
}

void ns1__NSyncWriteMobileEPVInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__NSyncWriteMobileEPVInfoResponse::return_);
#endif
}

int ns1__NSyncWriteMobileEPVInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NSyncWriteMobileEPVInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NSyncWriteMobileEPVInfoResponse(struct soap *soap, const char *tag, int id, const ns1__NSyncWriteMobileEPVInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NSyncWriteMobileEPVInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->ns1__NSyncWriteMobileEPVInfoResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__NSyncWriteMobileEPVInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__NSyncWriteMobileEPVInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NSyncWriteMobileEPVInfoResponse * SOAP_FMAC4 soap_in_ns1__NSyncWriteMobileEPVInfoResponse(struct soap *soap, const char *tag, ns1__NSyncWriteMobileEPVInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NSyncWriteMobileEPVInfoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NSyncWriteMobileEPVInfoResponse, sizeof(ns1__NSyncWriteMobileEPVInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__NSyncWriteMobileEPVInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__NSyncWriteMobileEPVInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->ns1__NSyncWriteMobileEPVInfoResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__NSyncWriteMobileEPVInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NSyncWriteMobileEPVInfoResponse, SOAP_TYPE_ns1__NSyncWriteMobileEPVInfoResponse, sizeof(ns1__NSyncWriteMobileEPVInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__NSyncWriteMobileEPVInfoResponse * SOAP_FMAC2 soap_instantiate_ns1__NSyncWriteMobileEPVInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NSyncWriteMobileEPVInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__NSyncWriteMobileEPVInfoResponse *p;
	size_t k = sizeof(ns1__NSyncWriteMobileEPVInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__NSyncWriteMobileEPVInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__NSyncWriteMobileEPVInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__NSyncWriteMobileEPVInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__NSyncWriteMobileEPVInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__NSyncWriteMobileEPVInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__NSyncWriteMobileEPVInfoResponse(soap, tag ? tag : "ns1:NSyncWriteMobileEPVInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NSyncWriteMobileEPVInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NSyncWriteMobileEPVInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NSyncWriteMobileEPVInfoResponse * SOAP_FMAC4 soap_get_ns1__NSyncWriteMobileEPVInfoResponse(struct soap *soap, ns1__NSyncWriteMobileEPVInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NSyncWriteMobileEPVInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__NSyncWriteMobileEPVInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::sid);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strDeviceId);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strVehicleId);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strDeviceType);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strDirectionId);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strDriveWayId);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strLicense);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strLicenseType);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strPassDateTime);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strRedLightBeginTime);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strRedLightLast);
	soap_default_LONG64(soap, &this->ns1__NSyncWriteMobileEPVInfo::lSpeed);
	soap_default_LONG64(soap, &this->ns1__NSyncWriteMobileEPVInfo::lLargeLimitSpeed);
	soap_default_LONG64(soap, &this->ns1__NSyncWriteMobileEPVInfo::lMiniLimitSpeed);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strViolationType);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strViolationType2);
	soap_default_LONG64(soap, &this->ns1__NSyncWriteMobileEPVInfo::lCarLength);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strLicenseColor);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strCarType);
	this->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath1.xsd__base64Binary::soap_default(soap);
	this->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath2.xsd__base64Binary::soap_default(soap);
	this->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath3.xsd__base64Binary::soap_default(soap);
	this->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath4.xsd__base64Binary::soap_default(soap);
	this->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath5.xsd__base64Binary::soap_default(soap);
	this->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath6.xsd__base64Binary::soap_default(soap);
	this->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath7.xsd__base64Binary::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strPicRemotePath);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strViolate);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strSendType);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strVioPlaceId);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strVioPlaceName);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strCollectDept);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strDataSrc);
	soap_default_LONG64(soap, &this->ns1__NSyncWriteMobileEPVInfo::lRoadKLMS);
	soap_default_LONG64(soap, &this->ns1__NSyncWriteMobileEPVInfo::lRoadMs);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strCarColor);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strReserve1);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strReserve2);
	soap_default_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strReserve3);
}

void ns1__NSyncWriteMobileEPVInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::sid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::sid);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strDeviceId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strDeviceId);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strVehicleId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strVehicleId);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strDeviceType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strDeviceType);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strDirectionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strDirectionId);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strDriveWayId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strDriveWayId);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strLicense, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strLicense);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strLicenseType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strLicenseType);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strPassDateTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strPassDateTime);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strRedLightBeginTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strRedLightBeginTime);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strRedLightLast, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strRedLightLast);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strViolationType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strViolationType);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strViolationType2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strViolationType2);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strLicenseColor, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strLicenseColor);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strCarType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strCarType);
	this->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath1.soap_serialize(soap);
	this->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath2.soap_serialize(soap);
	this->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath3.soap_serialize(soap);
	this->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath4.soap_serialize(soap);
	this->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath5.soap_serialize(soap);
	this->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath6.soap_serialize(soap);
	this->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath7.soap_serialize(soap);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strPicRemotePath, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strPicRemotePath);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strViolate, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strViolate);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strSendType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strSendType);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strVioPlaceId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strVioPlaceId);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strVioPlaceName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strVioPlaceName);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strCollectDept, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strCollectDept);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strDataSrc, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strDataSrc);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strCarColor, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strCarColor);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strReserve1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strReserve1);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strReserve2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strReserve2);
	soap_embedded(soap, &this->ns1__NSyncWriteMobileEPVInfo::strReserve3, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteMobileEPVInfo::strReserve3);
#endif
}

int ns1__NSyncWriteMobileEPVInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NSyncWriteMobileEPVInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NSyncWriteMobileEPVInfo(struct soap *soap, const char *tag, int id, const ns1__NSyncWriteMobileEPVInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NSyncWriteMobileEPVInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "sid", -1, &a->ns1__NSyncWriteMobileEPVInfo::sid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDeviceId", -1, &a->ns1__NSyncWriteMobileEPVInfo::strDeviceId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strVehicleId", -1, &a->ns1__NSyncWriteMobileEPVInfo::strVehicleId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDeviceType", -1, &a->ns1__NSyncWriteMobileEPVInfo::strDeviceType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDirectionId", -1, &a->ns1__NSyncWriteMobileEPVInfo::strDirectionId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDriveWayId", -1, &a->ns1__NSyncWriteMobileEPVInfo::strDriveWayId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strLicense", -1, &a->ns1__NSyncWriteMobileEPVInfo::strLicense, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strLicenseType", -1, &a->ns1__NSyncWriteMobileEPVInfo::strLicenseType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPassDateTime", -1, &a->ns1__NSyncWriteMobileEPVInfo::strPassDateTime, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strRedLightBeginTime", -1, &a->ns1__NSyncWriteMobileEPVInfo::strRedLightBeginTime, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strRedLightLast", -1, &a->ns1__NSyncWriteMobileEPVInfo::strRedLightLast, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lSpeed", -1, &a->ns1__NSyncWriteMobileEPVInfo::lSpeed, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lLargeLimitSpeed", -1, &a->ns1__NSyncWriteMobileEPVInfo::lLargeLimitSpeed, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lMiniLimitSpeed", -1, &a->ns1__NSyncWriteMobileEPVInfo::lMiniLimitSpeed, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strViolationType", -1, &a->ns1__NSyncWriteMobileEPVInfo::strViolationType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strViolationType2", -1, &a->ns1__NSyncWriteMobileEPVInfo::strViolationType2, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lCarLength", -1, &a->ns1__NSyncWriteMobileEPVInfo::lCarLength, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strLicenseColor", -1, &a->ns1__NSyncWriteMobileEPVInfo::strLicenseColor, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strCarType", -1, &a->ns1__NSyncWriteMobileEPVInfo::strCarType, ""))
		return soap->error;
	if ((a->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath1).soap_out(soap, "strPicLocalPath1", -1, ""))
		return soap->error;
	if ((a->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath2).soap_out(soap, "strPicLocalPath2", -1, ""))
		return soap->error;
	if ((a->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath3).soap_out(soap, "strPicLocalPath3", -1, ""))
		return soap->error;
	if ((a->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath4).soap_out(soap, "strPicLocalPath4", -1, ""))
		return soap->error;
	if ((a->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath5).soap_out(soap, "strPicLocalPath5", -1, ""))
		return soap->error;
	if ((a->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath6).soap_out(soap, "strPicLocalPath6", -1, ""))
		return soap->error;
	if ((a->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath7).soap_out(soap, "strPicLocalPath7", -1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicRemotePath", -1, &a->ns1__NSyncWriteMobileEPVInfo::strPicRemotePath, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strViolate", -1, &a->ns1__NSyncWriteMobileEPVInfo::strViolate, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strSendType", -1, &a->ns1__NSyncWriteMobileEPVInfo::strSendType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strVioPlaceId", -1, &a->ns1__NSyncWriteMobileEPVInfo::strVioPlaceId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strVioPlaceName", -1, &a->ns1__NSyncWriteMobileEPVInfo::strVioPlaceName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strCollectDept", -1, &a->ns1__NSyncWriteMobileEPVInfo::strCollectDept, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDataSrc", -1, &a->ns1__NSyncWriteMobileEPVInfo::strDataSrc, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lRoadKLMS", -1, &a->ns1__NSyncWriteMobileEPVInfo::lRoadKLMS, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lRoadMs", -1, &a->ns1__NSyncWriteMobileEPVInfo::lRoadMs, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strCarColor", -1, &a->ns1__NSyncWriteMobileEPVInfo::strCarColor, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strReserve1", -1, &a->ns1__NSyncWriteMobileEPVInfo::strReserve1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strReserve2", -1, &a->ns1__NSyncWriteMobileEPVInfo::strReserve2, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strReserve3", -1, &a->ns1__NSyncWriteMobileEPVInfo::strReserve3, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__NSyncWriteMobileEPVInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__NSyncWriteMobileEPVInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NSyncWriteMobileEPVInfo * SOAP_FMAC4 soap_in_ns1__NSyncWriteMobileEPVInfo(struct soap *soap, const char *tag, ns1__NSyncWriteMobileEPVInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NSyncWriteMobileEPVInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NSyncWriteMobileEPVInfo, sizeof(ns1__NSyncWriteMobileEPVInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__NSyncWriteMobileEPVInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__NSyncWriteMobileEPVInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sid1 = 1;
	size_t soap_flag_strDeviceId1 = 1;
	size_t soap_flag_strVehicleId1 = 1;
	size_t soap_flag_strDeviceType1 = 1;
	size_t soap_flag_strDirectionId1 = 1;
	size_t soap_flag_strDriveWayId1 = 1;
	size_t soap_flag_strLicense1 = 1;
	size_t soap_flag_strLicenseType1 = 1;
	size_t soap_flag_strPassDateTime1 = 1;
	size_t soap_flag_strRedLightBeginTime1 = 1;
	size_t soap_flag_strRedLightLast1 = 1;
	size_t soap_flag_lSpeed1 = 1;
	size_t soap_flag_lLargeLimitSpeed1 = 1;
	size_t soap_flag_lMiniLimitSpeed1 = 1;
	size_t soap_flag_strViolationType1 = 1;
	size_t soap_flag_strViolationType21 = 1;
	size_t soap_flag_lCarLength1 = 1;
	size_t soap_flag_strLicenseColor1 = 1;
	size_t soap_flag_strCarType1 = 1;
	size_t soap_flag_strPicLocalPath11 = 1;
	size_t soap_flag_strPicLocalPath21 = 1;
	size_t soap_flag_strPicLocalPath31 = 1;
	size_t soap_flag_strPicLocalPath41 = 1;
	size_t soap_flag_strPicLocalPath51 = 1;
	size_t soap_flag_strPicLocalPath61 = 1;
	size_t soap_flag_strPicLocalPath71 = 1;
	size_t soap_flag_strPicRemotePath1 = 1;
	size_t soap_flag_strViolate1 = 1;
	size_t soap_flag_strSendType1 = 1;
	size_t soap_flag_strVioPlaceId1 = 1;
	size_t soap_flag_strVioPlaceName1 = 1;
	size_t soap_flag_strCollectDept1 = 1;
	size_t soap_flag_strDataSrc1 = 1;
	size_t soap_flag_lRoadKLMS1 = 1;
	size_t soap_flag_lRoadMs1 = 1;
	size_t soap_flag_strCarColor1 = 1;
	size_t soap_flag_strReserve11 = 1;
	size_t soap_flag_strReserve21 = 1;
	size_t soap_flag_strReserve31 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sid", &a->ns1__NSyncWriteMobileEPVInfo::sid, "xsd:string"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap_flag_strDeviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDeviceId", &a->ns1__NSyncWriteMobileEPVInfo::strDeviceId, "xsd:string"))
				{	soap_flag_strDeviceId1--;
					continue;
				}
			}
			if (soap_flag_strVehicleId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strVehicleId", &a->ns1__NSyncWriteMobileEPVInfo::strVehicleId, "xsd:string"))
				{	soap_flag_strVehicleId1--;
					continue;
				}
			}
			if (soap_flag_strDeviceType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDeviceType", &a->ns1__NSyncWriteMobileEPVInfo::strDeviceType, "xsd:string"))
				{	soap_flag_strDeviceType1--;
					continue;
				}
			}
			if (soap_flag_strDirectionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDirectionId", &a->ns1__NSyncWriteMobileEPVInfo::strDirectionId, "xsd:string"))
				{	soap_flag_strDirectionId1--;
					continue;
				}
			}
			if (soap_flag_strDriveWayId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDriveWayId", &a->ns1__NSyncWriteMobileEPVInfo::strDriveWayId, "xsd:string"))
				{	soap_flag_strDriveWayId1--;
					continue;
				}
			}
			if (soap_flag_strLicense1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strLicense", &a->ns1__NSyncWriteMobileEPVInfo::strLicense, "xsd:string"))
				{	soap_flag_strLicense1--;
					continue;
				}
			}
			if (soap_flag_strLicenseType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strLicenseType", &a->ns1__NSyncWriteMobileEPVInfo::strLicenseType, "xsd:string"))
				{	soap_flag_strLicenseType1--;
					continue;
				}
			}
			if (soap_flag_strPassDateTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPassDateTime", &a->ns1__NSyncWriteMobileEPVInfo::strPassDateTime, "xsd:string"))
				{	soap_flag_strPassDateTime1--;
					continue;
				}
			}
			if (soap_flag_strRedLightBeginTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strRedLightBeginTime", &a->ns1__NSyncWriteMobileEPVInfo::strRedLightBeginTime, "xsd:string"))
				{	soap_flag_strRedLightBeginTime1--;
					continue;
				}
			}
			if (soap_flag_strRedLightLast1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strRedLightLast", &a->ns1__NSyncWriteMobileEPVInfo::strRedLightLast, "xsd:string"))
				{	soap_flag_strRedLightLast1--;
					continue;
				}
			}
			if (soap_flag_lSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lSpeed", &a->ns1__NSyncWriteMobileEPVInfo::lSpeed, "xsd:long"))
				{	soap_flag_lSpeed1--;
					continue;
				}
			}
			if (soap_flag_lLargeLimitSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lLargeLimitSpeed", &a->ns1__NSyncWriteMobileEPVInfo::lLargeLimitSpeed, "xsd:long"))
				{	soap_flag_lLargeLimitSpeed1--;
					continue;
				}
			}
			if (soap_flag_lMiniLimitSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lMiniLimitSpeed", &a->ns1__NSyncWriteMobileEPVInfo::lMiniLimitSpeed, "xsd:long"))
				{	soap_flag_lMiniLimitSpeed1--;
					continue;
				}
			}
			if (soap_flag_strViolationType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strViolationType", &a->ns1__NSyncWriteMobileEPVInfo::strViolationType, "xsd:string"))
				{	soap_flag_strViolationType1--;
					continue;
				}
			}
			if (soap_flag_strViolationType21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strViolationType2", &a->ns1__NSyncWriteMobileEPVInfo::strViolationType2, "xsd:string"))
				{	soap_flag_strViolationType21--;
					continue;
				}
			}
			if (soap_flag_lCarLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lCarLength", &a->ns1__NSyncWriteMobileEPVInfo::lCarLength, "xsd:long"))
				{	soap_flag_lCarLength1--;
					continue;
				}
			}
			if (soap_flag_strLicenseColor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strLicenseColor", &a->ns1__NSyncWriteMobileEPVInfo::strLicenseColor, "xsd:string"))
				{	soap_flag_strLicenseColor1--;
					continue;
				}
			}
			if (soap_flag_strCarType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strCarType", &a->ns1__NSyncWriteMobileEPVInfo::strCarType, "xsd:string"))
				{	soap_flag_strCarType1--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath11 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath1).soap_in(soap, "strPicLocalPath1", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath11--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath21 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath2).soap_in(soap, "strPicLocalPath2", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath21--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath31 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath3).soap_in(soap, "strPicLocalPath3", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath31--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath41 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath4).soap_in(soap, "strPicLocalPath4", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath41--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath51 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath5).soap_in(soap, "strPicLocalPath5", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath51--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath61 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath6).soap_in(soap, "strPicLocalPath6", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath61--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath71 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__NSyncWriteMobileEPVInfo::strPicLocalPath7).soap_in(soap, "strPicLocalPath7", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath71--;
					continue;
				}
			}
			if (soap_flag_strPicRemotePath1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicRemotePath", &a->ns1__NSyncWriteMobileEPVInfo::strPicRemotePath, "xsd:string"))
				{	soap_flag_strPicRemotePath1--;
					continue;
				}
			}
			if (soap_flag_strViolate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strViolate", &a->ns1__NSyncWriteMobileEPVInfo::strViolate, "xsd:string"))
				{	soap_flag_strViolate1--;
					continue;
				}
			}
			if (soap_flag_strSendType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strSendType", &a->ns1__NSyncWriteMobileEPVInfo::strSendType, "xsd:string"))
				{	soap_flag_strSendType1--;
					continue;
				}
			}
			if (soap_flag_strVioPlaceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strVioPlaceId", &a->ns1__NSyncWriteMobileEPVInfo::strVioPlaceId, "xsd:string"))
				{	soap_flag_strVioPlaceId1--;
					continue;
				}
			}
			if (soap_flag_strVioPlaceName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strVioPlaceName", &a->ns1__NSyncWriteMobileEPVInfo::strVioPlaceName, "xsd:string"))
				{	soap_flag_strVioPlaceName1--;
					continue;
				}
			}
			if (soap_flag_strCollectDept1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strCollectDept", &a->ns1__NSyncWriteMobileEPVInfo::strCollectDept, "xsd:string"))
				{	soap_flag_strCollectDept1--;
					continue;
				}
			}
			if (soap_flag_strDataSrc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDataSrc", &a->ns1__NSyncWriteMobileEPVInfo::strDataSrc, "xsd:string"))
				{	soap_flag_strDataSrc1--;
					continue;
				}
			}
			if (soap_flag_lRoadKLMS1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lRoadKLMS", &a->ns1__NSyncWriteMobileEPVInfo::lRoadKLMS, "xsd:long"))
				{	soap_flag_lRoadKLMS1--;
					continue;
				}
			}
			if (soap_flag_lRoadMs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lRoadMs", &a->ns1__NSyncWriteMobileEPVInfo::lRoadMs, "xsd:long"))
				{	soap_flag_lRoadMs1--;
					continue;
				}
			}
			if (soap_flag_strCarColor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strCarColor", &a->ns1__NSyncWriteMobileEPVInfo::strCarColor, "xsd:string"))
				{	soap_flag_strCarColor1--;
					continue;
				}
			}
			if (soap_flag_strReserve11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strReserve1", &a->ns1__NSyncWriteMobileEPVInfo::strReserve1, "xsd:string"))
				{	soap_flag_strReserve11--;
					continue;
				}
			}
			if (soap_flag_strReserve21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strReserve2", &a->ns1__NSyncWriteMobileEPVInfo::strReserve2, "xsd:string"))
				{	soap_flag_strReserve21--;
					continue;
				}
			}
			if (soap_flag_strReserve31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strReserve3", &a->ns1__NSyncWriteMobileEPVInfo::strReserve3, "xsd:string"))
				{	soap_flag_strReserve31--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid1 > 0 || soap_flag_strDeviceId1 > 0 || soap_flag_strVehicleId1 > 0 || soap_flag_strDeviceType1 > 0 || soap_flag_strDirectionId1 > 0 || soap_flag_strDriveWayId1 > 0 || soap_flag_strLicense1 > 0 || soap_flag_strLicenseType1 > 0 || soap_flag_strPassDateTime1 > 0 || soap_flag_strRedLightBeginTime1 > 0 || soap_flag_strRedLightLast1 > 0 || soap_flag_lSpeed1 > 0 || soap_flag_lLargeLimitSpeed1 > 0 || soap_flag_lMiniLimitSpeed1 > 0 || soap_flag_strViolationType1 > 0 || soap_flag_strViolationType21 > 0 || soap_flag_lCarLength1 > 0 || soap_flag_strLicenseColor1 > 0 || soap_flag_strCarType1 > 0 || soap_flag_strPicLocalPath11 > 0 || soap_flag_strPicLocalPath21 > 0 || soap_flag_strPicLocalPath31 > 0 || soap_flag_strPicLocalPath41 > 0 || soap_flag_strPicLocalPath51 > 0 || soap_flag_strPicLocalPath61 > 0 || soap_flag_strPicLocalPath71 > 0 || soap_flag_strPicRemotePath1 > 0 || soap_flag_strViolate1 > 0 || soap_flag_strSendType1 > 0 || soap_flag_strVioPlaceId1 > 0 || soap_flag_strVioPlaceName1 > 0 || soap_flag_strCollectDept1 > 0 || soap_flag_strDataSrc1 > 0 || soap_flag_lRoadKLMS1 > 0 || soap_flag_lRoadMs1 > 0 || soap_flag_strCarColor1 > 0 || soap_flag_strReserve11 > 0 || soap_flag_strReserve21 > 0 || soap_flag_strReserve31 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__NSyncWriteMobileEPVInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NSyncWriteMobileEPVInfo, SOAP_TYPE_ns1__NSyncWriteMobileEPVInfo, sizeof(ns1__NSyncWriteMobileEPVInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__NSyncWriteMobileEPVInfo * SOAP_FMAC2 soap_instantiate_ns1__NSyncWriteMobileEPVInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NSyncWriteMobileEPVInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__NSyncWriteMobileEPVInfo *p;
	size_t k = sizeof(ns1__NSyncWriteMobileEPVInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__NSyncWriteMobileEPVInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__NSyncWriteMobileEPVInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__NSyncWriteMobileEPVInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__NSyncWriteMobileEPVInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__NSyncWriteMobileEPVInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__NSyncWriteMobileEPVInfo(soap, tag ? tag : "ns1:NSyncWriteMobileEPVInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NSyncWriteMobileEPVInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NSyncWriteMobileEPVInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NSyncWriteMobileEPVInfo * SOAP_FMAC4 soap_get_ns1__NSyncWriteMobileEPVInfo(struct soap *soap, ns1__NSyncWriteMobileEPVInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NSyncWriteMobileEPVInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__NWriteDeviceStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__NWriteDeviceStatusResponse::return_ = NULL;
}

void ns1__NWriteDeviceStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__NWriteDeviceStatusResponse::return_);
#endif
}

int ns1__NWriteDeviceStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NWriteDeviceStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NWriteDeviceStatusResponse(struct soap *soap, const char *tag, int id, const ns1__NWriteDeviceStatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NWriteDeviceStatusResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->ns1__NWriteDeviceStatusResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__NWriteDeviceStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__NWriteDeviceStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NWriteDeviceStatusResponse * SOAP_FMAC4 soap_in_ns1__NWriteDeviceStatusResponse(struct soap *soap, const char *tag, ns1__NWriteDeviceStatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NWriteDeviceStatusResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NWriteDeviceStatusResponse, sizeof(ns1__NWriteDeviceStatusResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__NWriteDeviceStatusResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__NWriteDeviceStatusResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->ns1__NWriteDeviceStatusResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__NWriteDeviceStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NWriteDeviceStatusResponse, SOAP_TYPE_ns1__NWriteDeviceStatusResponse, sizeof(ns1__NWriteDeviceStatusResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__NWriteDeviceStatusResponse * SOAP_FMAC2 soap_instantiate_ns1__NWriteDeviceStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NWriteDeviceStatusResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__NWriteDeviceStatusResponse *p;
	size_t k = sizeof(ns1__NWriteDeviceStatusResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__NWriteDeviceStatusResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__NWriteDeviceStatusResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__NWriteDeviceStatusResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__NWriteDeviceStatusResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__NWriteDeviceStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__NWriteDeviceStatusResponse(soap, tag ? tag : "ns1:NWriteDeviceStatusResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NWriteDeviceStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NWriteDeviceStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NWriteDeviceStatusResponse * SOAP_FMAC4 soap_get_ns1__NWriteDeviceStatusResponse(struct soap *soap, ns1__NWriteDeviceStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NWriteDeviceStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__NWriteDeviceStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__NWriteDeviceStatus::sid);
	soap_default_std__string(soap, &this->ns1__NWriteDeviceStatus::strDeviceId);
	soap_default_std__string(soap, &this->ns1__NWriteDeviceStatus::strVehDetectorStatus);
	soap_default_std__string(soap, &this->ns1__NWriteDeviceStatus::strVideoDeviceStatus);
	soap_default_std__string(soap, &this->ns1__NWriteDeviceStatus::strGatherCardStatus);
	soap_default_std__string(soap, &this->ns1__NWriteDeviceStatus::strTemperature);
	soap_default_std__string(soap, &this->ns1__NWriteDeviceStatus::strReserveOne);
	soap_default_std__string(soap, &this->ns1__NWriteDeviceStatus::strReserveTwo);
	soap_default_std__string(soap, &this->ns1__NWriteDeviceStatus::strReserveThree);
}

void ns1__NWriteDeviceStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__NWriteDeviceStatus::sid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteDeviceStatus::sid);
	soap_embedded(soap, &this->ns1__NWriteDeviceStatus::strDeviceId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteDeviceStatus::strDeviceId);
	soap_embedded(soap, &this->ns1__NWriteDeviceStatus::strVehDetectorStatus, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteDeviceStatus::strVehDetectorStatus);
	soap_embedded(soap, &this->ns1__NWriteDeviceStatus::strVideoDeviceStatus, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteDeviceStatus::strVideoDeviceStatus);
	soap_embedded(soap, &this->ns1__NWriteDeviceStatus::strGatherCardStatus, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteDeviceStatus::strGatherCardStatus);
	soap_embedded(soap, &this->ns1__NWriteDeviceStatus::strTemperature, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteDeviceStatus::strTemperature);
	soap_embedded(soap, &this->ns1__NWriteDeviceStatus::strReserveOne, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteDeviceStatus::strReserveOne);
	soap_embedded(soap, &this->ns1__NWriteDeviceStatus::strReserveTwo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteDeviceStatus::strReserveTwo);
	soap_embedded(soap, &this->ns1__NWriteDeviceStatus::strReserveThree, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteDeviceStatus::strReserveThree);
#endif
}

int ns1__NWriteDeviceStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NWriteDeviceStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NWriteDeviceStatus(struct soap *soap, const char *tag, int id, const ns1__NWriteDeviceStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NWriteDeviceStatus), type))
		return soap->error;
	if (soap_out_std__string(soap, "sid", -1, &a->ns1__NWriteDeviceStatus::sid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDeviceId", -1, &a->ns1__NWriteDeviceStatus::strDeviceId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strVehDetectorStatus", -1, &a->ns1__NWriteDeviceStatus::strVehDetectorStatus, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strVideoDeviceStatus", -1, &a->ns1__NWriteDeviceStatus::strVideoDeviceStatus, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strGatherCardStatus", -1, &a->ns1__NWriteDeviceStatus::strGatherCardStatus, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strTemperature", -1, &a->ns1__NWriteDeviceStatus::strTemperature, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strReserveOne", -1, &a->ns1__NWriteDeviceStatus::strReserveOne, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strReserveTwo", -1, &a->ns1__NWriteDeviceStatus::strReserveTwo, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strReserveThree", -1, &a->ns1__NWriteDeviceStatus::strReserveThree, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__NWriteDeviceStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__NWriteDeviceStatus(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NWriteDeviceStatus * SOAP_FMAC4 soap_in_ns1__NWriteDeviceStatus(struct soap *soap, const char *tag, ns1__NWriteDeviceStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NWriteDeviceStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NWriteDeviceStatus, sizeof(ns1__NWriteDeviceStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__NWriteDeviceStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__NWriteDeviceStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sid1 = 1;
	size_t soap_flag_strDeviceId1 = 1;
	size_t soap_flag_strVehDetectorStatus1 = 1;
	size_t soap_flag_strVideoDeviceStatus1 = 1;
	size_t soap_flag_strGatherCardStatus1 = 1;
	size_t soap_flag_strTemperature1 = 1;
	size_t soap_flag_strReserveOne1 = 1;
	size_t soap_flag_strReserveTwo1 = 1;
	size_t soap_flag_strReserveThree1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sid", &a->ns1__NWriteDeviceStatus::sid, "xsd:string"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap_flag_strDeviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDeviceId", &a->ns1__NWriteDeviceStatus::strDeviceId, "xsd:string"))
				{	soap_flag_strDeviceId1--;
					continue;
				}
			}
			if (soap_flag_strVehDetectorStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strVehDetectorStatus", &a->ns1__NWriteDeviceStatus::strVehDetectorStatus, "xsd:string"))
				{	soap_flag_strVehDetectorStatus1--;
					continue;
				}
			}
			if (soap_flag_strVideoDeviceStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strVideoDeviceStatus", &a->ns1__NWriteDeviceStatus::strVideoDeviceStatus, "xsd:string"))
				{	soap_flag_strVideoDeviceStatus1--;
					continue;
				}
			}
			if (soap_flag_strGatherCardStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strGatherCardStatus", &a->ns1__NWriteDeviceStatus::strGatherCardStatus, "xsd:string"))
				{	soap_flag_strGatherCardStatus1--;
					continue;
				}
			}
			if (soap_flag_strTemperature1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strTemperature", &a->ns1__NWriteDeviceStatus::strTemperature, "xsd:string"))
				{	soap_flag_strTemperature1--;
					continue;
				}
			}
			if (soap_flag_strReserveOne1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strReserveOne", &a->ns1__NWriteDeviceStatus::strReserveOne, "xsd:string"))
				{	soap_flag_strReserveOne1--;
					continue;
				}
			}
			if (soap_flag_strReserveTwo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strReserveTwo", &a->ns1__NWriteDeviceStatus::strReserveTwo, "xsd:string"))
				{	soap_flag_strReserveTwo1--;
					continue;
				}
			}
			if (soap_flag_strReserveThree1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strReserveThree", &a->ns1__NWriteDeviceStatus::strReserveThree, "xsd:string"))
				{	soap_flag_strReserveThree1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid1 > 0 || soap_flag_strDeviceId1 > 0 || soap_flag_strVehDetectorStatus1 > 0 || soap_flag_strVideoDeviceStatus1 > 0 || soap_flag_strGatherCardStatus1 > 0 || soap_flag_strTemperature1 > 0 || soap_flag_strReserveOne1 > 0 || soap_flag_strReserveTwo1 > 0 || soap_flag_strReserveThree1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__NWriteDeviceStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NWriteDeviceStatus, SOAP_TYPE_ns1__NWriteDeviceStatus, sizeof(ns1__NWriteDeviceStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__NWriteDeviceStatus * SOAP_FMAC2 soap_instantiate_ns1__NWriteDeviceStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NWriteDeviceStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__NWriteDeviceStatus *p;
	size_t k = sizeof(ns1__NWriteDeviceStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__NWriteDeviceStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__NWriteDeviceStatus);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__NWriteDeviceStatus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__NWriteDeviceStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__NWriteDeviceStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__NWriteDeviceStatus(soap, tag ? tag : "ns1:NWriteDeviceStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NWriteDeviceStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NWriteDeviceStatus(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NWriteDeviceStatus * SOAP_FMAC4 soap_get_ns1__NWriteDeviceStatus(struct soap *soap, ns1__NWriteDeviceStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NWriteDeviceStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__WriteFluxResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__WriteFluxResponse::return_ = NULL;
}

void ns1__WriteFluxResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__WriteFluxResponse::return_);
#endif
}

int ns1__WriteFluxResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__WriteFluxResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__WriteFluxResponse(struct soap *soap, const char *tag, int id, const ns1__WriteFluxResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__WriteFluxResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->ns1__WriteFluxResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__WriteFluxResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__WriteFluxResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__WriteFluxResponse * SOAP_FMAC4 soap_in_ns1__WriteFluxResponse(struct soap *soap, const char *tag, ns1__WriteFluxResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__WriteFluxResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__WriteFluxResponse, sizeof(ns1__WriteFluxResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__WriteFluxResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__WriteFluxResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->ns1__WriteFluxResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__WriteFluxResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__WriteFluxResponse, SOAP_TYPE_ns1__WriteFluxResponse, sizeof(ns1__WriteFluxResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__WriteFluxResponse * SOAP_FMAC2 soap_instantiate_ns1__WriteFluxResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__WriteFluxResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__WriteFluxResponse *p;
	size_t k = sizeof(ns1__WriteFluxResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__WriteFluxResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__WriteFluxResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__WriteFluxResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__WriteFluxResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__WriteFluxResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__WriteFluxResponse(soap, tag ? tag : "ns1:WriteFluxResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__WriteFluxResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__WriteFluxResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__WriteFluxResponse * SOAP_FMAC4 soap_get_ns1__WriteFluxResponse(struct soap *soap, ns1__WriteFluxResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__WriteFluxResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__WriteFlux::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__WriteFlux::sid);
	soap_default_std__string(soap, &this->ns1__WriteFlux::lpszDeviceId);
	soap_default_std__string(soap, &this->ns1__WriteFlux::lpszDiretId);
	soap_default_std__string(soap, &this->ns1__WriteFlux::lpszDriveWay);
	soap_default_std__string(soap, &this->ns1__WriteFlux::lpszPeriodBegin);
	soap_default_std__string(soap, &this->ns1__WriteFlux::lpszPeriodEnd);
	soap_default_LONG64(soap, &this->ns1__WriteFlux::lFlux);
	soap_default_std__string(soap, &this->ns1__WriteFlux::lpszReserve1);
	soap_default_std__string(soap, &this->ns1__WriteFlux::lpszReserve2);
	soap_default_std__string(soap, &this->ns1__WriteFlux::lpszReserve3);
}

void ns1__WriteFlux::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__WriteFlux::sid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__WriteFlux::sid);
	soap_embedded(soap, &this->ns1__WriteFlux::lpszDeviceId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__WriteFlux::lpszDeviceId);
	soap_embedded(soap, &this->ns1__WriteFlux::lpszDiretId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__WriteFlux::lpszDiretId);
	soap_embedded(soap, &this->ns1__WriteFlux::lpszDriveWay, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__WriteFlux::lpszDriveWay);
	soap_embedded(soap, &this->ns1__WriteFlux::lpszPeriodBegin, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__WriteFlux::lpszPeriodBegin);
	soap_embedded(soap, &this->ns1__WriteFlux::lpszPeriodEnd, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__WriteFlux::lpszPeriodEnd);
	soap_embedded(soap, &this->ns1__WriteFlux::lpszReserve1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__WriteFlux::lpszReserve1);
	soap_embedded(soap, &this->ns1__WriteFlux::lpszReserve2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__WriteFlux::lpszReserve2);
	soap_embedded(soap, &this->ns1__WriteFlux::lpszReserve3, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__WriteFlux::lpszReserve3);
#endif
}

int ns1__WriteFlux::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__WriteFlux(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__WriteFlux(struct soap *soap, const char *tag, int id, const ns1__WriteFlux *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__WriteFlux), type))
		return soap->error;
	if (soap_out_std__string(soap, "sid", -1, &a->ns1__WriteFlux::sid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "lpszDeviceId", -1, &a->ns1__WriteFlux::lpszDeviceId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "lpszDiretId", -1, &a->ns1__WriteFlux::lpszDiretId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "lpszDriveWay", -1, &a->ns1__WriteFlux::lpszDriveWay, ""))
		return soap->error;
	if (soap_out_std__string(soap, "lpszPeriodBegin", -1, &a->ns1__WriteFlux::lpszPeriodBegin, ""))
		return soap->error;
	if (soap_out_std__string(soap, "lpszPeriodEnd", -1, &a->ns1__WriteFlux::lpszPeriodEnd, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lFlux", -1, &a->ns1__WriteFlux::lFlux, ""))
		return soap->error;
	if (soap_out_std__string(soap, "lpszReserve1", -1, &a->ns1__WriteFlux::lpszReserve1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "lpszReserve2", -1, &a->ns1__WriteFlux::lpszReserve2, ""))
		return soap->error;
	if (soap_out_std__string(soap, "lpszReserve3", -1, &a->ns1__WriteFlux::lpszReserve3, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__WriteFlux::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__WriteFlux(soap, tag, this, type);
}

SOAP_FMAC3 ns1__WriteFlux * SOAP_FMAC4 soap_in_ns1__WriteFlux(struct soap *soap, const char *tag, ns1__WriteFlux *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__WriteFlux*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__WriteFlux, sizeof(ns1__WriteFlux), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__WriteFlux)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__WriteFlux *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sid1 = 1;
	size_t soap_flag_lpszDeviceId1 = 1;
	size_t soap_flag_lpszDiretId1 = 1;
	size_t soap_flag_lpszDriveWay1 = 1;
	size_t soap_flag_lpszPeriodBegin1 = 1;
	size_t soap_flag_lpszPeriodEnd1 = 1;
	size_t soap_flag_lFlux1 = 1;
	size_t soap_flag_lpszReserve11 = 1;
	size_t soap_flag_lpszReserve21 = 1;
	size_t soap_flag_lpszReserve31 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sid", &a->ns1__WriteFlux::sid, "xsd:string"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap_flag_lpszDeviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "lpszDeviceId", &a->ns1__WriteFlux::lpszDeviceId, "xsd:string"))
				{	soap_flag_lpszDeviceId1--;
					continue;
				}
			}
			if (soap_flag_lpszDiretId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "lpszDiretId", &a->ns1__WriteFlux::lpszDiretId, "xsd:string"))
				{	soap_flag_lpszDiretId1--;
					continue;
				}
			}
			if (soap_flag_lpszDriveWay1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "lpszDriveWay", &a->ns1__WriteFlux::lpszDriveWay, "xsd:string"))
				{	soap_flag_lpszDriveWay1--;
					continue;
				}
			}
			if (soap_flag_lpszPeriodBegin1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "lpszPeriodBegin", &a->ns1__WriteFlux::lpszPeriodBegin, "xsd:string"))
				{	soap_flag_lpszPeriodBegin1--;
					continue;
				}
			}
			if (soap_flag_lpszPeriodEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "lpszPeriodEnd", &a->ns1__WriteFlux::lpszPeriodEnd, "xsd:string"))
				{	soap_flag_lpszPeriodEnd1--;
					continue;
				}
			}
			if (soap_flag_lFlux1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lFlux", &a->ns1__WriteFlux::lFlux, "xsd:long"))
				{	soap_flag_lFlux1--;
					continue;
				}
			}
			if (soap_flag_lpszReserve11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "lpszReserve1", &a->ns1__WriteFlux::lpszReserve1, "xsd:string"))
				{	soap_flag_lpszReserve11--;
					continue;
				}
			}
			if (soap_flag_lpszReserve21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "lpszReserve2", &a->ns1__WriteFlux::lpszReserve2, "xsd:string"))
				{	soap_flag_lpszReserve21--;
					continue;
				}
			}
			if (soap_flag_lpszReserve31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "lpszReserve3", &a->ns1__WriteFlux::lpszReserve3, "xsd:string"))
				{	soap_flag_lpszReserve31--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid1 > 0 || soap_flag_lpszDeviceId1 > 0 || soap_flag_lpszDiretId1 > 0 || soap_flag_lpszDriveWay1 > 0 || soap_flag_lpszPeriodBegin1 > 0 || soap_flag_lpszPeriodEnd1 > 0 || soap_flag_lFlux1 > 0 || soap_flag_lpszReserve11 > 0 || soap_flag_lpszReserve21 > 0 || soap_flag_lpszReserve31 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__WriteFlux *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__WriteFlux, SOAP_TYPE_ns1__WriteFlux, sizeof(ns1__WriteFlux), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__WriteFlux * SOAP_FMAC2 soap_instantiate_ns1__WriteFlux(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__WriteFlux(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__WriteFlux *p;
	size_t k = sizeof(ns1__WriteFlux);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__WriteFlux, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__WriteFlux);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__WriteFlux, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__WriteFlux location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__WriteFlux::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__WriteFlux(soap, tag ? tag : "ns1:WriteFlux", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__WriteFlux::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__WriteFlux(soap, this, tag, type);
}

SOAP_FMAC3 ns1__WriteFlux * SOAP_FMAC4 soap_get_ns1__WriteFlux(struct soap *soap, ns1__WriteFlux *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__WriteFlux(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__NSyncWriteVehicleInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__NSyncWriteVehicleInfoResponse::return_ = NULL;
}

void ns1__NSyncWriteVehicleInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__NSyncWriteVehicleInfoResponse::return_);
#endif
}

int ns1__NSyncWriteVehicleInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NSyncWriteVehicleInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NSyncWriteVehicleInfoResponse(struct soap *soap, const char *tag, int id, const ns1__NSyncWriteVehicleInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NSyncWriteVehicleInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->ns1__NSyncWriteVehicleInfoResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__NSyncWriteVehicleInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__NSyncWriteVehicleInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NSyncWriteVehicleInfoResponse * SOAP_FMAC4 soap_in_ns1__NSyncWriteVehicleInfoResponse(struct soap *soap, const char *tag, ns1__NSyncWriteVehicleInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NSyncWriteVehicleInfoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NSyncWriteVehicleInfoResponse, sizeof(ns1__NSyncWriteVehicleInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__NSyncWriteVehicleInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__NSyncWriteVehicleInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->ns1__NSyncWriteVehicleInfoResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__NSyncWriteVehicleInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NSyncWriteVehicleInfoResponse, SOAP_TYPE_ns1__NSyncWriteVehicleInfoResponse, sizeof(ns1__NSyncWriteVehicleInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__NSyncWriteVehicleInfoResponse * SOAP_FMAC2 soap_instantiate_ns1__NSyncWriteVehicleInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NSyncWriteVehicleInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__NSyncWriteVehicleInfoResponse *p;
	size_t k = sizeof(ns1__NSyncWriteVehicleInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__NSyncWriteVehicleInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__NSyncWriteVehicleInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__NSyncWriteVehicleInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__NSyncWriteVehicleInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__NSyncWriteVehicleInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__NSyncWriteVehicleInfoResponse(soap, tag ? tag : "ns1:NSyncWriteVehicleInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NSyncWriteVehicleInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NSyncWriteVehicleInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NSyncWriteVehicleInfoResponse * SOAP_FMAC4 soap_get_ns1__NSyncWriteVehicleInfoResponse(struct soap *soap, ns1__NSyncWriteVehicleInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NSyncWriteVehicleInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__NSyncWriteVehicleInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::sid);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strDeviceId);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strVehicleId);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strDeviceType);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strDirectionId);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strDriveWayId);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strLicense);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strLicenseType);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strPassDateTime);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strRedLightBeginTime);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strRedLightLast);
	soap_default_LONG64(soap, &this->ns1__NSyncWriteVehicleInfo::lSpeed);
	soap_default_LONG64(soap, &this->ns1__NSyncWriteVehicleInfo::lLargeLimitSpeed);
	soap_default_LONG64(soap, &this->ns1__NSyncWriteVehicleInfo::lMiniLimitSpeed);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strViolationType);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strViolationType2);
	soap_default_LONG64(soap, &this->ns1__NSyncWriteVehicleInfo::lCarLength);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strLicenseColor);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strCarType);
	this->ns1__NSyncWriteVehicleInfo::strPicLocalPath1.xsd__base64Binary::soap_default(soap);
	this->ns1__NSyncWriteVehicleInfo::strPicLocalPath2.xsd__base64Binary::soap_default(soap);
	this->ns1__NSyncWriteVehicleInfo::strPicLocalPath3.xsd__base64Binary::soap_default(soap);
	this->ns1__NSyncWriteVehicleInfo::strPicLocalPath4.xsd__base64Binary::soap_default(soap);
	this->ns1__NSyncWriteVehicleInfo::strPicLocalPath5.xsd__base64Binary::soap_default(soap);
	this->ns1__NSyncWriteVehicleInfo::strPicLocalPath6.xsd__base64Binary::soap_default(soap);
	this->ns1__NSyncWriteVehicleInfo::strPicLocalPath7.xsd__base64Binary::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strPicRemotePath);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strViolate);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strSendType);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strCarColor);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strReserve1);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strReserve2);
	soap_default_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strReserve3);
}

void ns1__NSyncWriteVehicleInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__NSyncWriteVehicleInfo::sid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::sid);
	soap_embedded(soap, &this->ns1__NSyncWriteVehicleInfo::strDeviceId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strDeviceId);
	soap_embedded(soap, &this->ns1__NSyncWriteVehicleInfo::strVehicleId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strVehicleId);
	soap_embedded(soap, &this->ns1__NSyncWriteVehicleInfo::strDeviceType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strDeviceType);
	soap_embedded(soap, &this->ns1__NSyncWriteVehicleInfo::strDirectionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strDirectionId);
	soap_embedded(soap, &this->ns1__NSyncWriteVehicleInfo::strDriveWayId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strDriveWayId);
	soap_embedded(soap, &this->ns1__NSyncWriteVehicleInfo::strLicense, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strLicense);
	soap_embedded(soap, &this->ns1__NSyncWriteVehicleInfo::strLicenseType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strLicenseType);
	soap_embedded(soap, &this->ns1__NSyncWriteVehicleInfo::strPassDateTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strPassDateTime);
	soap_embedded(soap, &this->ns1__NSyncWriteVehicleInfo::strRedLightBeginTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strRedLightBeginTime);
	soap_embedded(soap, &this->ns1__NSyncWriteVehicleInfo::strRedLightLast, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strRedLightLast);
	soap_embedded(soap, &this->ns1__NSyncWriteVehicleInfo::strViolationType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strViolationType);
	soap_embedded(soap, &this->ns1__NSyncWriteVehicleInfo::strViolationType2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strViolationType2);
	soap_embedded(soap, &this->ns1__NSyncWriteVehicleInfo::strLicenseColor, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strLicenseColor);
	soap_embedded(soap, &this->ns1__NSyncWriteVehicleInfo::strCarType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strCarType);
	this->ns1__NSyncWriteVehicleInfo::strPicLocalPath1.soap_serialize(soap);
	this->ns1__NSyncWriteVehicleInfo::strPicLocalPath2.soap_serialize(soap);
	this->ns1__NSyncWriteVehicleInfo::strPicLocalPath3.soap_serialize(soap);
	this->ns1__NSyncWriteVehicleInfo::strPicLocalPath4.soap_serialize(soap);
	this->ns1__NSyncWriteVehicleInfo::strPicLocalPath5.soap_serialize(soap);
	this->ns1__NSyncWriteVehicleInfo::strPicLocalPath6.soap_serialize(soap);
	this->ns1__NSyncWriteVehicleInfo::strPicLocalPath7.soap_serialize(soap);
	soap_embedded(soap, &this->ns1__NSyncWriteVehicleInfo::strPicRemotePath, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strPicRemotePath);
	soap_embedded(soap, &this->ns1__NSyncWriteVehicleInfo::strViolate, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strViolate);
	soap_embedded(soap, &this->ns1__NSyncWriteVehicleInfo::strSendType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strSendType);
	soap_embedded(soap, &this->ns1__NSyncWriteVehicleInfo::strCarColor, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strCarColor);
	soap_embedded(soap, &this->ns1__NSyncWriteVehicleInfo::strReserve1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strReserve1);
	soap_embedded(soap, &this->ns1__NSyncWriteVehicleInfo::strReserve2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strReserve2);
	soap_embedded(soap, &this->ns1__NSyncWriteVehicleInfo::strReserve3, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NSyncWriteVehicleInfo::strReserve3);
#endif
}

int ns1__NSyncWriteVehicleInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NSyncWriteVehicleInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NSyncWriteVehicleInfo(struct soap *soap, const char *tag, int id, const ns1__NSyncWriteVehicleInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NSyncWriteVehicleInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "sid", -1, &a->ns1__NSyncWriteVehicleInfo::sid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDeviceId", -1, &a->ns1__NSyncWriteVehicleInfo::strDeviceId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strVehicleId", -1, &a->ns1__NSyncWriteVehicleInfo::strVehicleId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDeviceType", -1, &a->ns1__NSyncWriteVehicleInfo::strDeviceType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDirectionId", -1, &a->ns1__NSyncWriteVehicleInfo::strDirectionId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDriveWayId", -1, &a->ns1__NSyncWriteVehicleInfo::strDriveWayId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strLicense", -1, &a->ns1__NSyncWriteVehicleInfo::strLicense, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strLicenseType", -1, &a->ns1__NSyncWriteVehicleInfo::strLicenseType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPassDateTime", -1, &a->ns1__NSyncWriteVehicleInfo::strPassDateTime, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strRedLightBeginTime", -1, &a->ns1__NSyncWriteVehicleInfo::strRedLightBeginTime, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strRedLightLast", -1, &a->ns1__NSyncWriteVehicleInfo::strRedLightLast, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lSpeed", -1, &a->ns1__NSyncWriteVehicleInfo::lSpeed, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lLargeLimitSpeed", -1, &a->ns1__NSyncWriteVehicleInfo::lLargeLimitSpeed, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lMiniLimitSpeed", -1, &a->ns1__NSyncWriteVehicleInfo::lMiniLimitSpeed, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strViolationType", -1, &a->ns1__NSyncWriteVehicleInfo::strViolationType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strViolationType2", -1, &a->ns1__NSyncWriteVehicleInfo::strViolationType2, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lCarLength", -1, &a->ns1__NSyncWriteVehicleInfo::lCarLength, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strLicenseColor", -1, &a->ns1__NSyncWriteVehicleInfo::strLicenseColor, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strCarType", -1, &a->ns1__NSyncWriteVehicleInfo::strCarType, ""))
		return soap->error;
	if ((a->ns1__NSyncWriteVehicleInfo::strPicLocalPath1).soap_out(soap, "strPicLocalPath1", -1, ""))
		return soap->error;
	if ((a->ns1__NSyncWriteVehicleInfo::strPicLocalPath2).soap_out(soap, "strPicLocalPath2", -1, ""))
		return soap->error;
	if ((a->ns1__NSyncWriteVehicleInfo::strPicLocalPath3).soap_out(soap, "strPicLocalPath3", -1, ""))
		return soap->error;
	if ((a->ns1__NSyncWriteVehicleInfo::strPicLocalPath4).soap_out(soap, "strPicLocalPath4", -1, ""))
		return soap->error;
	if ((a->ns1__NSyncWriteVehicleInfo::strPicLocalPath5).soap_out(soap, "strPicLocalPath5", -1, ""))
		return soap->error;
	if ((a->ns1__NSyncWriteVehicleInfo::strPicLocalPath6).soap_out(soap, "strPicLocalPath6", -1, ""))
		return soap->error;
	if ((a->ns1__NSyncWriteVehicleInfo::strPicLocalPath7).soap_out(soap, "strPicLocalPath7", -1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicRemotePath", -1, &a->ns1__NSyncWriteVehicleInfo::strPicRemotePath, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strViolate", -1, &a->ns1__NSyncWriteVehicleInfo::strViolate, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strSendType", -1, &a->ns1__NSyncWriteVehicleInfo::strSendType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strCarColor", -1, &a->ns1__NSyncWriteVehicleInfo::strCarColor, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strReserve1", -1, &a->ns1__NSyncWriteVehicleInfo::strReserve1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strReserve2", -1, &a->ns1__NSyncWriteVehicleInfo::strReserve2, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strReserve3", -1, &a->ns1__NSyncWriteVehicleInfo::strReserve3, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__NSyncWriteVehicleInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__NSyncWriteVehicleInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NSyncWriteVehicleInfo * SOAP_FMAC4 soap_in_ns1__NSyncWriteVehicleInfo(struct soap *soap, const char *tag, ns1__NSyncWriteVehicleInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NSyncWriteVehicleInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NSyncWriteVehicleInfo, sizeof(ns1__NSyncWriteVehicleInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__NSyncWriteVehicleInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__NSyncWriteVehicleInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sid1 = 1;
	size_t soap_flag_strDeviceId1 = 1;
	size_t soap_flag_strVehicleId1 = 1;
	size_t soap_flag_strDeviceType1 = 1;
	size_t soap_flag_strDirectionId1 = 1;
	size_t soap_flag_strDriveWayId1 = 1;
	size_t soap_flag_strLicense1 = 1;
	size_t soap_flag_strLicenseType1 = 1;
	size_t soap_flag_strPassDateTime1 = 1;
	size_t soap_flag_strRedLightBeginTime1 = 1;
	size_t soap_flag_strRedLightLast1 = 1;
	size_t soap_flag_lSpeed1 = 1;
	size_t soap_flag_lLargeLimitSpeed1 = 1;
	size_t soap_flag_lMiniLimitSpeed1 = 1;
	size_t soap_flag_strViolationType1 = 1;
	size_t soap_flag_strViolationType21 = 1;
	size_t soap_flag_lCarLength1 = 1;
	size_t soap_flag_strLicenseColor1 = 1;
	size_t soap_flag_strCarType1 = 1;
	size_t soap_flag_strPicLocalPath11 = 1;
	size_t soap_flag_strPicLocalPath21 = 1;
	size_t soap_flag_strPicLocalPath31 = 1;
	size_t soap_flag_strPicLocalPath41 = 1;
	size_t soap_flag_strPicLocalPath51 = 1;
	size_t soap_flag_strPicLocalPath61 = 1;
	size_t soap_flag_strPicLocalPath71 = 1;
	size_t soap_flag_strPicRemotePath1 = 1;
	size_t soap_flag_strViolate1 = 1;
	size_t soap_flag_strSendType1 = 1;
	size_t soap_flag_strCarColor1 = 1;
	size_t soap_flag_strReserve11 = 1;
	size_t soap_flag_strReserve21 = 1;
	size_t soap_flag_strReserve31 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sid", &a->ns1__NSyncWriteVehicleInfo::sid, "xsd:string"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap_flag_strDeviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDeviceId", &a->ns1__NSyncWriteVehicleInfo::strDeviceId, "xsd:string"))
				{	soap_flag_strDeviceId1--;
					continue;
				}
			}
			if (soap_flag_strVehicleId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strVehicleId", &a->ns1__NSyncWriteVehicleInfo::strVehicleId, "xsd:string"))
				{	soap_flag_strVehicleId1--;
					continue;
				}
			}
			if (soap_flag_strDeviceType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDeviceType", &a->ns1__NSyncWriteVehicleInfo::strDeviceType, "xsd:string"))
				{	soap_flag_strDeviceType1--;
					continue;
				}
			}
			if (soap_flag_strDirectionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDirectionId", &a->ns1__NSyncWriteVehicleInfo::strDirectionId, "xsd:string"))
				{	soap_flag_strDirectionId1--;
					continue;
				}
			}
			if (soap_flag_strDriveWayId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDriveWayId", &a->ns1__NSyncWriteVehicleInfo::strDriveWayId, "xsd:string"))
				{	soap_flag_strDriveWayId1--;
					continue;
				}
			}
			if (soap_flag_strLicense1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strLicense", &a->ns1__NSyncWriteVehicleInfo::strLicense, "xsd:string"))
				{	soap_flag_strLicense1--;
					continue;
				}
			}
			if (soap_flag_strLicenseType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strLicenseType", &a->ns1__NSyncWriteVehicleInfo::strLicenseType, "xsd:string"))
				{	soap_flag_strLicenseType1--;
					continue;
				}
			}
			if (soap_flag_strPassDateTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPassDateTime", &a->ns1__NSyncWriteVehicleInfo::strPassDateTime, "xsd:string"))
				{	soap_flag_strPassDateTime1--;
					continue;
				}
			}
			if (soap_flag_strRedLightBeginTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strRedLightBeginTime", &a->ns1__NSyncWriteVehicleInfo::strRedLightBeginTime, "xsd:string"))
				{	soap_flag_strRedLightBeginTime1--;
					continue;
				}
			}
			if (soap_flag_strRedLightLast1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strRedLightLast", &a->ns1__NSyncWriteVehicleInfo::strRedLightLast, "xsd:string"))
				{	soap_flag_strRedLightLast1--;
					continue;
				}
			}
			if (soap_flag_lSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lSpeed", &a->ns1__NSyncWriteVehicleInfo::lSpeed, "xsd:long"))
				{	soap_flag_lSpeed1--;
					continue;
				}
			}
			if (soap_flag_lLargeLimitSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lLargeLimitSpeed", &a->ns1__NSyncWriteVehicleInfo::lLargeLimitSpeed, "xsd:long"))
				{	soap_flag_lLargeLimitSpeed1--;
					continue;
				}
			}
			if (soap_flag_lMiniLimitSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lMiniLimitSpeed", &a->ns1__NSyncWriteVehicleInfo::lMiniLimitSpeed, "xsd:long"))
				{	soap_flag_lMiniLimitSpeed1--;
					continue;
				}
			}
			if (soap_flag_strViolationType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strViolationType", &a->ns1__NSyncWriteVehicleInfo::strViolationType, "xsd:string"))
				{	soap_flag_strViolationType1--;
					continue;
				}
			}
			if (soap_flag_strViolationType21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strViolationType2", &a->ns1__NSyncWriteVehicleInfo::strViolationType2, "xsd:string"))
				{	soap_flag_strViolationType21--;
					continue;
				}
			}
			if (soap_flag_lCarLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lCarLength", &a->ns1__NSyncWriteVehicleInfo::lCarLength, "xsd:long"))
				{	soap_flag_lCarLength1--;
					continue;
				}
			}
			if (soap_flag_strLicenseColor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strLicenseColor", &a->ns1__NSyncWriteVehicleInfo::strLicenseColor, "xsd:string"))
				{	soap_flag_strLicenseColor1--;
					continue;
				}
			}
			if (soap_flag_strCarType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strCarType", &a->ns1__NSyncWriteVehicleInfo::strCarType, "xsd:string"))
				{	soap_flag_strCarType1--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath11 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__NSyncWriteVehicleInfo::strPicLocalPath1).soap_in(soap, "strPicLocalPath1", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath11--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath21 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__NSyncWriteVehicleInfo::strPicLocalPath2).soap_in(soap, "strPicLocalPath2", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath21--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath31 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__NSyncWriteVehicleInfo::strPicLocalPath3).soap_in(soap, "strPicLocalPath3", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath31--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath41 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__NSyncWriteVehicleInfo::strPicLocalPath4).soap_in(soap, "strPicLocalPath4", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath41--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath51 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__NSyncWriteVehicleInfo::strPicLocalPath5).soap_in(soap, "strPicLocalPath5", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath51--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath61 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__NSyncWriteVehicleInfo::strPicLocalPath6).soap_in(soap, "strPicLocalPath6", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath61--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath71 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__NSyncWriteVehicleInfo::strPicLocalPath7).soap_in(soap, "strPicLocalPath7", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath71--;
					continue;
				}
			}
			if (soap_flag_strPicRemotePath1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicRemotePath", &a->ns1__NSyncWriteVehicleInfo::strPicRemotePath, "xsd:string"))
				{	soap_flag_strPicRemotePath1--;
					continue;
				}
			}
			if (soap_flag_strViolate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strViolate", &a->ns1__NSyncWriteVehicleInfo::strViolate, "xsd:string"))
				{	soap_flag_strViolate1--;
					continue;
				}
			}
			if (soap_flag_strSendType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strSendType", &a->ns1__NSyncWriteVehicleInfo::strSendType, "xsd:string"))
				{	soap_flag_strSendType1--;
					continue;
				}
			}
			if (soap_flag_strCarColor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strCarColor", &a->ns1__NSyncWriteVehicleInfo::strCarColor, "xsd:string"))
				{	soap_flag_strCarColor1--;
					continue;
				}
			}
			if (soap_flag_strReserve11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strReserve1", &a->ns1__NSyncWriteVehicleInfo::strReserve1, "xsd:string"))
				{	soap_flag_strReserve11--;
					continue;
				}
			}
			if (soap_flag_strReserve21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strReserve2", &a->ns1__NSyncWriteVehicleInfo::strReserve2, "xsd:string"))
				{	soap_flag_strReserve21--;
					continue;
				}
			}
			if (soap_flag_strReserve31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strReserve3", &a->ns1__NSyncWriteVehicleInfo::strReserve3, "xsd:string"))
				{	soap_flag_strReserve31--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid1 > 0 || soap_flag_strDeviceId1 > 0 || soap_flag_strVehicleId1 > 0 || soap_flag_strDeviceType1 > 0 || soap_flag_strDirectionId1 > 0 || soap_flag_strDriveWayId1 > 0 || soap_flag_strLicense1 > 0 || soap_flag_strLicenseType1 > 0 || soap_flag_strPassDateTime1 > 0 || soap_flag_strRedLightBeginTime1 > 0 || soap_flag_strRedLightLast1 > 0 || soap_flag_lSpeed1 > 0 || soap_flag_lLargeLimitSpeed1 > 0 || soap_flag_lMiniLimitSpeed1 > 0 || soap_flag_strViolationType1 > 0 || soap_flag_strViolationType21 > 0 || soap_flag_lCarLength1 > 0 || soap_flag_strLicenseColor1 > 0 || soap_flag_strCarType1 > 0 || soap_flag_strPicLocalPath11 > 0 || soap_flag_strPicLocalPath21 > 0 || soap_flag_strPicLocalPath31 > 0 || soap_flag_strPicLocalPath41 > 0 || soap_flag_strPicLocalPath51 > 0 || soap_flag_strPicLocalPath61 > 0 || soap_flag_strPicLocalPath71 > 0 || soap_flag_strPicRemotePath1 > 0 || soap_flag_strViolate1 > 0 || soap_flag_strSendType1 > 0 || soap_flag_strCarColor1 > 0 || soap_flag_strReserve11 > 0 || soap_flag_strReserve21 > 0 || soap_flag_strReserve31 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__NSyncWriteVehicleInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NSyncWriteVehicleInfo, SOAP_TYPE_ns1__NSyncWriteVehicleInfo, sizeof(ns1__NSyncWriteVehicleInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__NSyncWriteVehicleInfo * SOAP_FMAC2 soap_instantiate_ns1__NSyncWriteVehicleInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NSyncWriteVehicleInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__NSyncWriteVehicleInfo *p;
	size_t k = sizeof(ns1__NSyncWriteVehicleInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__NSyncWriteVehicleInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__NSyncWriteVehicleInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__NSyncWriteVehicleInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__NSyncWriteVehicleInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__NSyncWriteVehicleInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__NSyncWriteVehicleInfo(soap, tag ? tag : "ns1:NSyncWriteVehicleInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NSyncWriteVehicleInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NSyncWriteVehicleInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NSyncWriteVehicleInfo * SOAP_FMAC4 soap_get_ns1__NSyncWriteVehicleInfo(struct soap *soap, ns1__NSyncWriteVehicleInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NSyncWriteVehicleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__NWriteVehicleInfoExResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__NWriteVehicleInfoExResponse::return_ = NULL;
}

void ns1__NWriteVehicleInfoExResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__NWriteVehicleInfoExResponse::return_);
#endif
}

int ns1__NWriteVehicleInfoExResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NWriteVehicleInfoExResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NWriteVehicleInfoExResponse(struct soap *soap, const char *tag, int id, const ns1__NWriteVehicleInfoExResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NWriteVehicleInfoExResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->ns1__NWriteVehicleInfoExResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__NWriteVehicleInfoExResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__NWriteVehicleInfoExResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NWriteVehicleInfoExResponse * SOAP_FMAC4 soap_in_ns1__NWriteVehicleInfoExResponse(struct soap *soap, const char *tag, ns1__NWriteVehicleInfoExResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NWriteVehicleInfoExResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NWriteVehicleInfoExResponse, sizeof(ns1__NWriteVehicleInfoExResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__NWriteVehicleInfoExResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__NWriteVehicleInfoExResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->ns1__NWriteVehicleInfoExResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__NWriteVehicleInfoExResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NWriteVehicleInfoExResponse, SOAP_TYPE_ns1__NWriteVehicleInfoExResponse, sizeof(ns1__NWriteVehicleInfoExResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__NWriteVehicleInfoExResponse * SOAP_FMAC2 soap_instantiate_ns1__NWriteVehicleInfoExResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NWriteVehicleInfoExResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__NWriteVehicleInfoExResponse *p;
	size_t k = sizeof(ns1__NWriteVehicleInfoExResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__NWriteVehicleInfoExResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__NWriteVehicleInfoExResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__NWriteVehicleInfoExResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__NWriteVehicleInfoExResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__NWriteVehicleInfoExResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__NWriteVehicleInfoExResponse(soap, tag ? tag : "ns1:NWriteVehicleInfoExResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NWriteVehicleInfoExResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NWriteVehicleInfoExResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NWriteVehicleInfoExResponse * SOAP_FMAC4 soap_get_ns1__NWriteVehicleInfoExResponse(struct soap *soap, ns1__NWriteVehicleInfoExResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NWriteVehicleInfoExResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__NWriteVehicleInfoEx::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::sid);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strDeviceId);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strVehicleId);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strDeviceType);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strDirectionId);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strDriveWayId);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strLicense);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strLicenseType);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strPassDateTime);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strRedLightBeginTime);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strRedLightLast);
	soap_default_LONG64(soap, &this->ns1__NWriteVehicleInfoEx::lSpeed);
	soap_default_LONG64(soap, &this->ns1__NWriteVehicleInfoEx::lLargeLimitSpeed);
	soap_default_LONG64(soap, &this->ns1__NWriteVehicleInfoEx::lMiniLimitSpeed);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strViolationType);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strViolationType2);
	soap_default_LONG64(soap, &this->ns1__NWriteVehicleInfoEx::lCarLength);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strLicenseColor);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strCarType);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strPicLocalPath1);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strPicLocalPath2);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strPicLocalPath3);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strPicLocalPath4);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strPicLocalPath5);
	this->ns1__NWriteVehicleInfoEx::strPicLocalPath6.xsd__base64Binary::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strPicLocalPath7);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strPicRemotePath);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strViolate);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strSendType);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strCarColor);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strReserve1);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strReserve2);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strReserve3);
}

void ns1__NWriteVehicleInfoEx::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::sid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::sid);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strDeviceId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strDeviceId);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strVehicleId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strVehicleId);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strDeviceType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strDeviceType);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strDirectionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strDirectionId);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strDriveWayId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strDriveWayId);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strLicense, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strLicense);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strLicenseType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strLicenseType);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strPassDateTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strPassDateTime);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strRedLightBeginTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strRedLightBeginTime);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strRedLightLast, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strRedLightLast);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strViolationType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strViolationType);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strViolationType2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strViolationType2);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strLicenseColor, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strLicenseColor);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strCarType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strCarType);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strPicLocalPath1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strPicLocalPath1);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strPicLocalPath2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strPicLocalPath2);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strPicLocalPath3, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strPicLocalPath3);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strPicLocalPath4, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strPicLocalPath4);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strPicLocalPath5, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strPicLocalPath5);
	this->ns1__NWriteVehicleInfoEx::strPicLocalPath6.soap_serialize(soap);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strPicLocalPath7, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strPicLocalPath7);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strPicRemotePath, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strPicRemotePath);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strViolate, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strViolate);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strSendType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strSendType);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strCarColor, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strCarColor);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strReserve1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strReserve1);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strReserve2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strReserve2);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfoEx::strReserve3, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfoEx::strReserve3);
#endif
}

int ns1__NWriteVehicleInfoEx::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NWriteVehicleInfoEx(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NWriteVehicleInfoEx(struct soap *soap, const char *tag, int id, const ns1__NWriteVehicleInfoEx *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NWriteVehicleInfoEx), type))
		return soap->error;
	if (soap_out_std__string(soap, "sid", -1, &a->ns1__NWriteVehicleInfoEx::sid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDeviceId", -1, &a->ns1__NWriteVehicleInfoEx::strDeviceId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strVehicleId", -1, &a->ns1__NWriteVehicleInfoEx::strVehicleId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDeviceType", -1, &a->ns1__NWriteVehicleInfoEx::strDeviceType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDirectionId", -1, &a->ns1__NWriteVehicleInfoEx::strDirectionId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDriveWayId", -1, &a->ns1__NWriteVehicleInfoEx::strDriveWayId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strLicense", -1, &a->ns1__NWriteVehicleInfoEx::strLicense, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strLicenseType", -1, &a->ns1__NWriteVehicleInfoEx::strLicenseType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPassDateTime", -1, &a->ns1__NWriteVehicleInfoEx::strPassDateTime, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strRedLightBeginTime", -1, &a->ns1__NWriteVehicleInfoEx::strRedLightBeginTime, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strRedLightLast", -1, &a->ns1__NWriteVehicleInfoEx::strRedLightLast, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lSpeed", -1, &a->ns1__NWriteVehicleInfoEx::lSpeed, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lLargeLimitSpeed", -1, &a->ns1__NWriteVehicleInfoEx::lLargeLimitSpeed, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lMiniLimitSpeed", -1, &a->ns1__NWriteVehicleInfoEx::lMiniLimitSpeed, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strViolationType", -1, &a->ns1__NWriteVehicleInfoEx::strViolationType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strViolationType2", -1, &a->ns1__NWriteVehicleInfoEx::strViolationType2, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lCarLength", -1, &a->ns1__NWriteVehicleInfoEx::lCarLength, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strLicenseColor", -1, &a->ns1__NWriteVehicleInfoEx::strLicenseColor, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strCarType", -1, &a->ns1__NWriteVehicleInfoEx::strCarType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath1", -1, &a->ns1__NWriteVehicleInfoEx::strPicLocalPath1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath2", -1, &a->ns1__NWriteVehicleInfoEx::strPicLocalPath2, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath3", -1, &a->ns1__NWriteVehicleInfoEx::strPicLocalPath3, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath4", -1, &a->ns1__NWriteVehicleInfoEx::strPicLocalPath4, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath5", -1, &a->ns1__NWriteVehicleInfoEx::strPicLocalPath5, ""))
		return soap->error;
	if ((a->ns1__NWriteVehicleInfoEx::strPicLocalPath6).soap_out(soap, "strPicLocalPath6", -1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath7", -1, &a->ns1__NWriteVehicleInfoEx::strPicLocalPath7, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicRemotePath", -1, &a->ns1__NWriteVehicleInfoEx::strPicRemotePath, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strViolate", -1, &a->ns1__NWriteVehicleInfoEx::strViolate, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strSendType", -1, &a->ns1__NWriteVehicleInfoEx::strSendType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strCarColor", -1, &a->ns1__NWriteVehicleInfoEx::strCarColor, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strReserve1", -1, &a->ns1__NWriteVehicleInfoEx::strReserve1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strReserve2", -1, &a->ns1__NWriteVehicleInfoEx::strReserve2, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strReserve3", -1, &a->ns1__NWriteVehicleInfoEx::strReserve3, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__NWriteVehicleInfoEx::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__NWriteVehicleInfoEx(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NWriteVehicleInfoEx * SOAP_FMAC4 soap_in_ns1__NWriteVehicleInfoEx(struct soap *soap, const char *tag, ns1__NWriteVehicleInfoEx *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NWriteVehicleInfoEx*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NWriteVehicleInfoEx, sizeof(ns1__NWriteVehicleInfoEx), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__NWriteVehicleInfoEx)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__NWriteVehicleInfoEx *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sid1 = 1;
	size_t soap_flag_strDeviceId1 = 1;
	size_t soap_flag_strVehicleId1 = 1;
	size_t soap_flag_strDeviceType1 = 1;
	size_t soap_flag_strDirectionId1 = 1;
	size_t soap_flag_strDriveWayId1 = 1;
	size_t soap_flag_strLicense1 = 1;
	size_t soap_flag_strLicenseType1 = 1;
	size_t soap_flag_strPassDateTime1 = 1;
	size_t soap_flag_strRedLightBeginTime1 = 1;
	size_t soap_flag_strRedLightLast1 = 1;
	size_t soap_flag_lSpeed1 = 1;
	size_t soap_flag_lLargeLimitSpeed1 = 1;
	size_t soap_flag_lMiniLimitSpeed1 = 1;
	size_t soap_flag_strViolationType1 = 1;
	size_t soap_flag_strViolationType21 = 1;
	size_t soap_flag_lCarLength1 = 1;
	size_t soap_flag_strLicenseColor1 = 1;
	size_t soap_flag_strCarType1 = 1;
	size_t soap_flag_strPicLocalPath11 = 1;
	size_t soap_flag_strPicLocalPath21 = 1;
	size_t soap_flag_strPicLocalPath31 = 1;
	size_t soap_flag_strPicLocalPath41 = 1;
	size_t soap_flag_strPicLocalPath51 = 1;
	size_t soap_flag_strPicLocalPath61 = 1;
	size_t soap_flag_strPicLocalPath71 = 1;
	size_t soap_flag_strPicRemotePath1 = 1;
	size_t soap_flag_strViolate1 = 1;
	size_t soap_flag_strSendType1 = 1;
	size_t soap_flag_strCarColor1 = 1;
	size_t soap_flag_strReserve11 = 1;
	size_t soap_flag_strReserve21 = 1;
	size_t soap_flag_strReserve31 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sid", &a->ns1__NWriteVehicleInfoEx::sid, "xsd:string"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap_flag_strDeviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDeviceId", &a->ns1__NWriteVehicleInfoEx::strDeviceId, "xsd:string"))
				{	soap_flag_strDeviceId1--;
					continue;
				}
			}
			if (soap_flag_strVehicleId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strVehicleId", &a->ns1__NWriteVehicleInfoEx::strVehicleId, "xsd:string"))
				{	soap_flag_strVehicleId1--;
					continue;
				}
			}
			if (soap_flag_strDeviceType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDeviceType", &a->ns1__NWriteVehicleInfoEx::strDeviceType, "xsd:string"))
				{	soap_flag_strDeviceType1--;
					continue;
				}
			}
			if (soap_flag_strDirectionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDirectionId", &a->ns1__NWriteVehicleInfoEx::strDirectionId, "xsd:string"))
				{	soap_flag_strDirectionId1--;
					continue;
				}
			}
			if (soap_flag_strDriveWayId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDriveWayId", &a->ns1__NWriteVehicleInfoEx::strDriveWayId, "xsd:string"))
				{	soap_flag_strDriveWayId1--;
					continue;
				}
			}
			if (soap_flag_strLicense1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strLicense", &a->ns1__NWriteVehicleInfoEx::strLicense, "xsd:string"))
				{	soap_flag_strLicense1--;
					continue;
				}
			}
			if (soap_flag_strLicenseType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strLicenseType", &a->ns1__NWriteVehicleInfoEx::strLicenseType, "xsd:string"))
				{	soap_flag_strLicenseType1--;
					continue;
				}
			}
			if (soap_flag_strPassDateTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPassDateTime", &a->ns1__NWriteVehicleInfoEx::strPassDateTime, "xsd:string"))
				{	soap_flag_strPassDateTime1--;
					continue;
				}
			}
			if (soap_flag_strRedLightBeginTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strRedLightBeginTime", &a->ns1__NWriteVehicleInfoEx::strRedLightBeginTime, "xsd:string"))
				{	soap_flag_strRedLightBeginTime1--;
					continue;
				}
			}
			if (soap_flag_strRedLightLast1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strRedLightLast", &a->ns1__NWriteVehicleInfoEx::strRedLightLast, "xsd:string"))
				{	soap_flag_strRedLightLast1--;
					continue;
				}
			}
			if (soap_flag_lSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lSpeed", &a->ns1__NWriteVehicleInfoEx::lSpeed, "xsd:long"))
				{	soap_flag_lSpeed1--;
					continue;
				}
			}
			if (soap_flag_lLargeLimitSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lLargeLimitSpeed", &a->ns1__NWriteVehicleInfoEx::lLargeLimitSpeed, "xsd:long"))
				{	soap_flag_lLargeLimitSpeed1--;
					continue;
				}
			}
			if (soap_flag_lMiniLimitSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lMiniLimitSpeed", &a->ns1__NWriteVehicleInfoEx::lMiniLimitSpeed, "xsd:long"))
				{	soap_flag_lMiniLimitSpeed1--;
					continue;
				}
			}
			if (soap_flag_strViolationType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strViolationType", &a->ns1__NWriteVehicleInfoEx::strViolationType, "xsd:string"))
				{	soap_flag_strViolationType1--;
					continue;
				}
			}
			if (soap_flag_strViolationType21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strViolationType2", &a->ns1__NWriteVehicleInfoEx::strViolationType2, "xsd:string"))
				{	soap_flag_strViolationType21--;
					continue;
				}
			}
			if (soap_flag_lCarLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lCarLength", &a->ns1__NWriteVehicleInfoEx::lCarLength, "xsd:long"))
				{	soap_flag_lCarLength1--;
					continue;
				}
			}
			if (soap_flag_strLicenseColor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strLicenseColor", &a->ns1__NWriteVehicleInfoEx::strLicenseColor, "xsd:string"))
				{	soap_flag_strLicenseColor1--;
					continue;
				}
			}
			if (soap_flag_strCarType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strCarType", &a->ns1__NWriteVehicleInfoEx::strCarType, "xsd:string"))
				{	soap_flag_strCarType1--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath1", &a->ns1__NWriteVehicleInfoEx::strPicLocalPath1, "xsd:string"))
				{	soap_flag_strPicLocalPath11--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath2", &a->ns1__NWriteVehicleInfoEx::strPicLocalPath2, "xsd:string"))
				{	soap_flag_strPicLocalPath21--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath3", &a->ns1__NWriteVehicleInfoEx::strPicLocalPath3, "xsd:string"))
				{	soap_flag_strPicLocalPath31--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath4", &a->ns1__NWriteVehicleInfoEx::strPicLocalPath4, "xsd:string"))
				{	soap_flag_strPicLocalPath41--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath5", &a->ns1__NWriteVehicleInfoEx::strPicLocalPath5, "xsd:string"))
				{	soap_flag_strPicLocalPath51--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath61 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__NWriteVehicleInfoEx::strPicLocalPath6).soap_in(soap, "strPicLocalPath6", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath61--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath71 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath7", &a->ns1__NWriteVehicleInfoEx::strPicLocalPath7, "xsd:string"))
				{	soap_flag_strPicLocalPath71--;
					continue;
				}
			}
			if (soap_flag_strPicRemotePath1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicRemotePath", &a->ns1__NWriteVehicleInfoEx::strPicRemotePath, "xsd:string"))
				{	soap_flag_strPicRemotePath1--;
					continue;
				}
			}
			if (soap_flag_strViolate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strViolate", &a->ns1__NWriteVehicleInfoEx::strViolate, "xsd:string"))
				{	soap_flag_strViolate1--;
					continue;
				}
			}
			if (soap_flag_strSendType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strSendType", &a->ns1__NWriteVehicleInfoEx::strSendType, "xsd:string"))
				{	soap_flag_strSendType1--;
					continue;
				}
			}
			if (soap_flag_strCarColor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strCarColor", &a->ns1__NWriteVehicleInfoEx::strCarColor, "xsd:string"))
				{	soap_flag_strCarColor1--;
					continue;
				}
			}
			if (soap_flag_strReserve11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strReserve1", &a->ns1__NWriteVehicleInfoEx::strReserve1, "xsd:string"))
				{	soap_flag_strReserve11--;
					continue;
				}
			}
			if (soap_flag_strReserve21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strReserve2", &a->ns1__NWriteVehicleInfoEx::strReserve2, "xsd:string"))
				{	soap_flag_strReserve21--;
					continue;
				}
			}
			if (soap_flag_strReserve31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strReserve3", &a->ns1__NWriteVehicleInfoEx::strReserve3, "xsd:string"))
				{	soap_flag_strReserve31--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid1 > 0 || soap_flag_strDeviceId1 > 0 || soap_flag_strVehicleId1 > 0 || soap_flag_strDeviceType1 > 0 || soap_flag_strDirectionId1 > 0 || soap_flag_strDriveWayId1 > 0 || soap_flag_strLicense1 > 0 || soap_flag_strLicenseType1 > 0 || soap_flag_strPassDateTime1 > 0 || soap_flag_strRedLightBeginTime1 > 0 || soap_flag_strRedLightLast1 > 0 || soap_flag_lSpeed1 > 0 || soap_flag_lLargeLimitSpeed1 > 0 || soap_flag_lMiniLimitSpeed1 > 0 || soap_flag_strViolationType1 > 0 || soap_flag_strViolationType21 > 0 || soap_flag_lCarLength1 > 0 || soap_flag_strLicenseColor1 > 0 || soap_flag_strCarType1 > 0 || soap_flag_strPicLocalPath11 > 0 || soap_flag_strPicLocalPath21 > 0 || soap_flag_strPicLocalPath31 > 0 || soap_flag_strPicLocalPath41 > 0 || soap_flag_strPicLocalPath51 > 0 || soap_flag_strPicLocalPath61 > 0 || soap_flag_strPicLocalPath71 > 0 || soap_flag_strPicRemotePath1 > 0 || soap_flag_strViolate1 > 0 || soap_flag_strSendType1 > 0 || soap_flag_strCarColor1 > 0 || soap_flag_strReserve11 > 0 || soap_flag_strReserve21 > 0 || soap_flag_strReserve31 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__NWriteVehicleInfoEx *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NWriteVehicleInfoEx, SOAP_TYPE_ns1__NWriteVehicleInfoEx, sizeof(ns1__NWriteVehicleInfoEx), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__NWriteVehicleInfoEx * SOAP_FMAC2 soap_instantiate_ns1__NWriteVehicleInfoEx(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NWriteVehicleInfoEx(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__NWriteVehicleInfoEx *p;
	size_t k = sizeof(ns1__NWriteVehicleInfoEx);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__NWriteVehicleInfoEx, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__NWriteVehicleInfoEx);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__NWriteVehicleInfoEx, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__NWriteVehicleInfoEx location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__NWriteVehicleInfoEx::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__NWriteVehicleInfoEx(soap, tag ? tag : "ns1:NWriteVehicleInfoEx", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NWriteVehicleInfoEx::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NWriteVehicleInfoEx(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NWriteVehicleInfoEx * SOAP_FMAC4 soap_get_ns1__NWriteVehicleInfoEx(struct soap *soap, ns1__NWriteVehicleInfoEx *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NWriteVehicleInfoEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__NWriteVehicleInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__NWriteVehicleInfoResponse::return_ = NULL;
}

void ns1__NWriteVehicleInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__NWriteVehicleInfoResponse::return_);
#endif
}

int ns1__NWriteVehicleInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NWriteVehicleInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NWriteVehicleInfoResponse(struct soap *soap, const char *tag, int id, const ns1__NWriteVehicleInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NWriteVehicleInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->ns1__NWriteVehicleInfoResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__NWriteVehicleInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__NWriteVehicleInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NWriteVehicleInfoResponse * SOAP_FMAC4 soap_in_ns1__NWriteVehicleInfoResponse(struct soap *soap, const char *tag, ns1__NWriteVehicleInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NWriteVehicleInfoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NWriteVehicleInfoResponse, sizeof(ns1__NWriteVehicleInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__NWriteVehicleInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__NWriteVehicleInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->ns1__NWriteVehicleInfoResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__NWriteVehicleInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NWriteVehicleInfoResponse, SOAP_TYPE_ns1__NWriteVehicleInfoResponse, sizeof(ns1__NWriteVehicleInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__NWriteVehicleInfoResponse * SOAP_FMAC2 soap_instantiate_ns1__NWriteVehicleInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NWriteVehicleInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__NWriteVehicleInfoResponse *p;
	size_t k = sizeof(ns1__NWriteVehicleInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__NWriteVehicleInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__NWriteVehicleInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__NWriteVehicleInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__NWriteVehicleInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__NWriteVehicleInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__NWriteVehicleInfoResponse(soap, tag ? tag : "ns1:NWriteVehicleInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NWriteVehicleInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NWriteVehicleInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NWriteVehicleInfoResponse * SOAP_FMAC4 soap_get_ns1__NWriteVehicleInfoResponse(struct soap *soap, ns1__NWriteVehicleInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NWriteVehicleInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__NWriteVehicleInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::sid);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strDeviceId);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strVehicleId);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strDeviceType);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strDirectionId);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strDriveWayId);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strLicense);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strLicenseType);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strPassDateTime);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strRedLightBeginTime);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strRedLightLast);
	soap_default_LONG64(soap, &this->ns1__NWriteVehicleInfo::lSpeed);
	soap_default_LONG64(soap, &this->ns1__NWriteVehicleInfo::lLargeLimitSpeed);
	soap_default_LONG64(soap, &this->ns1__NWriteVehicleInfo::lMiniLimitSpeed);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strViolationType);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strViolationType2);
	soap_default_LONG64(soap, &this->ns1__NWriteVehicleInfo::lCarLength);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strLicenseColor);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strCarType);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strPicLocalPath1);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strPicLocalPath2);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strPicLocalPath3);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strPicLocalPath4);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strPicLocalPath5);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strPicLocalPath6);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strPicLocalPath7);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strPicRemotePath);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strViolate);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strSendType);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strCarColor);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strReserve1);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strReserve2);
	soap_default_std__string(soap, &this->ns1__NWriteVehicleInfo::strReserve3);
}

void ns1__NWriteVehicleInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::sid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::sid);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strDeviceId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strDeviceId);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strVehicleId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strVehicleId);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strDeviceType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strDeviceType);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strDirectionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strDirectionId);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strDriveWayId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strDriveWayId);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strLicense, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strLicense);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strLicenseType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strLicenseType);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strPassDateTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strPassDateTime);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strRedLightBeginTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strRedLightBeginTime);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strRedLightLast, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strRedLightLast);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strViolationType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strViolationType);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strViolationType2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strViolationType2);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strLicenseColor, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strLicenseColor);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strCarType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strCarType);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strPicLocalPath1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strPicLocalPath1);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strPicLocalPath2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strPicLocalPath2);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strPicLocalPath3, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strPicLocalPath3);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strPicLocalPath4, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strPicLocalPath4);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strPicLocalPath5, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strPicLocalPath5);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strPicLocalPath6, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strPicLocalPath6);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strPicLocalPath7, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strPicLocalPath7);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strPicRemotePath, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strPicRemotePath);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strViolate, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strViolate);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strSendType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strSendType);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strCarColor, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strCarColor);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strReserve1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strReserve1);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strReserve2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strReserve2);
	soap_embedded(soap, &this->ns1__NWriteVehicleInfo::strReserve3, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__NWriteVehicleInfo::strReserve3);
#endif
}

int ns1__NWriteVehicleInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NWriteVehicleInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NWriteVehicleInfo(struct soap *soap, const char *tag, int id, const ns1__NWriteVehicleInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NWriteVehicleInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "sid", -1, &a->ns1__NWriteVehicleInfo::sid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDeviceId", -1, &a->ns1__NWriteVehicleInfo::strDeviceId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strVehicleId", -1, &a->ns1__NWriteVehicleInfo::strVehicleId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDeviceType", -1, &a->ns1__NWriteVehicleInfo::strDeviceType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDirectionId", -1, &a->ns1__NWriteVehicleInfo::strDirectionId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDriveWayId", -1, &a->ns1__NWriteVehicleInfo::strDriveWayId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strLicense", -1, &a->ns1__NWriteVehicleInfo::strLicense, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strLicenseType", -1, &a->ns1__NWriteVehicleInfo::strLicenseType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPassDateTime", -1, &a->ns1__NWriteVehicleInfo::strPassDateTime, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strRedLightBeginTime", -1, &a->ns1__NWriteVehicleInfo::strRedLightBeginTime, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strRedLightLast", -1, &a->ns1__NWriteVehicleInfo::strRedLightLast, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lSpeed", -1, &a->ns1__NWriteVehicleInfo::lSpeed, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lLargeLimitSpeed", -1, &a->ns1__NWriteVehicleInfo::lLargeLimitSpeed, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lMiniLimitSpeed", -1, &a->ns1__NWriteVehicleInfo::lMiniLimitSpeed, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strViolationType", -1, &a->ns1__NWriteVehicleInfo::strViolationType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strViolationType2", -1, &a->ns1__NWriteVehicleInfo::strViolationType2, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lCarLength", -1, &a->ns1__NWriteVehicleInfo::lCarLength, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strLicenseColor", -1, &a->ns1__NWriteVehicleInfo::strLicenseColor, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strCarType", -1, &a->ns1__NWriteVehicleInfo::strCarType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath1", -1, &a->ns1__NWriteVehicleInfo::strPicLocalPath1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath2", -1, &a->ns1__NWriteVehicleInfo::strPicLocalPath2, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath3", -1, &a->ns1__NWriteVehicleInfo::strPicLocalPath3, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath4", -1, &a->ns1__NWriteVehicleInfo::strPicLocalPath4, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath5", -1, &a->ns1__NWriteVehicleInfo::strPicLocalPath5, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath6", -1, &a->ns1__NWriteVehicleInfo::strPicLocalPath6, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath7", -1, &a->ns1__NWriteVehicleInfo::strPicLocalPath7, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicRemotePath", -1, &a->ns1__NWriteVehicleInfo::strPicRemotePath, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strViolate", -1, &a->ns1__NWriteVehicleInfo::strViolate, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strSendType", -1, &a->ns1__NWriteVehicleInfo::strSendType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strCarColor", -1, &a->ns1__NWriteVehicleInfo::strCarColor, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strReserve1", -1, &a->ns1__NWriteVehicleInfo::strReserve1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strReserve2", -1, &a->ns1__NWriteVehicleInfo::strReserve2, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strReserve3", -1, &a->ns1__NWriteVehicleInfo::strReserve3, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__NWriteVehicleInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__NWriteVehicleInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NWriteVehicleInfo * SOAP_FMAC4 soap_in_ns1__NWriteVehicleInfo(struct soap *soap, const char *tag, ns1__NWriteVehicleInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NWriteVehicleInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NWriteVehicleInfo, sizeof(ns1__NWriteVehicleInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__NWriteVehicleInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__NWriteVehicleInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sid1 = 1;
	size_t soap_flag_strDeviceId1 = 1;
	size_t soap_flag_strVehicleId1 = 1;
	size_t soap_flag_strDeviceType1 = 1;
	size_t soap_flag_strDirectionId1 = 1;
	size_t soap_flag_strDriveWayId1 = 1;
	size_t soap_flag_strLicense1 = 1;
	size_t soap_flag_strLicenseType1 = 1;
	size_t soap_flag_strPassDateTime1 = 1;
	size_t soap_flag_strRedLightBeginTime1 = 1;
	size_t soap_flag_strRedLightLast1 = 1;
	size_t soap_flag_lSpeed1 = 1;
	size_t soap_flag_lLargeLimitSpeed1 = 1;
	size_t soap_flag_lMiniLimitSpeed1 = 1;
	size_t soap_flag_strViolationType1 = 1;
	size_t soap_flag_strViolationType21 = 1;
	size_t soap_flag_lCarLength1 = 1;
	size_t soap_flag_strLicenseColor1 = 1;
	size_t soap_flag_strCarType1 = 1;
	size_t soap_flag_strPicLocalPath11 = 1;
	size_t soap_flag_strPicLocalPath21 = 1;
	size_t soap_flag_strPicLocalPath31 = 1;
	size_t soap_flag_strPicLocalPath41 = 1;
	size_t soap_flag_strPicLocalPath51 = 1;
	size_t soap_flag_strPicLocalPath61 = 1;
	size_t soap_flag_strPicLocalPath71 = 1;
	size_t soap_flag_strPicRemotePath1 = 1;
	size_t soap_flag_strViolate1 = 1;
	size_t soap_flag_strSendType1 = 1;
	size_t soap_flag_strCarColor1 = 1;
	size_t soap_flag_strReserve11 = 1;
	size_t soap_flag_strReserve21 = 1;
	size_t soap_flag_strReserve31 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sid", &a->ns1__NWriteVehicleInfo::sid, "xsd:string"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap_flag_strDeviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDeviceId", &a->ns1__NWriteVehicleInfo::strDeviceId, "xsd:string"))
				{	soap_flag_strDeviceId1--;
					continue;
				}
			}
			if (soap_flag_strVehicleId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strVehicleId", &a->ns1__NWriteVehicleInfo::strVehicleId, "xsd:string"))
				{	soap_flag_strVehicleId1--;
					continue;
				}
			}
			if (soap_flag_strDeviceType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDeviceType", &a->ns1__NWriteVehicleInfo::strDeviceType, "xsd:string"))
				{	soap_flag_strDeviceType1--;
					continue;
				}
			}
			if (soap_flag_strDirectionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDirectionId", &a->ns1__NWriteVehicleInfo::strDirectionId, "xsd:string"))
				{	soap_flag_strDirectionId1--;
					continue;
				}
			}
			if (soap_flag_strDriveWayId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDriveWayId", &a->ns1__NWriteVehicleInfo::strDriveWayId, "xsd:string"))
				{	soap_flag_strDriveWayId1--;
					continue;
				}
			}
			if (soap_flag_strLicense1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strLicense", &a->ns1__NWriteVehicleInfo::strLicense, "xsd:string"))
				{	soap_flag_strLicense1--;
					continue;
				}
			}
			if (soap_flag_strLicenseType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strLicenseType", &a->ns1__NWriteVehicleInfo::strLicenseType, "xsd:string"))
				{	soap_flag_strLicenseType1--;
					continue;
				}
			}
			if (soap_flag_strPassDateTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPassDateTime", &a->ns1__NWriteVehicleInfo::strPassDateTime, "xsd:string"))
				{	soap_flag_strPassDateTime1--;
					continue;
				}
			}
			if (soap_flag_strRedLightBeginTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strRedLightBeginTime", &a->ns1__NWriteVehicleInfo::strRedLightBeginTime, "xsd:string"))
				{	soap_flag_strRedLightBeginTime1--;
					continue;
				}
			}
			if (soap_flag_strRedLightLast1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strRedLightLast", &a->ns1__NWriteVehicleInfo::strRedLightLast, "xsd:string"))
				{	soap_flag_strRedLightLast1--;
					continue;
				}
			}
			if (soap_flag_lSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lSpeed", &a->ns1__NWriteVehicleInfo::lSpeed, "xsd:long"))
				{	soap_flag_lSpeed1--;
					continue;
				}
			}
			if (soap_flag_lLargeLimitSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lLargeLimitSpeed", &a->ns1__NWriteVehicleInfo::lLargeLimitSpeed, "xsd:long"))
				{	soap_flag_lLargeLimitSpeed1--;
					continue;
				}
			}
			if (soap_flag_lMiniLimitSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lMiniLimitSpeed", &a->ns1__NWriteVehicleInfo::lMiniLimitSpeed, "xsd:long"))
				{	soap_flag_lMiniLimitSpeed1--;
					continue;
				}
			}
			if (soap_flag_strViolationType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strViolationType", &a->ns1__NWriteVehicleInfo::strViolationType, "xsd:string"))
				{	soap_flag_strViolationType1--;
					continue;
				}
			}
			if (soap_flag_strViolationType21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strViolationType2", &a->ns1__NWriteVehicleInfo::strViolationType2, "xsd:string"))
				{	soap_flag_strViolationType21--;
					continue;
				}
			}
			if (soap_flag_lCarLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lCarLength", &a->ns1__NWriteVehicleInfo::lCarLength, "xsd:long"))
				{	soap_flag_lCarLength1--;
					continue;
				}
			}
			if (soap_flag_strLicenseColor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strLicenseColor", &a->ns1__NWriteVehicleInfo::strLicenseColor, "xsd:string"))
				{	soap_flag_strLicenseColor1--;
					continue;
				}
			}
			if (soap_flag_strCarType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strCarType", &a->ns1__NWriteVehicleInfo::strCarType, "xsd:string"))
				{	soap_flag_strCarType1--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath1", &a->ns1__NWriteVehicleInfo::strPicLocalPath1, "xsd:string"))
				{	soap_flag_strPicLocalPath11--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath2", &a->ns1__NWriteVehicleInfo::strPicLocalPath2, "xsd:string"))
				{	soap_flag_strPicLocalPath21--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath3", &a->ns1__NWriteVehicleInfo::strPicLocalPath3, "xsd:string"))
				{	soap_flag_strPicLocalPath31--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath4", &a->ns1__NWriteVehicleInfo::strPicLocalPath4, "xsd:string"))
				{	soap_flag_strPicLocalPath41--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath5", &a->ns1__NWriteVehicleInfo::strPicLocalPath5, "xsd:string"))
				{	soap_flag_strPicLocalPath51--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath61 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath6", &a->ns1__NWriteVehicleInfo::strPicLocalPath6, "xsd:string"))
				{	soap_flag_strPicLocalPath61--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath71 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath7", &a->ns1__NWriteVehicleInfo::strPicLocalPath7, "xsd:string"))
				{	soap_flag_strPicLocalPath71--;
					continue;
				}
			}
			if (soap_flag_strPicRemotePath1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicRemotePath", &a->ns1__NWriteVehicleInfo::strPicRemotePath, "xsd:string"))
				{	soap_flag_strPicRemotePath1--;
					continue;
				}
			}
			if (soap_flag_strViolate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strViolate", &a->ns1__NWriteVehicleInfo::strViolate, "xsd:string"))
				{	soap_flag_strViolate1--;
					continue;
				}
			}
			if (soap_flag_strSendType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strSendType", &a->ns1__NWriteVehicleInfo::strSendType, "xsd:string"))
				{	soap_flag_strSendType1--;
					continue;
				}
			}
			if (soap_flag_strCarColor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strCarColor", &a->ns1__NWriteVehicleInfo::strCarColor, "xsd:string"))
				{	soap_flag_strCarColor1--;
					continue;
				}
			}
			if (soap_flag_strReserve11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strReserve1", &a->ns1__NWriteVehicleInfo::strReserve1, "xsd:string"))
				{	soap_flag_strReserve11--;
					continue;
				}
			}
			if (soap_flag_strReserve21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strReserve2", &a->ns1__NWriteVehicleInfo::strReserve2, "xsd:string"))
				{	soap_flag_strReserve21--;
					continue;
				}
			}
			if (soap_flag_strReserve31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strReserve3", &a->ns1__NWriteVehicleInfo::strReserve3, "xsd:string"))
				{	soap_flag_strReserve31--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid1 > 0 || soap_flag_strDeviceId1 > 0 || soap_flag_strVehicleId1 > 0 || soap_flag_strDeviceType1 > 0 || soap_flag_strDirectionId1 > 0 || soap_flag_strDriveWayId1 > 0 || soap_flag_strLicense1 > 0 || soap_flag_strLicenseType1 > 0 || soap_flag_strPassDateTime1 > 0 || soap_flag_strRedLightBeginTime1 > 0 || soap_flag_strRedLightLast1 > 0 || soap_flag_lSpeed1 > 0 || soap_flag_lLargeLimitSpeed1 > 0 || soap_flag_lMiniLimitSpeed1 > 0 || soap_flag_strViolationType1 > 0 || soap_flag_strViolationType21 > 0 || soap_flag_lCarLength1 > 0 || soap_flag_strLicenseColor1 > 0 || soap_flag_strCarType1 > 0 || soap_flag_strPicLocalPath11 > 0 || soap_flag_strPicLocalPath21 > 0 || soap_flag_strPicLocalPath31 > 0 || soap_flag_strPicLocalPath41 > 0 || soap_flag_strPicLocalPath51 > 0 || soap_flag_strPicLocalPath61 > 0 || soap_flag_strPicLocalPath71 > 0 || soap_flag_strPicRemotePath1 > 0 || soap_flag_strViolate1 > 0 || soap_flag_strSendType1 > 0 || soap_flag_strCarColor1 > 0 || soap_flag_strReserve11 > 0 || soap_flag_strReserve21 > 0 || soap_flag_strReserve31 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__NWriteVehicleInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NWriteVehicleInfo, SOAP_TYPE_ns1__NWriteVehicleInfo, sizeof(ns1__NWriteVehicleInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__NWriteVehicleInfo * SOAP_FMAC2 soap_instantiate_ns1__NWriteVehicleInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NWriteVehicleInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__NWriteVehicleInfo *p;
	size_t k = sizeof(ns1__NWriteVehicleInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__NWriteVehicleInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__NWriteVehicleInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__NWriteVehicleInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__NWriteVehicleInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__NWriteVehicleInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__NWriteVehicleInfo(soap, tag ? tag : "ns1:NWriteVehicleInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NWriteVehicleInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NWriteVehicleInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NWriteVehicleInfo * SOAP_FMAC4 soap_get_ns1__NWriteVehicleInfo(struct soap *soap, ns1__NWriteVehicleInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NWriteVehicleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__writeAlarmInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__writeAlarmInfoResponse::return_ = NULL;
}

void ns1__writeAlarmInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__writeAlarmInfoResponse::return_);
#endif
}

int ns1__writeAlarmInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__writeAlarmInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__writeAlarmInfoResponse(struct soap *soap, const char *tag, int id, const ns1__writeAlarmInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__writeAlarmInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->ns1__writeAlarmInfoResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__writeAlarmInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__writeAlarmInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__writeAlarmInfoResponse * SOAP_FMAC4 soap_in_ns1__writeAlarmInfoResponse(struct soap *soap, const char *tag, ns1__writeAlarmInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__writeAlarmInfoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__writeAlarmInfoResponse, sizeof(ns1__writeAlarmInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__writeAlarmInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__writeAlarmInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->ns1__writeAlarmInfoResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__writeAlarmInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__writeAlarmInfoResponse, SOAP_TYPE_ns1__writeAlarmInfoResponse, sizeof(ns1__writeAlarmInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__writeAlarmInfoResponse * SOAP_FMAC2 soap_instantiate_ns1__writeAlarmInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__writeAlarmInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__writeAlarmInfoResponse *p;
	size_t k = sizeof(ns1__writeAlarmInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__writeAlarmInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__writeAlarmInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__writeAlarmInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__writeAlarmInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__writeAlarmInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__writeAlarmInfoResponse(soap, tag ? tag : "ns1:writeAlarmInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__writeAlarmInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__writeAlarmInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__writeAlarmInfoResponse * SOAP_FMAC4 soap_get_ns1__writeAlarmInfoResponse(struct soap *soap, ns1__writeAlarmInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__writeAlarmInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__writeAlarmInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__writeAlarmInfo::sid);
	soap_default_std__string(soap, &this->ns1__writeAlarmInfo::strDeviceId);
	soap_default_std__string(soap, &this->ns1__writeAlarmInfo::strDirectionId);
	soap_default_std__string(soap, &this->ns1__writeAlarmInfo::strDircName);
	soap_default_std__string(soap, &this->ns1__writeAlarmInfo::strLicense);
	soap_default_std__string(soap, &this->ns1__writeAlarmInfo::strLicenseType);
	soap_default_std__string(soap, &this->ns1__writeAlarmInfo::strPassDateTime);
	soap_default_std__string(soap, &this->ns1__writeAlarmInfo::strPicLocalPath1);
	soap_default_std__string(soap, &this->ns1__writeAlarmInfo::strPicLocalPath2);
	soap_default_std__string(soap, &this->ns1__writeAlarmInfo::strPicLocalPath3);
	soap_default_std__string(soap, &this->ns1__writeAlarmInfo::strPicLocalPath4);
	soap_default_std__string(soap, &this->ns1__writeAlarmInfo::strPicLocalPath5);
	soap_default_std__string(soap, &this->ns1__writeAlarmInfo::strPicLocalPath6);
	soap_default_std__string(soap, &this->ns1__writeAlarmInfo::strPicLocalPath7);
	soap_default_std__string(soap, &this->ns1__writeAlarmInfo::strAlarmDateTime);
	soap_default_std__string(soap, &this->ns1__writeAlarmInfo::strBriefCaseDescript);
	soap_default_std__string(soap, &this->ns1__writeAlarmInfo::strSuspType);
	soap_default_std__string(soap, &this->ns1__writeAlarmInfo::strSuspNo);
	soap_default_std__string(soap, &this->ns1__writeAlarmInfo::strAlarmLevel);
	soap_default_std__string(soap, &this->ns1__writeAlarmInfo::strPlaceId);
	soap_default_std__string(soap, &this->ns1__writeAlarmInfo::strPlaceName);
	soap_default_std__string(soap, &this->ns1__writeAlarmInfo::strReserve1);
	soap_default_std__string(soap, &this->ns1__writeAlarmInfo::strReserve2);
	soap_default_std__string(soap, &this->ns1__writeAlarmInfo::strReserve3);
}

void ns1__writeAlarmInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__writeAlarmInfo::sid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeAlarmInfo::sid);
	soap_embedded(soap, &this->ns1__writeAlarmInfo::strDeviceId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeAlarmInfo::strDeviceId);
	soap_embedded(soap, &this->ns1__writeAlarmInfo::strDirectionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeAlarmInfo::strDirectionId);
	soap_embedded(soap, &this->ns1__writeAlarmInfo::strDircName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeAlarmInfo::strDircName);
	soap_embedded(soap, &this->ns1__writeAlarmInfo::strLicense, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeAlarmInfo::strLicense);
	soap_embedded(soap, &this->ns1__writeAlarmInfo::strLicenseType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeAlarmInfo::strLicenseType);
	soap_embedded(soap, &this->ns1__writeAlarmInfo::strPassDateTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeAlarmInfo::strPassDateTime);
	soap_embedded(soap, &this->ns1__writeAlarmInfo::strPicLocalPath1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeAlarmInfo::strPicLocalPath1);
	soap_embedded(soap, &this->ns1__writeAlarmInfo::strPicLocalPath2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeAlarmInfo::strPicLocalPath2);
	soap_embedded(soap, &this->ns1__writeAlarmInfo::strPicLocalPath3, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeAlarmInfo::strPicLocalPath3);
	soap_embedded(soap, &this->ns1__writeAlarmInfo::strPicLocalPath4, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeAlarmInfo::strPicLocalPath4);
	soap_embedded(soap, &this->ns1__writeAlarmInfo::strPicLocalPath5, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeAlarmInfo::strPicLocalPath5);
	soap_embedded(soap, &this->ns1__writeAlarmInfo::strPicLocalPath6, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeAlarmInfo::strPicLocalPath6);
	soap_embedded(soap, &this->ns1__writeAlarmInfo::strPicLocalPath7, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeAlarmInfo::strPicLocalPath7);
	soap_embedded(soap, &this->ns1__writeAlarmInfo::strAlarmDateTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeAlarmInfo::strAlarmDateTime);
	soap_embedded(soap, &this->ns1__writeAlarmInfo::strBriefCaseDescript, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeAlarmInfo::strBriefCaseDescript);
	soap_embedded(soap, &this->ns1__writeAlarmInfo::strSuspType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeAlarmInfo::strSuspType);
	soap_embedded(soap, &this->ns1__writeAlarmInfo::strSuspNo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeAlarmInfo::strSuspNo);
	soap_embedded(soap, &this->ns1__writeAlarmInfo::strAlarmLevel, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeAlarmInfo::strAlarmLevel);
	soap_embedded(soap, &this->ns1__writeAlarmInfo::strPlaceId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeAlarmInfo::strPlaceId);
	soap_embedded(soap, &this->ns1__writeAlarmInfo::strPlaceName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeAlarmInfo::strPlaceName);
	soap_embedded(soap, &this->ns1__writeAlarmInfo::strReserve1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeAlarmInfo::strReserve1);
	soap_embedded(soap, &this->ns1__writeAlarmInfo::strReserve2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeAlarmInfo::strReserve2);
	soap_embedded(soap, &this->ns1__writeAlarmInfo::strReserve3, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeAlarmInfo::strReserve3);
#endif
}

int ns1__writeAlarmInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__writeAlarmInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__writeAlarmInfo(struct soap *soap, const char *tag, int id, const ns1__writeAlarmInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__writeAlarmInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "sid", -1, &a->ns1__writeAlarmInfo::sid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDeviceId", -1, &a->ns1__writeAlarmInfo::strDeviceId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDirectionId", -1, &a->ns1__writeAlarmInfo::strDirectionId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDircName", -1, &a->ns1__writeAlarmInfo::strDircName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strLicense", -1, &a->ns1__writeAlarmInfo::strLicense, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strLicenseType", -1, &a->ns1__writeAlarmInfo::strLicenseType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPassDateTime", -1, &a->ns1__writeAlarmInfo::strPassDateTime, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath1", -1, &a->ns1__writeAlarmInfo::strPicLocalPath1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath2", -1, &a->ns1__writeAlarmInfo::strPicLocalPath2, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath3", -1, &a->ns1__writeAlarmInfo::strPicLocalPath3, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath4", -1, &a->ns1__writeAlarmInfo::strPicLocalPath4, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath5", -1, &a->ns1__writeAlarmInfo::strPicLocalPath5, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath6", -1, &a->ns1__writeAlarmInfo::strPicLocalPath6, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath7", -1, &a->ns1__writeAlarmInfo::strPicLocalPath7, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strAlarmDateTime", -1, &a->ns1__writeAlarmInfo::strAlarmDateTime, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strBriefCaseDescript", -1, &a->ns1__writeAlarmInfo::strBriefCaseDescript, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strSuspType", -1, &a->ns1__writeAlarmInfo::strSuspType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strSuspNo", -1, &a->ns1__writeAlarmInfo::strSuspNo, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strAlarmLevel", -1, &a->ns1__writeAlarmInfo::strAlarmLevel, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPlaceId", -1, &a->ns1__writeAlarmInfo::strPlaceId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPlaceName", -1, &a->ns1__writeAlarmInfo::strPlaceName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strReserve1", -1, &a->ns1__writeAlarmInfo::strReserve1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strReserve2", -1, &a->ns1__writeAlarmInfo::strReserve2, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strReserve3", -1, &a->ns1__writeAlarmInfo::strReserve3, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__writeAlarmInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__writeAlarmInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__writeAlarmInfo * SOAP_FMAC4 soap_in_ns1__writeAlarmInfo(struct soap *soap, const char *tag, ns1__writeAlarmInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__writeAlarmInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__writeAlarmInfo, sizeof(ns1__writeAlarmInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__writeAlarmInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__writeAlarmInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sid1 = 1;
	size_t soap_flag_strDeviceId1 = 1;
	size_t soap_flag_strDirectionId1 = 1;
	size_t soap_flag_strDircName1 = 1;
	size_t soap_flag_strLicense1 = 1;
	size_t soap_flag_strLicenseType1 = 1;
	size_t soap_flag_strPassDateTime1 = 1;
	size_t soap_flag_strPicLocalPath11 = 1;
	size_t soap_flag_strPicLocalPath21 = 1;
	size_t soap_flag_strPicLocalPath31 = 1;
	size_t soap_flag_strPicLocalPath41 = 1;
	size_t soap_flag_strPicLocalPath51 = 1;
	size_t soap_flag_strPicLocalPath61 = 1;
	size_t soap_flag_strPicLocalPath71 = 1;
	size_t soap_flag_strAlarmDateTime1 = 1;
	size_t soap_flag_strBriefCaseDescript1 = 1;
	size_t soap_flag_strSuspType1 = 1;
	size_t soap_flag_strSuspNo1 = 1;
	size_t soap_flag_strAlarmLevel1 = 1;
	size_t soap_flag_strPlaceId1 = 1;
	size_t soap_flag_strPlaceName1 = 1;
	size_t soap_flag_strReserve11 = 1;
	size_t soap_flag_strReserve21 = 1;
	size_t soap_flag_strReserve31 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sid", &a->ns1__writeAlarmInfo::sid, "xsd:string"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap_flag_strDeviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDeviceId", &a->ns1__writeAlarmInfo::strDeviceId, "xsd:string"))
				{	soap_flag_strDeviceId1--;
					continue;
				}
			}
			if (soap_flag_strDirectionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDirectionId", &a->ns1__writeAlarmInfo::strDirectionId, "xsd:string"))
				{	soap_flag_strDirectionId1--;
					continue;
				}
			}
			if (soap_flag_strDircName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDircName", &a->ns1__writeAlarmInfo::strDircName, "xsd:string"))
				{	soap_flag_strDircName1--;
					continue;
				}
			}
			if (soap_flag_strLicense1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strLicense", &a->ns1__writeAlarmInfo::strLicense, "xsd:string"))
				{	soap_flag_strLicense1--;
					continue;
				}
			}
			if (soap_flag_strLicenseType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strLicenseType", &a->ns1__writeAlarmInfo::strLicenseType, "xsd:string"))
				{	soap_flag_strLicenseType1--;
					continue;
				}
			}
			if (soap_flag_strPassDateTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPassDateTime", &a->ns1__writeAlarmInfo::strPassDateTime, "xsd:string"))
				{	soap_flag_strPassDateTime1--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath1", &a->ns1__writeAlarmInfo::strPicLocalPath1, "xsd:string"))
				{	soap_flag_strPicLocalPath11--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath2", &a->ns1__writeAlarmInfo::strPicLocalPath2, "xsd:string"))
				{	soap_flag_strPicLocalPath21--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath3", &a->ns1__writeAlarmInfo::strPicLocalPath3, "xsd:string"))
				{	soap_flag_strPicLocalPath31--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath4", &a->ns1__writeAlarmInfo::strPicLocalPath4, "xsd:string"))
				{	soap_flag_strPicLocalPath41--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath5", &a->ns1__writeAlarmInfo::strPicLocalPath5, "xsd:string"))
				{	soap_flag_strPicLocalPath51--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath61 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath6", &a->ns1__writeAlarmInfo::strPicLocalPath6, "xsd:string"))
				{	soap_flag_strPicLocalPath61--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath71 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath7", &a->ns1__writeAlarmInfo::strPicLocalPath7, "xsd:string"))
				{	soap_flag_strPicLocalPath71--;
					continue;
				}
			}
			if (soap_flag_strAlarmDateTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strAlarmDateTime", &a->ns1__writeAlarmInfo::strAlarmDateTime, "xsd:string"))
				{	soap_flag_strAlarmDateTime1--;
					continue;
				}
			}
			if (soap_flag_strBriefCaseDescript1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strBriefCaseDescript", &a->ns1__writeAlarmInfo::strBriefCaseDescript, "xsd:string"))
				{	soap_flag_strBriefCaseDescript1--;
					continue;
				}
			}
			if (soap_flag_strSuspType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strSuspType", &a->ns1__writeAlarmInfo::strSuspType, "xsd:string"))
				{	soap_flag_strSuspType1--;
					continue;
				}
			}
			if (soap_flag_strSuspNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strSuspNo", &a->ns1__writeAlarmInfo::strSuspNo, "xsd:string"))
				{	soap_flag_strSuspNo1--;
					continue;
				}
			}
			if (soap_flag_strAlarmLevel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strAlarmLevel", &a->ns1__writeAlarmInfo::strAlarmLevel, "xsd:string"))
				{	soap_flag_strAlarmLevel1--;
					continue;
				}
			}
			if (soap_flag_strPlaceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPlaceId", &a->ns1__writeAlarmInfo::strPlaceId, "xsd:string"))
				{	soap_flag_strPlaceId1--;
					continue;
				}
			}
			if (soap_flag_strPlaceName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPlaceName", &a->ns1__writeAlarmInfo::strPlaceName, "xsd:string"))
				{	soap_flag_strPlaceName1--;
					continue;
				}
			}
			if (soap_flag_strReserve11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strReserve1", &a->ns1__writeAlarmInfo::strReserve1, "xsd:string"))
				{	soap_flag_strReserve11--;
					continue;
				}
			}
			if (soap_flag_strReserve21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strReserve2", &a->ns1__writeAlarmInfo::strReserve2, "xsd:string"))
				{	soap_flag_strReserve21--;
					continue;
				}
			}
			if (soap_flag_strReserve31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strReserve3", &a->ns1__writeAlarmInfo::strReserve3, "xsd:string"))
				{	soap_flag_strReserve31--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid1 > 0 || soap_flag_strDeviceId1 > 0 || soap_flag_strDirectionId1 > 0 || soap_flag_strDircName1 > 0 || soap_flag_strLicense1 > 0 || soap_flag_strLicenseType1 > 0 || soap_flag_strPassDateTime1 > 0 || soap_flag_strPicLocalPath11 > 0 || soap_flag_strPicLocalPath21 > 0 || soap_flag_strPicLocalPath31 > 0 || soap_flag_strPicLocalPath41 > 0 || soap_flag_strPicLocalPath51 > 0 || soap_flag_strPicLocalPath61 > 0 || soap_flag_strPicLocalPath71 > 0 || soap_flag_strAlarmDateTime1 > 0 || soap_flag_strBriefCaseDescript1 > 0 || soap_flag_strSuspType1 > 0 || soap_flag_strSuspNo1 > 0 || soap_flag_strAlarmLevel1 > 0 || soap_flag_strPlaceId1 > 0 || soap_flag_strPlaceName1 > 0 || soap_flag_strReserve11 > 0 || soap_flag_strReserve21 > 0 || soap_flag_strReserve31 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__writeAlarmInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__writeAlarmInfo, SOAP_TYPE_ns1__writeAlarmInfo, sizeof(ns1__writeAlarmInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__writeAlarmInfo * SOAP_FMAC2 soap_instantiate_ns1__writeAlarmInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__writeAlarmInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__writeAlarmInfo *p;
	size_t k = sizeof(ns1__writeAlarmInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__writeAlarmInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__writeAlarmInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__writeAlarmInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__writeAlarmInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__writeAlarmInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__writeAlarmInfo(soap, tag ? tag : "ns1:writeAlarmInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__writeAlarmInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__writeAlarmInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__writeAlarmInfo * SOAP_FMAC4 soap_get_ns1__writeAlarmInfo(struct soap *soap, ns1__writeAlarmInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__writeAlarmInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__querySyncTimeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__querySyncTimeResponse::return_ = NULL;
}

void ns1__querySyncTimeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__querySyncTimeResponse::return_);
#endif
}

int ns1__querySyncTimeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__querySyncTimeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__querySyncTimeResponse(struct soap *soap, const char *tag, int id, const ns1__querySyncTimeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__querySyncTimeResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->ns1__querySyncTimeResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__querySyncTimeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__querySyncTimeResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__querySyncTimeResponse * SOAP_FMAC4 soap_in_ns1__querySyncTimeResponse(struct soap *soap, const char *tag, ns1__querySyncTimeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__querySyncTimeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__querySyncTimeResponse, sizeof(ns1__querySyncTimeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__querySyncTimeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__querySyncTimeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->ns1__querySyncTimeResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__querySyncTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__querySyncTimeResponse, SOAP_TYPE_ns1__querySyncTimeResponse, sizeof(ns1__querySyncTimeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__querySyncTimeResponse * SOAP_FMAC2 soap_instantiate_ns1__querySyncTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__querySyncTimeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__querySyncTimeResponse *p;
	size_t k = sizeof(ns1__querySyncTimeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__querySyncTimeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__querySyncTimeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__querySyncTimeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__querySyncTimeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__querySyncTimeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__querySyncTimeResponse(soap, tag ? tag : "ns1:querySyncTimeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__querySyncTimeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__querySyncTimeResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__querySyncTimeResponse * SOAP_FMAC4 soap_get_ns1__querySyncTimeResponse(struct soap *soap, ns1__querySyncTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__querySyncTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__querySyncTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__querySyncTime::sid);
}

void ns1__querySyncTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__querySyncTime::sid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__querySyncTime::sid);
#endif
}

int ns1__querySyncTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__querySyncTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__querySyncTime(struct soap *soap, const char *tag, int id, const ns1__querySyncTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__querySyncTime), type))
		return soap->error;
	if (soap_out_std__string(soap, "sid", -1, &a->ns1__querySyncTime::sid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__querySyncTime::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__querySyncTime(soap, tag, this, type);
}

SOAP_FMAC3 ns1__querySyncTime * SOAP_FMAC4 soap_in_ns1__querySyncTime(struct soap *soap, const char *tag, ns1__querySyncTime *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__querySyncTime*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__querySyncTime, sizeof(ns1__querySyncTime), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__querySyncTime)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__querySyncTime *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sid1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sid", &a->ns1__querySyncTime::sid, "xsd:string"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__querySyncTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__querySyncTime, SOAP_TYPE_ns1__querySyncTime, sizeof(ns1__querySyncTime), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__querySyncTime * SOAP_FMAC2 soap_instantiate_ns1__querySyncTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__querySyncTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__querySyncTime *p;
	size_t k = sizeof(ns1__querySyncTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__querySyncTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__querySyncTime);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__querySyncTime, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__querySyncTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__querySyncTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__querySyncTime(soap, tag ? tag : "ns1:querySyncTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__querySyncTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__querySyncTime(soap, this, tag, type);
}

SOAP_FMAC3 ns1__querySyncTime * SOAP_FMAC4 soap_get_ns1__querySyncTime(struct soap *soap, ns1__querySyncTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__querySyncTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__logoutResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__logoutResponse::return_ = NULL;
}

void ns1__logoutResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__logoutResponse::return_);
#endif
}

int ns1__logoutResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__logoutResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__logoutResponse(struct soap *soap, const char *tag, int id, const ns1__logoutResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__logoutResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->ns1__logoutResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__logoutResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__logoutResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__logoutResponse * SOAP_FMAC4 soap_in_ns1__logoutResponse(struct soap *soap, const char *tag, ns1__logoutResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__logoutResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__logoutResponse, sizeof(ns1__logoutResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__logoutResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__logoutResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->ns1__logoutResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__logoutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__logoutResponse, SOAP_TYPE_ns1__logoutResponse, sizeof(ns1__logoutResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__logoutResponse * SOAP_FMAC2 soap_instantiate_ns1__logoutResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__logoutResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__logoutResponse *p;
	size_t k = sizeof(ns1__logoutResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__logoutResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__logoutResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__logoutResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__logoutResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__logoutResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__logoutResponse(soap, tag ? tag : "ns1:logoutResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__logoutResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__logoutResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__logoutResponse * SOAP_FMAC4 soap_get_ns1__logoutResponse(struct soap *soap, ns1__logoutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__logoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__logout::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__logout::sid);
}

void ns1__logout::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__logout::sid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__logout::sid);
#endif
}

int ns1__logout::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__logout(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__logout(struct soap *soap, const char *tag, int id, const ns1__logout *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__logout), type))
		return soap->error;
	if (soap_out_std__string(soap, "sid", -1, &a->ns1__logout::sid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__logout::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__logout(soap, tag, this, type);
}

SOAP_FMAC3 ns1__logout * SOAP_FMAC4 soap_in_ns1__logout(struct soap *soap, const char *tag, ns1__logout *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__logout*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__logout, sizeof(ns1__logout), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__logout)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__logout *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sid1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sid", &a->ns1__logout::sid, "xsd:string"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__logout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__logout, SOAP_TYPE_ns1__logout, sizeof(ns1__logout), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__logout * SOAP_FMAC2 soap_instantiate_ns1__logout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__logout(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__logout *p;
	size_t k = sizeof(ns1__logout);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__logout, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__logout);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__logout, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__logout location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__logout::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__logout(soap, tag ? tag : "ns1:logout", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__logout::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__logout(soap, this, tag, type);
}

SOAP_FMAC3 ns1__logout * SOAP_FMAC4 soap_get_ns1__logout(struct soap *soap, ns1__logout *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__queryViolateSpeedResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__queryViolateSpeedResponse::return_ = NULL;
}

void ns1__queryViolateSpeedResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__queryViolateSpeedResponse::return_);
#endif
}

int ns1__queryViolateSpeedResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__queryViolateSpeedResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__queryViolateSpeedResponse(struct soap *soap, const char *tag, int id, const ns1__queryViolateSpeedResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__queryViolateSpeedResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->ns1__queryViolateSpeedResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__queryViolateSpeedResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__queryViolateSpeedResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__queryViolateSpeedResponse * SOAP_FMAC4 soap_in_ns1__queryViolateSpeedResponse(struct soap *soap, const char *tag, ns1__queryViolateSpeedResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__queryViolateSpeedResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__queryViolateSpeedResponse, sizeof(ns1__queryViolateSpeedResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__queryViolateSpeedResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__queryViolateSpeedResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->ns1__queryViolateSpeedResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__queryViolateSpeedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__queryViolateSpeedResponse, SOAP_TYPE_ns1__queryViolateSpeedResponse, sizeof(ns1__queryViolateSpeedResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__queryViolateSpeedResponse * SOAP_FMAC2 soap_instantiate_ns1__queryViolateSpeedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__queryViolateSpeedResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__queryViolateSpeedResponse *p;
	size_t k = sizeof(ns1__queryViolateSpeedResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__queryViolateSpeedResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__queryViolateSpeedResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__queryViolateSpeedResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__queryViolateSpeedResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__queryViolateSpeedResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__queryViolateSpeedResponse(soap, tag ? tag : "ns1:queryViolateSpeedResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__queryViolateSpeedResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__queryViolateSpeedResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__queryViolateSpeedResponse * SOAP_FMAC4 soap_get_ns1__queryViolateSpeedResponse(struct soap *soap, ns1__queryViolateSpeedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__queryViolateSpeedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__queryViolateSpeed::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__queryViolateSpeed::sid);
	soap_default_std__string(soap, &this->ns1__queryViolateSpeed::strDeviceId);
	soap_default_std__string(soap, &this->ns1__queryViolateSpeed::strDirectId);
	soap_default_std__string(soap, &this->ns1__queryViolateSpeed::strCarType);
}

void ns1__queryViolateSpeed::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__queryViolateSpeed::sid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__queryViolateSpeed::sid);
	soap_embedded(soap, &this->ns1__queryViolateSpeed::strDeviceId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__queryViolateSpeed::strDeviceId);
	soap_embedded(soap, &this->ns1__queryViolateSpeed::strDirectId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__queryViolateSpeed::strDirectId);
	soap_embedded(soap, &this->ns1__queryViolateSpeed::strCarType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__queryViolateSpeed::strCarType);
#endif
}

int ns1__queryViolateSpeed::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__queryViolateSpeed(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__queryViolateSpeed(struct soap *soap, const char *tag, int id, const ns1__queryViolateSpeed *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__queryViolateSpeed), type))
		return soap->error;
	if (soap_out_std__string(soap, "sid", -1, &a->ns1__queryViolateSpeed::sid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDeviceId", -1, &a->ns1__queryViolateSpeed::strDeviceId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDirectId", -1, &a->ns1__queryViolateSpeed::strDirectId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strCarType", -1, &a->ns1__queryViolateSpeed::strCarType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__queryViolateSpeed::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__queryViolateSpeed(soap, tag, this, type);
}

SOAP_FMAC3 ns1__queryViolateSpeed * SOAP_FMAC4 soap_in_ns1__queryViolateSpeed(struct soap *soap, const char *tag, ns1__queryViolateSpeed *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__queryViolateSpeed*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__queryViolateSpeed, sizeof(ns1__queryViolateSpeed), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__queryViolateSpeed)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__queryViolateSpeed *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sid1 = 1;
	size_t soap_flag_strDeviceId1 = 1;
	size_t soap_flag_strDirectId1 = 1;
	size_t soap_flag_strCarType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sid", &a->ns1__queryViolateSpeed::sid, "xsd:string"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap_flag_strDeviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDeviceId", &a->ns1__queryViolateSpeed::strDeviceId, "xsd:string"))
				{	soap_flag_strDeviceId1--;
					continue;
				}
			}
			if (soap_flag_strDirectId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDirectId", &a->ns1__queryViolateSpeed::strDirectId, "xsd:string"))
				{	soap_flag_strDirectId1--;
					continue;
				}
			}
			if (soap_flag_strCarType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strCarType", &a->ns1__queryViolateSpeed::strCarType, "xsd:string"))
				{	soap_flag_strCarType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid1 > 0 || soap_flag_strDeviceId1 > 0 || soap_flag_strDirectId1 > 0 || soap_flag_strCarType1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__queryViolateSpeed *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__queryViolateSpeed, SOAP_TYPE_ns1__queryViolateSpeed, sizeof(ns1__queryViolateSpeed), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__queryViolateSpeed * SOAP_FMAC2 soap_instantiate_ns1__queryViolateSpeed(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__queryViolateSpeed(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__queryViolateSpeed *p;
	size_t k = sizeof(ns1__queryViolateSpeed);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__queryViolateSpeed, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__queryViolateSpeed);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__queryViolateSpeed, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__queryViolateSpeed location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__queryViolateSpeed::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__queryViolateSpeed(soap, tag ? tag : "ns1:queryViolateSpeed", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__queryViolateSpeed::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__queryViolateSpeed(soap, this, tag, type);
}

SOAP_FMAC3 ns1__queryViolateSpeed * SOAP_FMAC4 soap_get_ns1__queryViolateSpeed(struct soap *soap, ns1__queryViolateSpeed *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__queryViolateSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__queryLimitSpeedResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__queryLimitSpeedResponse::return_ = NULL;
}

void ns1__queryLimitSpeedResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__queryLimitSpeedResponse::return_);
#endif
}

int ns1__queryLimitSpeedResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__queryLimitSpeedResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__queryLimitSpeedResponse(struct soap *soap, const char *tag, int id, const ns1__queryLimitSpeedResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__queryLimitSpeedResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->ns1__queryLimitSpeedResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__queryLimitSpeedResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__queryLimitSpeedResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__queryLimitSpeedResponse * SOAP_FMAC4 soap_in_ns1__queryLimitSpeedResponse(struct soap *soap, const char *tag, ns1__queryLimitSpeedResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__queryLimitSpeedResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__queryLimitSpeedResponse, sizeof(ns1__queryLimitSpeedResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__queryLimitSpeedResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__queryLimitSpeedResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->ns1__queryLimitSpeedResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__queryLimitSpeedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__queryLimitSpeedResponse, SOAP_TYPE_ns1__queryLimitSpeedResponse, sizeof(ns1__queryLimitSpeedResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__queryLimitSpeedResponse * SOAP_FMAC2 soap_instantiate_ns1__queryLimitSpeedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__queryLimitSpeedResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__queryLimitSpeedResponse *p;
	size_t k = sizeof(ns1__queryLimitSpeedResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__queryLimitSpeedResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__queryLimitSpeedResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__queryLimitSpeedResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__queryLimitSpeedResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__queryLimitSpeedResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__queryLimitSpeedResponse(soap, tag ? tag : "ns1:queryLimitSpeedResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__queryLimitSpeedResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__queryLimitSpeedResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__queryLimitSpeedResponse * SOAP_FMAC4 soap_get_ns1__queryLimitSpeedResponse(struct soap *soap, ns1__queryLimitSpeedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__queryLimitSpeedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__queryLimitSpeed::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__queryLimitSpeed::sid);
	soap_default_std__string(soap, &this->ns1__queryLimitSpeed::strDeviceId);
	soap_default_std__string(soap, &this->ns1__queryLimitSpeed::strDirectId);
	soap_default_std__string(soap, &this->ns1__queryLimitSpeed::strCarType);
}

void ns1__queryLimitSpeed::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__queryLimitSpeed::sid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__queryLimitSpeed::sid);
	soap_embedded(soap, &this->ns1__queryLimitSpeed::strDeviceId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__queryLimitSpeed::strDeviceId);
	soap_embedded(soap, &this->ns1__queryLimitSpeed::strDirectId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__queryLimitSpeed::strDirectId);
	soap_embedded(soap, &this->ns1__queryLimitSpeed::strCarType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__queryLimitSpeed::strCarType);
#endif
}

int ns1__queryLimitSpeed::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__queryLimitSpeed(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__queryLimitSpeed(struct soap *soap, const char *tag, int id, const ns1__queryLimitSpeed *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__queryLimitSpeed), type))
		return soap->error;
	if (soap_out_std__string(soap, "sid", -1, &a->ns1__queryLimitSpeed::sid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDeviceId", -1, &a->ns1__queryLimitSpeed::strDeviceId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDirectId", -1, &a->ns1__queryLimitSpeed::strDirectId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strCarType", -1, &a->ns1__queryLimitSpeed::strCarType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__queryLimitSpeed::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__queryLimitSpeed(soap, tag, this, type);
}

SOAP_FMAC3 ns1__queryLimitSpeed * SOAP_FMAC4 soap_in_ns1__queryLimitSpeed(struct soap *soap, const char *tag, ns1__queryLimitSpeed *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__queryLimitSpeed*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__queryLimitSpeed, sizeof(ns1__queryLimitSpeed), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__queryLimitSpeed)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__queryLimitSpeed *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sid1 = 1;
	size_t soap_flag_strDeviceId1 = 1;
	size_t soap_flag_strDirectId1 = 1;
	size_t soap_flag_strCarType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sid", &a->ns1__queryLimitSpeed::sid, "xsd:string"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap_flag_strDeviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDeviceId", &a->ns1__queryLimitSpeed::strDeviceId, "xsd:string"))
				{	soap_flag_strDeviceId1--;
					continue;
				}
			}
			if (soap_flag_strDirectId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDirectId", &a->ns1__queryLimitSpeed::strDirectId, "xsd:string"))
				{	soap_flag_strDirectId1--;
					continue;
				}
			}
			if (soap_flag_strCarType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strCarType", &a->ns1__queryLimitSpeed::strCarType, "xsd:string"))
				{	soap_flag_strCarType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid1 > 0 || soap_flag_strDeviceId1 > 0 || soap_flag_strDirectId1 > 0 || soap_flag_strCarType1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__queryLimitSpeed *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__queryLimitSpeed, SOAP_TYPE_ns1__queryLimitSpeed, sizeof(ns1__queryLimitSpeed), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__queryLimitSpeed * SOAP_FMAC2 soap_instantiate_ns1__queryLimitSpeed(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__queryLimitSpeed(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__queryLimitSpeed *p;
	size_t k = sizeof(ns1__queryLimitSpeed);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__queryLimitSpeed, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__queryLimitSpeed);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__queryLimitSpeed, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__queryLimitSpeed location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__queryLimitSpeed::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__queryLimitSpeed(soap, tag ? tag : "ns1:queryLimitSpeed", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__queryLimitSpeed::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__queryLimitSpeed(soap, this, tag, type);
}

SOAP_FMAC3 ns1__queryLimitSpeed * SOAP_FMAC4 soap_get_ns1__queryLimitSpeed(struct soap *soap, ns1__queryLimitSpeed *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__queryLimitSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__loginResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__loginResponse::return_ = NULL;
}

void ns1__loginResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__loginResponse::return_);
#endif
}

int ns1__loginResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__loginResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__loginResponse(struct soap *soap, const char *tag, int id, const ns1__loginResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__loginResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->ns1__loginResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__loginResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__loginResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__loginResponse * SOAP_FMAC4 soap_in_ns1__loginResponse(struct soap *soap, const char *tag, ns1__loginResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__loginResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__loginResponse, sizeof(ns1__loginResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__loginResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__loginResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->ns1__loginResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__loginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__loginResponse, SOAP_TYPE_ns1__loginResponse, sizeof(ns1__loginResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__loginResponse * SOAP_FMAC2 soap_instantiate_ns1__loginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__loginResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__loginResponse *p;
	size_t k = sizeof(ns1__loginResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__loginResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__loginResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__loginResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__loginResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__loginResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__loginResponse(soap, tag ? tag : "ns1:loginResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__loginResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__loginResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__loginResponse * SOAP_FMAC4 soap_get_ns1__loginResponse(struct soap *soap, ns1__loginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__loginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__login::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__login::strDeviceId);
	soap_default_std__string(soap, &this->ns1__login::strDeviceKey);
}

void ns1__login::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__login::strDeviceId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__login::strDeviceId);
	soap_embedded(soap, &this->ns1__login::strDeviceKey, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__login::strDeviceKey);
#endif
}

int ns1__login::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__login(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__login(struct soap *soap, const char *tag, int id, const ns1__login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__login), type))
		return soap->error;
	if (soap_out_std__string(soap, "strDeviceId", -1, &a->ns1__login::strDeviceId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDeviceKey", -1, &a->ns1__login::strDeviceKey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__login::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__login(soap, tag, this, type);
}

SOAP_FMAC3 ns1__login * SOAP_FMAC4 soap_in_ns1__login(struct soap *soap, const char *tag, ns1__login *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__login*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__login, sizeof(ns1__login), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__login)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__login *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_strDeviceId1 = 1;
	size_t soap_flag_strDeviceKey1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strDeviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDeviceId", &a->ns1__login::strDeviceId, "xsd:string"))
				{	soap_flag_strDeviceId1--;
					continue;
				}
			}
			if (soap_flag_strDeviceKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDeviceKey", &a->ns1__login::strDeviceKey, "xsd:string"))
				{	soap_flag_strDeviceKey1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_strDeviceId1 > 0 || soap_flag_strDeviceKey1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__login *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__login, SOAP_TYPE_ns1__login, sizeof(ns1__login), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__login * SOAP_FMAC2 soap_instantiate_ns1__login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__login(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__login *p;
	size_t k = sizeof(ns1__login);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__login, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__login);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__login, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__login location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__login::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__login(soap, tag ? tag : "ns1:login", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__login::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__login(soap, this, tag, type);
}

SOAP_FMAC3 ns1__login * SOAP_FMAC4 soap_get_ns1__login(struct soap *soap, ns1__login *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__writeVehicleInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__writeVehicleInfoResponse::return_ = NULL;
}

void ns1__writeVehicleInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__writeVehicleInfoResponse::return_);
#endif
}

int ns1__writeVehicleInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__writeVehicleInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__writeVehicleInfoResponse(struct soap *soap, const char *tag, int id, const ns1__writeVehicleInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__writeVehicleInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->ns1__writeVehicleInfoResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__writeVehicleInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__writeVehicleInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__writeVehicleInfoResponse * SOAP_FMAC4 soap_in_ns1__writeVehicleInfoResponse(struct soap *soap, const char *tag, ns1__writeVehicleInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__writeVehicleInfoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__writeVehicleInfoResponse, sizeof(ns1__writeVehicleInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__writeVehicleInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__writeVehicleInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->ns1__writeVehicleInfoResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__writeVehicleInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__writeVehicleInfoResponse, SOAP_TYPE_ns1__writeVehicleInfoResponse, sizeof(ns1__writeVehicleInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__writeVehicleInfoResponse * SOAP_FMAC2 soap_instantiate_ns1__writeVehicleInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__writeVehicleInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__writeVehicleInfoResponse *p;
	size_t k = sizeof(ns1__writeVehicleInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__writeVehicleInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__writeVehicleInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__writeVehicleInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__writeVehicleInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__writeVehicleInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__writeVehicleInfoResponse(soap, tag ? tag : "ns1:writeVehicleInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__writeVehicleInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__writeVehicleInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__writeVehicleInfoResponse * SOAP_FMAC4 soap_get_ns1__writeVehicleInfoResponse(struct soap *soap, ns1__writeVehicleInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__writeVehicleInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__writeVehicleInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::sid);
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::strDeviceId);
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::strVehicleId);
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::strDeviceType);
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::strDirectionId);
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::strDriveWayId);
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::strLicense);
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::strLicenseType);
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::strPassDateTime);
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::strRedLightBeginTime);
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::strRedLightLast);
	soap_default_LONG64(soap, &this->ns1__writeVehicleInfo::lSpeed);
	soap_default_LONG64(soap, &this->ns1__writeVehicleInfo::lLargeLimitSpeed);
	soap_default_LONG64(soap, &this->ns1__writeVehicleInfo::lMiniLimitSpeed);
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::strViolationType);
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::strViolationType2);
	soap_default_LONG64(soap, &this->ns1__writeVehicleInfo::lCarLength);
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::strLicenseColor);
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::strCarType);
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::strPicLocalPath1);
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::strPicLocalPath2);
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::strPicLocalPath3);
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::strPicLocalPath4);
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::strPicLocalPath5);
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::strPicLocalPath6);
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::strPicLocalPath7);
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::strPicRemotePath);
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::strViolate);
	soap_default_std__string(soap, &this->ns1__writeVehicleInfo::strSendType);
}

void ns1__writeVehicleInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__writeVehicleInfo::sid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::sid);
	soap_embedded(soap, &this->ns1__writeVehicleInfo::strDeviceId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::strDeviceId);
	soap_embedded(soap, &this->ns1__writeVehicleInfo::strVehicleId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::strVehicleId);
	soap_embedded(soap, &this->ns1__writeVehicleInfo::strDeviceType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::strDeviceType);
	soap_embedded(soap, &this->ns1__writeVehicleInfo::strDirectionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::strDirectionId);
	soap_embedded(soap, &this->ns1__writeVehicleInfo::strDriveWayId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::strDriveWayId);
	soap_embedded(soap, &this->ns1__writeVehicleInfo::strLicense, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::strLicense);
	soap_embedded(soap, &this->ns1__writeVehicleInfo::strLicenseType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::strLicenseType);
	soap_embedded(soap, &this->ns1__writeVehicleInfo::strPassDateTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::strPassDateTime);
	soap_embedded(soap, &this->ns1__writeVehicleInfo::strRedLightBeginTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::strRedLightBeginTime);
	soap_embedded(soap, &this->ns1__writeVehicleInfo::strRedLightLast, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::strRedLightLast);
	soap_embedded(soap, &this->ns1__writeVehicleInfo::strViolationType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::strViolationType);
	soap_embedded(soap, &this->ns1__writeVehicleInfo::strViolationType2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::strViolationType2);
	soap_embedded(soap, &this->ns1__writeVehicleInfo::strLicenseColor, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::strLicenseColor);
	soap_embedded(soap, &this->ns1__writeVehicleInfo::strCarType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::strCarType);
	soap_embedded(soap, &this->ns1__writeVehicleInfo::strPicLocalPath1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::strPicLocalPath1);
	soap_embedded(soap, &this->ns1__writeVehicleInfo::strPicLocalPath2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::strPicLocalPath2);
	soap_embedded(soap, &this->ns1__writeVehicleInfo::strPicLocalPath3, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::strPicLocalPath3);
	soap_embedded(soap, &this->ns1__writeVehicleInfo::strPicLocalPath4, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::strPicLocalPath4);
	soap_embedded(soap, &this->ns1__writeVehicleInfo::strPicLocalPath5, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::strPicLocalPath5);
	soap_embedded(soap, &this->ns1__writeVehicleInfo::strPicLocalPath6, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::strPicLocalPath6);
	soap_embedded(soap, &this->ns1__writeVehicleInfo::strPicLocalPath7, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::strPicLocalPath7);
	soap_embedded(soap, &this->ns1__writeVehicleInfo::strPicRemotePath, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::strPicRemotePath);
	soap_embedded(soap, &this->ns1__writeVehicleInfo::strViolate, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::strViolate);
	soap_embedded(soap, &this->ns1__writeVehicleInfo::strSendType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__writeVehicleInfo::strSendType);
#endif
}

int ns1__writeVehicleInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__writeVehicleInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__writeVehicleInfo(struct soap *soap, const char *tag, int id, const ns1__writeVehicleInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__writeVehicleInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "sid", -1, &a->ns1__writeVehicleInfo::sid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDeviceId", -1, &a->ns1__writeVehicleInfo::strDeviceId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strVehicleId", -1, &a->ns1__writeVehicleInfo::strVehicleId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDeviceType", -1, &a->ns1__writeVehicleInfo::strDeviceType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDirectionId", -1, &a->ns1__writeVehicleInfo::strDirectionId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDriveWayId", -1, &a->ns1__writeVehicleInfo::strDriveWayId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strLicense", -1, &a->ns1__writeVehicleInfo::strLicense, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strLicenseType", -1, &a->ns1__writeVehicleInfo::strLicenseType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPassDateTime", -1, &a->ns1__writeVehicleInfo::strPassDateTime, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strRedLightBeginTime", -1, &a->ns1__writeVehicleInfo::strRedLightBeginTime, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strRedLightLast", -1, &a->ns1__writeVehicleInfo::strRedLightLast, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lSpeed", -1, &a->ns1__writeVehicleInfo::lSpeed, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lLargeLimitSpeed", -1, &a->ns1__writeVehicleInfo::lLargeLimitSpeed, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lMiniLimitSpeed", -1, &a->ns1__writeVehicleInfo::lMiniLimitSpeed, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strViolationType", -1, &a->ns1__writeVehicleInfo::strViolationType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strViolationType2", -1, &a->ns1__writeVehicleInfo::strViolationType2, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lCarLength", -1, &a->ns1__writeVehicleInfo::lCarLength, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strLicenseColor", -1, &a->ns1__writeVehicleInfo::strLicenseColor, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strCarType", -1, &a->ns1__writeVehicleInfo::strCarType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath1", -1, &a->ns1__writeVehicleInfo::strPicLocalPath1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath2", -1, &a->ns1__writeVehicleInfo::strPicLocalPath2, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath3", -1, &a->ns1__writeVehicleInfo::strPicLocalPath3, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath4", -1, &a->ns1__writeVehicleInfo::strPicLocalPath4, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath5", -1, &a->ns1__writeVehicleInfo::strPicLocalPath5, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath6", -1, &a->ns1__writeVehicleInfo::strPicLocalPath6, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicLocalPath7", -1, &a->ns1__writeVehicleInfo::strPicLocalPath7, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicRemotePath", -1, &a->ns1__writeVehicleInfo::strPicRemotePath, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strViolate", -1, &a->ns1__writeVehicleInfo::strViolate, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strSendType", -1, &a->ns1__writeVehicleInfo::strSendType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__writeVehicleInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__writeVehicleInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__writeVehicleInfo * SOAP_FMAC4 soap_in_ns1__writeVehicleInfo(struct soap *soap, const char *tag, ns1__writeVehicleInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__writeVehicleInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__writeVehicleInfo, sizeof(ns1__writeVehicleInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__writeVehicleInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__writeVehicleInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sid1 = 1;
	size_t soap_flag_strDeviceId1 = 1;
	size_t soap_flag_strVehicleId1 = 1;
	size_t soap_flag_strDeviceType1 = 1;
	size_t soap_flag_strDirectionId1 = 1;
	size_t soap_flag_strDriveWayId1 = 1;
	size_t soap_flag_strLicense1 = 1;
	size_t soap_flag_strLicenseType1 = 1;
	size_t soap_flag_strPassDateTime1 = 1;
	size_t soap_flag_strRedLightBeginTime1 = 1;
	size_t soap_flag_strRedLightLast1 = 1;
	size_t soap_flag_lSpeed1 = 1;
	size_t soap_flag_lLargeLimitSpeed1 = 1;
	size_t soap_flag_lMiniLimitSpeed1 = 1;
	size_t soap_flag_strViolationType1 = 1;
	size_t soap_flag_strViolationType21 = 1;
	size_t soap_flag_lCarLength1 = 1;
	size_t soap_flag_strLicenseColor1 = 1;
	size_t soap_flag_strCarType1 = 1;
	size_t soap_flag_strPicLocalPath11 = 1;
	size_t soap_flag_strPicLocalPath21 = 1;
	size_t soap_flag_strPicLocalPath31 = 1;
	size_t soap_flag_strPicLocalPath41 = 1;
	size_t soap_flag_strPicLocalPath51 = 1;
	size_t soap_flag_strPicLocalPath61 = 1;
	size_t soap_flag_strPicLocalPath71 = 1;
	size_t soap_flag_strPicRemotePath1 = 1;
	size_t soap_flag_strViolate1 = 1;
	size_t soap_flag_strSendType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sid", &a->ns1__writeVehicleInfo::sid, "xsd:string"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap_flag_strDeviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDeviceId", &a->ns1__writeVehicleInfo::strDeviceId, "xsd:string"))
				{	soap_flag_strDeviceId1--;
					continue;
				}
			}
			if (soap_flag_strVehicleId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strVehicleId", &a->ns1__writeVehicleInfo::strVehicleId, "xsd:string"))
				{	soap_flag_strVehicleId1--;
					continue;
				}
			}
			if (soap_flag_strDeviceType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDeviceType", &a->ns1__writeVehicleInfo::strDeviceType, "xsd:string"))
				{	soap_flag_strDeviceType1--;
					continue;
				}
			}
			if (soap_flag_strDirectionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDirectionId", &a->ns1__writeVehicleInfo::strDirectionId, "xsd:string"))
				{	soap_flag_strDirectionId1--;
					continue;
				}
			}
			if (soap_flag_strDriveWayId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDriveWayId", &a->ns1__writeVehicleInfo::strDriveWayId, "xsd:string"))
				{	soap_flag_strDriveWayId1--;
					continue;
				}
			}
			if (soap_flag_strLicense1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strLicense", &a->ns1__writeVehicleInfo::strLicense, "xsd:string"))
				{	soap_flag_strLicense1--;
					continue;
				}
			}
			if (soap_flag_strLicenseType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strLicenseType", &a->ns1__writeVehicleInfo::strLicenseType, "xsd:string"))
				{	soap_flag_strLicenseType1--;
					continue;
				}
			}
			if (soap_flag_strPassDateTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPassDateTime", &a->ns1__writeVehicleInfo::strPassDateTime, "xsd:string"))
				{	soap_flag_strPassDateTime1--;
					continue;
				}
			}
			if (soap_flag_strRedLightBeginTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strRedLightBeginTime", &a->ns1__writeVehicleInfo::strRedLightBeginTime, "xsd:string"))
				{	soap_flag_strRedLightBeginTime1--;
					continue;
				}
			}
			if (soap_flag_strRedLightLast1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strRedLightLast", &a->ns1__writeVehicleInfo::strRedLightLast, "xsd:string"))
				{	soap_flag_strRedLightLast1--;
					continue;
				}
			}
			if (soap_flag_lSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lSpeed", &a->ns1__writeVehicleInfo::lSpeed, "xsd:long"))
				{	soap_flag_lSpeed1--;
					continue;
				}
			}
			if (soap_flag_lLargeLimitSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lLargeLimitSpeed", &a->ns1__writeVehicleInfo::lLargeLimitSpeed, "xsd:long"))
				{	soap_flag_lLargeLimitSpeed1--;
					continue;
				}
			}
			if (soap_flag_lMiniLimitSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lMiniLimitSpeed", &a->ns1__writeVehicleInfo::lMiniLimitSpeed, "xsd:long"))
				{	soap_flag_lMiniLimitSpeed1--;
					continue;
				}
			}
			if (soap_flag_strViolationType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strViolationType", &a->ns1__writeVehicleInfo::strViolationType, "xsd:string"))
				{	soap_flag_strViolationType1--;
					continue;
				}
			}
			if (soap_flag_strViolationType21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strViolationType2", &a->ns1__writeVehicleInfo::strViolationType2, "xsd:string"))
				{	soap_flag_strViolationType21--;
					continue;
				}
			}
			if (soap_flag_lCarLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lCarLength", &a->ns1__writeVehicleInfo::lCarLength, "xsd:long"))
				{	soap_flag_lCarLength1--;
					continue;
				}
			}
			if (soap_flag_strLicenseColor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strLicenseColor", &a->ns1__writeVehicleInfo::strLicenseColor, "xsd:string"))
				{	soap_flag_strLicenseColor1--;
					continue;
				}
			}
			if (soap_flag_strCarType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strCarType", &a->ns1__writeVehicleInfo::strCarType, "xsd:string"))
				{	soap_flag_strCarType1--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath1", &a->ns1__writeVehicleInfo::strPicLocalPath1, "xsd:string"))
				{	soap_flag_strPicLocalPath11--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath2", &a->ns1__writeVehicleInfo::strPicLocalPath2, "xsd:string"))
				{	soap_flag_strPicLocalPath21--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath3", &a->ns1__writeVehicleInfo::strPicLocalPath3, "xsd:string"))
				{	soap_flag_strPicLocalPath31--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath4", &a->ns1__writeVehicleInfo::strPicLocalPath4, "xsd:string"))
				{	soap_flag_strPicLocalPath41--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath5", &a->ns1__writeVehicleInfo::strPicLocalPath5, "xsd:string"))
				{	soap_flag_strPicLocalPath51--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath61 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath6", &a->ns1__writeVehicleInfo::strPicLocalPath6, "xsd:string"))
				{	soap_flag_strPicLocalPath61--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath71 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicLocalPath7", &a->ns1__writeVehicleInfo::strPicLocalPath7, "xsd:string"))
				{	soap_flag_strPicLocalPath71--;
					continue;
				}
			}
			if (soap_flag_strPicRemotePath1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicRemotePath", &a->ns1__writeVehicleInfo::strPicRemotePath, "xsd:string"))
				{	soap_flag_strPicRemotePath1--;
					continue;
				}
			}
			if (soap_flag_strViolate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strViolate", &a->ns1__writeVehicleInfo::strViolate, "xsd:string"))
				{	soap_flag_strViolate1--;
					continue;
				}
			}
			if (soap_flag_strSendType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strSendType", &a->ns1__writeVehicleInfo::strSendType, "xsd:string"))
				{	soap_flag_strSendType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid1 > 0 || soap_flag_strDeviceId1 > 0 || soap_flag_strVehicleId1 > 0 || soap_flag_strDeviceType1 > 0 || soap_flag_strDirectionId1 > 0 || soap_flag_strDriveWayId1 > 0 || soap_flag_strLicense1 > 0 || soap_flag_strLicenseType1 > 0 || soap_flag_strPassDateTime1 > 0 || soap_flag_strRedLightBeginTime1 > 0 || soap_flag_strRedLightLast1 > 0 || soap_flag_lSpeed1 > 0 || soap_flag_lLargeLimitSpeed1 > 0 || soap_flag_lMiniLimitSpeed1 > 0 || soap_flag_strViolationType1 > 0 || soap_flag_strViolationType21 > 0 || soap_flag_lCarLength1 > 0 || soap_flag_strLicenseColor1 > 0 || soap_flag_strCarType1 > 0 || soap_flag_strPicLocalPath11 > 0 || soap_flag_strPicLocalPath21 > 0 || soap_flag_strPicLocalPath31 > 0 || soap_flag_strPicLocalPath41 > 0 || soap_flag_strPicLocalPath51 > 0 || soap_flag_strPicLocalPath61 > 0 || soap_flag_strPicLocalPath71 > 0 || soap_flag_strPicRemotePath1 > 0 || soap_flag_strViolate1 > 0 || soap_flag_strSendType1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__writeVehicleInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__writeVehicleInfo, SOAP_TYPE_ns1__writeVehicleInfo, sizeof(ns1__writeVehicleInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__writeVehicleInfo * SOAP_FMAC2 soap_instantiate_ns1__writeVehicleInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__writeVehicleInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__writeVehicleInfo *p;
	size_t k = sizeof(ns1__writeVehicleInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__writeVehicleInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__writeVehicleInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__writeVehicleInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__writeVehicleInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__writeVehicleInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__writeVehicleInfo(soap, tag ? tag : "ns1:writeVehicleInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__writeVehicleInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__writeVehicleInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__writeVehicleInfo * SOAP_FMAC4 soap_get_ns1__writeVehicleInfo(struct soap *soap, ns1__writeVehicleInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__writeVehicleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__syncWriteVehicleInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__syncWriteVehicleInfoResponse::return_ = NULL;
}

void ns1__syncWriteVehicleInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__syncWriteVehicleInfoResponse::return_);
#endif
}

int ns1__syncWriteVehicleInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__syncWriteVehicleInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__syncWriteVehicleInfoResponse(struct soap *soap, const char *tag, int id, const ns1__syncWriteVehicleInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__syncWriteVehicleInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->ns1__syncWriteVehicleInfoResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__syncWriteVehicleInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__syncWriteVehicleInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__syncWriteVehicleInfoResponse * SOAP_FMAC4 soap_in_ns1__syncWriteVehicleInfoResponse(struct soap *soap, const char *tag, ns1__syncWriteVehicleInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__syncWriteVehicleInfoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__syncWriteVehicleInfoResponse, sizeof(ns1__syncWriteVehicleInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__syncWriteVehicleInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__syncWriteVehicleInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->ns1__syncWriteVehicleInfoResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__syncWriteVehicleInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__syncWriteVehicleInfoResponse, SOAP_TYPE_ns1__syncWriteVehicleInfoResponse, sizeof(ns1__syncWriteVehicleInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__syncWriteVehicleInfoResponse * SOAP_FMAC2 soap_instantiate_ns1__syncWriteVehicleInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__syncWriteVehicleInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__syncWriteVehicleInfoResponse *p;
	size_t k = sizeof(ns1__syncWriteVehicleInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__syncWriteVehicleInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__syncWriteVehicleInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__syncWriteVehicleInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__syncWriteVehicleInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__syncWriteVehicleInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__syncWriteVehicleInfoResponse(soap, tag ? tag : "ns1:syncWriteVehicleInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__syncWriteVehicleInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__syncWriteVehicleInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__syncWriteVehicleInfoResponse * SOAP_FMAC4 soap_get_ns1__syncWriteVehicleInfoResponse(struct soap *soap, ns1__syncWriteVehicleInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__syncWriteVehicleInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__syncWriteVehicleInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__syncWriteVehicleInfo::sid);
	soap_default_std__string(soap, &this->ns1__syncWriteVehicleInfo::strDeviceId);
	soap_default_std__string(soap, &this->ns1__syncWriteVehicleInfo::strVehicleId);
	soap_default_std__string(soap, &this->ns1__syncWriteVehicleInfo::strDeviceType);
	soap_default_std__string(soap, &this->ns1__syncWriteVehicleInfo::strDirectionId);
	soap_default_std__string(soap, &this->ns1__syncWriteVehicleInfo::strDriveWayId);
	soap_default_std__string(soap, &this->ns1__syncWriteVehicleInfo::strLicense);
	soap_default_std__string(soap, &this->ns1__syncWriteVehicleInfo::strLicenseType);
	soap_default_std__string(soap, &this->ns1__syncWriteVehicleInfo::strPassDateTime);
	soap_default_std__string(soap, &this->ns1__syncWriteVehicleInfo::strRedLightBeginTime);
	soap_default_std__string(soap, &this->ns1__syncWriteVehicleInfo::strRedLightLast);
	soap_default_LONG64(soap, &this->ns1__syncWriteVehicleInfo::lSpeed);
	soap_default_LONG64(soap, &this->ns1__syncWriteVehicleInfo::lLargeLimitSpeed);
	soap_default_LONG64(soap, &this->ns1__syncWriteVehicleInfo::lMiniLimitSpeed);
	soap_default_std__string(soap, &this->ns1__syncWriteVehicleInfo::strViolationType);
	soap_default_std__string(soap, &this->ns1__syncWriteVehicleInfo::strViolationType2);
	soap_default_LONG64(soap, &this->ns1__syncWriteVehicleInfo::lCarLength);
	soap_default_std__string(soap, &this->ns1__syncWriteVehicleInfo::strLicenseColor);
	soap_default_std__string(soap, &this->ns1__syncWriteVehicleInfo::strCarType);
	this->ns1__syncWriteVehicleInfo::strPicLocalPath1.xsd__base64Binary::soap_default(soap);
	this->ns1__syncWriteVehicleInfo::strPicLocalPath2.xsd__base64Binary::soap_default(soap);
	this->ns1__syncWriteVehicleInfo::strPicLocalPath3.xsd__base64Binary::soap_default(soap);
	this->ns1__syncWriteVehicleInfo::strPicLocalPath4.xsd__base64Binary::soap_default(soap);
	this->ns1__syncWriteVehicleInfo::strPicLocalPath5.xsd__base64Binary::soap_default(soap);
	this->ns1__syncWriteVehicleInfo::strPicLocalPath6.xsd__base64Binary::soap_default(soap);
	this->ns1__syncWriteVehicleInfo::strPicLocalPath7.xsd__base64Binary::soap_default(soap);
	soap_default_std__string(soap, &this->ns1__syncWriteVehicleInfo::strPicRemotePath);
	soap_default_std__string(soap, &this->ns1__syncWriteVehicleInfo::strViolate);
	soap_default_std__string(soap, &this->ns1__syncWriteVehicleInfo::strSendType);
}

void ns1__syncWriteVehicleInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__syncWriteVehicleInfo::sid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__syncWriteVehicleInfo::sid);
	soap_embedded(soap, &this->ns1__syncWriteVehicleInfo::strDeviceId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__syncWriteVehicleInfo::strDeviceId);
	soap_embedded(soap, &this->ns1__syncWriteVehicleInfo::strVehicleId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__syncWriteVehicleInfo::strVehicleId);
	soap_embedded(soap, &this->ns1__syncWriteVehicleInfo::strDeviceType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__syncWriteVehicleInfo::strDeviceType);
	soap_embedded(soap, &this->ns1__syncWriteVehicleInfo::strDirectionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__syncWriteVehicleInfo::strDirectionId);
	soap_embedded(soap, &this->ns1__syncWriteVehicleInfo::strDriveWayId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__syncWriteVehicleInfo::strDriveWayId);
	soap_embedded(soap, &this->ns1__syncWriteVehicleInfo::strLicense, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__syncWriteVehicleInfo::strLicense);
	soap_embedded(soap, &this->ns1__syncWriteVehicleInfo::strLicenseType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__syncWriteVehicleInfo::strLicenseType);
	soap_embedded(soap, &this->ns1__syncWriteVehicleInfo::strPassDateTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__syncWriteVehicleInfo::strPassDateTime);
	soap_embedded(soap, &this->ns1__syncWriteVehicleInfo::strRedLightBeginTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__syncWriteVehicleInfo::strRedLightBeginTime);
	soap_embedded(soap, &this->ns1__syncWriteVehicleInfo::strRedLightLast, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__syncWriteVehicleInfo::strRedLightLast);
	soap_embedded(soap, &this->ns1__syncWriteVehicleInfo::strViolationType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__syncWriteVehicleInfo::strViolationType);
	soap_embedded(soap, &this->ns1__syncWriteVehicleInfo::strViolationType2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__syncWriteVehicleInfo::strViolationType2);
	soap_embedded(soap, &this->ns1__syncWriteVehicleInfo::strLicenseColor, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__syncWriteVehicleInfo::strLicenseColor);
	soap_embedded(soap, &this->ns1__syncWriteVehicleInfo::strCarType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__syncWriteVehicleInfo::strCarType);
	this->ns1__syncWriteVehicleInfo::strPicLocalPath1.soap_serialize(soap);
	this->ns1__syncWriteVehicleInfo::strPicLocalPath2.soap_serialize(soap);
	this->ns1__syncWriteVehicleInfo::strPicLocalPath3.soap_serialize(soap);
	this->ns1__syncWriteVehicleInfo::strPicLocalPath4.soap_serialize(soap);
	this->ns1__syncWriteVehicleInfo::strPicLocalPath5.soap_serialize(soap);
	this->ns1__syncWriteVehicleInfo::strPicLocalPath6.soap_serialize(soap);
	this->ns1__syncWriteVehicleInfo::strPicLocalPath7.soap_serialize(soap);
	soap_embedded(soap, &this->ns1__syncWriteVehicleInfo::strPicRemotePath, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__syncWriteVehicleInfo::strPicRemotePath);
	soap_embedded(soap, &this->ns1__syncWriteVehicleInfo::strViolate, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__syncWriteVehicleInfo::strViolate);
	soap_embedded(soap, &this->ns1__syncWriteVehicleInfo::strSendType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__syncWriteVehicleInfo::strSendType);
#endif
}

int ns1__syncWriteVehicleInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__syncWriteVehicleInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__syncWriteVehicleInfo(struct soap *soap, const char *tag, int id, const ns1__syncWriteVehicleInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__syncWriteVehicleInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "sid", -1, &a->ns1__syncWriteVehicleInfo::sid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDeviceId", -1, &a->ns1__syncWriteVehicleInfo::strDeviceId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strVehicleId", -1, &a->ns1__syncWriteVehicleInfo::strVehicleId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDeviceType", -1, &a->ns1__syncWriteVehicleInfo::strDeviceType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDirectionId", -1, &a->ns1__syncWriteVehicleInfo::strDirectionId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strDriveWayId", -1, &a->ns1__syncWriteVehicleInfo::strDriveWayId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strLicense", -1, &a->ns1__syncWriteVehicleInfo::strLicense, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strLicenseType", -1, &a->ns1__syncWriteVehicleInfo::strLicenseType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPassDateTime", -1, &a->ns1__syncWriteVehicleInfo::strPassDateTime, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strRedLightBeginTime", -1, &a->ns1__syncWriteVehicleInfo::strRedLightBeginTime, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strRedLightLast", -1, &a->ns1__syncWriteVehicleInfo::strRedLightLast, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lSpeed", -1, &a->ns1__syncWriteVehicleInfo::lSpeed, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lLargeLimitSpeed", -1, &a->ns1__syncWriteVehicleInfo::lLargeLimitSpeed, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lMiniLimitSpeed", -1, &a->ns1__syncWriteVehicleInfo::lMiniLimitSpeed, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strViolationType", -1, &a->ns1__syncWriteVehicleInfo::strViolationType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strViolationType2", -1, &a->ns1__syncWriteVehicleInfo::strViolationType2, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "lCarLength", -1, &a->ns1__syncWriteVehicleInfo::lCarLength, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strLicenseColor", -1, &a->ns1__syncWriteVehicleInfo::strLicenseColor, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strCarType", -1, &a->ns1__syncWriteVehicleInfo::strCarType, ""))
		return soap->error;
	if ((a->ns1__syncWriteVehicleInfo::strPicLocalPath1).soap_out(soap, "strPicLocalPath1", -1, ""))
		return soap->error;
	if ((a->ns1__syncWriteVehicleInfo::strPicLocalPath2).soap_out(soap, "strPicLocalPath2", -1, ""))
		return soap->error;
	if ((a->ns1__syncWriteVehicleInfo::strPicLocalPath3).soap_out(soap, "strPicLocalPath3", -1, ""))
		return soap->error;
	if ((a->ns1__syncWriteVehicleInfo::strPicLocalPath4).soap_out(soap, "strPicLocalPath4", -1, ""))
		return soap->error;
	if ((a->ns1__syncWriteVehicleInfo::strPicLocalPath5).soap_out(soap, "strPicLocalPath5", -1, ""))
		return soap->error;
	if ((a->ns1__syncWriteVehicleInfo::strPicLocalPath6).soap_out(soap, "strPicLocalPath6", -1, ""))
		return soap->error;
	if ((a->ns1__syncWriteVehicleInfo::strPicLocalPath7).soap_out(soap, "strPicLocalPath7", -1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strPicRemotePath", -1, &a->ns1__syncWriteVehicleInfo::strPicRemotePath, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strViolate", -1, &a->ns1__syncWriteVehicleInfo::strViolate, ""))
		return soap->error;
	if (soap_out_std__string(soap, "strSendType", -1, &a->ns1__syncWriteVehicleInfo::strSendType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__syncWriteVehicleInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__syncWriteVehicleInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__syncWriteVehicleInfo * SOAP_FMAC4 soap_in_ns1__syncWriteVehicleInfo(struct soap *soap, const char *tag, ns1__syncWriteVehicleInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__syncWriteVehicleInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__syncWriteVehicleInfo, sizeof(ns1__syncWriteVehicleInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__syncWriteVehicleInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__syncWriteVehicleInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sid1 = 1;
	size_t soap_flag_strDeviceId1 = 1;
	size_t soap_flag_strVehicleId1 = 1;
	size_t soap_flag_strDeviceType1 = 1;
	size_t soap_flag_strDirectionId1 = 1;
	size_t soap_flag_strDriveWayId1 = 1;
	size_t soap_flag_strLicense1 = 1;
	size_t soap_flag_strLicenseType1 = 1;
	size_t soap_flag_strPassDateTime1 = 1;
	size_t soap_flag_strRedLightBeginTime1 = 1;
	size_t soap_flag_strRedLightLast1 = 1;
	size_t soap_flag_lSpeed1 = 1;
	size_t soap_flag_lLargeLimitSpeed1 = 1;
	size_t soap_flag_lMiniLimitSpeed1 = 1;
	size_t soap_flag_strViolationType1 = 1;
	size_t soap_flag_strViolationType21 = 1;
	size_t soap_flag_lCarLength1 = 1;
	size_t soap_flag_strLicenseColor1 = 1;
	size_t soap_flag_strCarType1 = 1;
	size_t soap_flag_strPicLocalPath11 = 1;
	size_t soap_flag_strPicLocalPath21 = 1;
	size_t soap_flag_strPicLocalPath31 = 1;
	size_t soap_flag_strPicLocalPath41 = 1;
	size_t soap_flag_strPicLocalPath51 = 1;
	size_t soap_flag_strPicLocalPath61 = 1;
	size_t soap_flag_strPicLocalPath71 = 1;
	size_t soap_flag_strPicRemotePath1 = 1;
	size_t soap_flag_strViolate1 = 1;
	size_t soap_flag_strSendType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sid", &a->ns1__syncWriteVehicleInfo::sid, "xsd:string"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap_flag_strDeviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDeviceId", &a->ns1__syncWriteVehicleInfo::strDeviceId, "xsd:string"))
				{	soap_flag_strDeviceId1--;
					continue;
				}
			}
			if (soap_flag_strVehicleId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strVehicleId", &a->ns1__syncWriteVehicleInfo::strVehicleId, "xsd:string"))
				{	soap_flag_strVehicleId1--;
					continue;
				}
			}
			if (soap_flag_strDeviceType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDeviceType", &a->ns1__syncWriteVehicleInfo::strDeviceType, "xsd:string"))
				{	soap_flag_strDeviceType1--;
					continue;
				}
			}
			if (soap_flag_strDirectionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDirectionId", &a->ns1__syncWriteVehicleInfo::strDirectionId, "xsd:string"))
				{	soap_flag_strDirectionId1--;
					continue;
				}
			}
			if (soap_flag_strDriveWayId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strDriveWayId", &a->ns1__syncWriteVehicleInfo::strDriveWayId, "xsd:string"))
				{	soap_flag_strDriveWayId1--;
					continue;
				}
			}
			if (soap_flag_strLicense1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strLicense", &a->ns1__syncWriteVehicleInfo::strLicense, "xsd:string"))
				{	soap_flag_strLicense1--;
					continue;
				}
			}
			if (soap_flag_strLicenseType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strLicenseType", &a->ns1__syncWriteVehicleInfo::strLicenseType, "xsd:string"))
				{	soap_flag_strLicenseType1--;
					continue;
				}
			}
			if (soap_flag_strPassDateTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPassDateTime", &a->ns1__syncWriteVehicleInfo::strPassDateTime, "xsd:string"))
				{	soap_flag_strPassDateTime1--;
					continue;
				}
			}
			if (soap_flag_strRedLightBeginTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strRedLightBeginTime", &a->ns1__syncWriteVehicleInfo::strRedLightBeginTime, "xsd:string"))
				{	soap_flag_strRedLightBeginTime1--;
					continue;
				}
			}
			if (soap_flag_strRedLightLast1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strRedLightLast", &a->ns1__syncWriteVehicleInfo::strRedLightLast, "xsd:string"))
				{	soap_flag_strRedLightLast1--;
					continue;
				}
			}
			if (soap_flag_lSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lSpeed", &a->ns1__syncWriteVehicleInfo::lSpeed, "xsd:long"))
				{	soap_flag_lSpeed1--;
					continue;
				}
			}
			if (soap_flag_lLargeLimitSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lLargeLimitSpeed", &a->ns1__syncWriteVehicleInfo::lLargeLimitSpeed, "xsd:long"))
				{	soap_flag_lLargeLimitSpeed1--;
					continue;
				}
			}
			if (soap_flag_lMiniLimitSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lMiniLimitSpeed", &a->ns1__syncWriteVehicleInfo::lMiniLimitSpeed, "xsd:long"))
				{	soap_flag_lMiniLimitSpeed1--;
					continue;
				}
			}
			if (soap_flag_strViolationType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strViolationType", &a->ns1__syncWriteVehicleInfo::strViolationType, "xsd:string"))
				{	soap_flag_strViolationType1--;
					continue;
				}
			}
			if (soap_flag_strViolationType21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strViolationType2", &a->ns1__syncWriteVehicleInfo::strViolationType2, "xsd:string"))
				{	soap_flag_strViolationType21--;
					continue;
				}
			}
			if (soap_flag_lCarLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "lCarLength", &a->ns1__syncWriteVehicleInfo::lCarLength, "xsd:long"))
				{	soap_flag_lCarLength1--;
					continue;
				}
			}
			if (soap_flag_strLicenseColor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strLicenseColor", &a->ns1__syncWriteVehicleInfo::strLicenseColor, "xsd:string"))
				{	soap_flag_strLicenseColor1--;
					continue;
				}
			}
			if (soap_flag_strCarType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strCarType", &a->ns1__syncWriteVehicleInfo::strCarType, "xsd:string"))
				{	soap_flag_strCarType1--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath11 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__syncWriteVehicleInfo::strPicLocalPath1).soap_in(soap, "strPicLocalPath1", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath11--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath21 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__syncWriteVehicleInfo::strPicLocalPath2).soap_in(soap, "strPicLocalPath2", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath21--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath31 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__syncWriteVehicleInfo::strPicLocalPath3).soap_in(soap, "strPicLocalPath3", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath31--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath41 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__syncWriteVehicleInfo::strPicLocalPath4).soap_in(soap, "strPicLocalPath4", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath41--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath51 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__syncWriteVehicleInfo::strPicLocalPath5).soap_in(soap, "strPicLocalPath5", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath51--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath61 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__syncWriteVehicleInfo::strPicLocalPath6).soap_in(soap, "strPicLocalPath6", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath61--;
					continue;
				}
			}
			if (soap_flag_strPicLocalPath71 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns1__syncWriteVehicleInfo::strPicLocalPath7).soap_in(soap, "strPicLocalPath7", "xsd:base64Binary"))
				{	soap_flag_strPicLocalPath71--;
					continue;
				}
			}
			if (soap_flag_strPicRemotePath1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strPicRemotePath", &a->ns1__syncWriteVehicleInfo::strPicRemotePath, "xsd:string"))
				{	soap_flag_strPicRemotePath1--;
					continue;
				}
			}
			if (soap_flag_strViolate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strViolate", &a->ns1__syncWriteVehicleInfo::strViolate, "xsd:string"))
				{	soap_flag_strViolate1--;
					continue;
				}
			}
			if (soap_flag_strSendType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "strSendType", &a->ns1__syncWriteVehicleInfo::strSendType, "xsd:string"))
				{	soap_flag_strSendType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid1 > 0 || soap_flag_strDeviceId1 > 0 || soap_flag_strVehicleId1 > 0 || soap_flag_strDeviceType1 > 0 || soap_flag_strDirectionId1 > 0 || soap_flag_strDriveWayId1 > 0 || soap_flag_strLicense1 > 0 || soap_flag_strLicenseType1 > 0 || soap_flag_strPassDateTime1 > 0 || soap_flag_strRedLightBeginTime1 > 0 || soap_flag_strRedLightLast1 > 0 || soap_flag_lSpeed1 > 0 || soap_flag_lLargeLimitSpeed1 > 0 || soap_flag_lMiniLimitSpeed1 > 0 || soap_flag_strViolationType1 > 0 || soap_flag_strViolationType21 > 0 || soap_flag_lCarLength1 > 0 || soap_flag_strLicenseColor1 > 0 || soap_flag_strCarType1 > 0 || soap_flag_strPicLocalPath11 > 0 || soap_flag_strPicLocalPath21 > 0 || soap_flag_strPicLocalPath31 > 0 || soap_flag_strPicLocalPath41 > 0 || soap_flag_strPicLocalPath51 > 0 || soap_flag_strPicLocalPath61 > 0 || soap_flag_strPicLocalPath71 > 0 || soap_flag_strPicRemotePath1 > 0 || soap_flag_strViolate1 > 0 || soap_flag_strSendType1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__syncWriteVehicleInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__syncWriteVehicleInfo, SOAP_TYPE_ns1__syncWriteVehicleInfo, sizeof(ns1__syncWriteVehicleInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__syncWriteVehicleInfo * SOAP_FMAC2 soap_instantiate_ns1__syncWriteVehicleInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__syncWriteVehicleInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__syncWriteVehicleInfo *p;
	size_t k = sizeof(ns1__syncWriteVehicleInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__syncWriteVehicleInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__syncWriteVehicleInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__syncWriteVehicleInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__syncWriteVehicleInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__syncWriteVehicleInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__syncWriteVehicleInfo(soap, tag ? tag : "ns1:syncWriteVehicleInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__syncWriteVehicleInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__syncWriteVehicleInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__syncWriteVehicleInfo * SOAP_FMAC4 soap_get_ns1__syncWriteVehicleInfo(struct soap *soap, ns1__syncWriteVehicleInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__syncWriteVehicleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Exception::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Exception::message = NULL;
}

void ns1__Exception::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__Exception::message);
#endif
}

int ns1__Exception::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Exception(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Exception(struct soap *soap, const char *tag, int id, const ns1__Exception *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Exception), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &a->ns1__Exception::message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Exception::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Exception(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Exception * SOAP_FMAC4 soap_in_ns1__Exception(struct soap *soap, const char *tag, ns1__Exception *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Exception*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Exception, sizeof(ns1__Exception), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Exception)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Exception *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_message1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "message", &a->ns1__Exception::message, "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Exception *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Exception, SOAP_TYPE_ns1__Exception, sizeof(ns1__Exception), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Exception * SOAP_FMAC2 soap_instantiate_ns1__Exception(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Exception(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Exception *p;
	size_t k = sizeof(ns1__Exception);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Exception, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Exception);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Exception, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Exception location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Exception::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Exception(soap, tag ? tag : "ns1:Exception", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Exception::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Exception(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Exception * SOAP_FMAC4 soap_get_ns1__Exception(struct soap *soap, ns1__Exception *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Exception(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ptr = NULL;
	this->__size = 0;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr)
		(void)soap_attachment_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_xsd__base64Binary, this->id, this->type);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__base64Binary2s(struct soap *soap, xsd__base64Binary a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_xsd__base64Binary, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__base64Binary(struct soap *soap, const char *s, xsd__base64Binary *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__base64Binary *p;
	size_t k = sizeof(xsd__base64Binary);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__base64Binary);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__base64Binary, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__base64Binary location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__base64Binary(soap, tag ? tag : "xsd:base64Binary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__WriteAreaSpeed(struct soap *soap, struct __ns1__WriteAreaSpeed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__WriteAreaSpeed_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__WriteAreaSpeed(struct soap *soap, const struct __ns1__WriteAreaSpeed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__WriteAreaSpeed(soap, &a->ns1__WriteAreaSpeed_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__WriteAreaSpeed(struct soap *soap, const char *tag, int id, const struct __ns1__WriteAreaSpeed *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__WriteAreaSpeed(soap, "ns1:WriteAreaSpeed", -1, &a->ns1__WriteAreaSpeed_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__WriteAreaSpeed * SOAP_FMAC4 soap_in___ns1__WriteAreaSpeed(struct soap *soap, const char *tag, struct __ns1__WriteAreaSpeed *a, const char *type)
{
	size_t soap_flag_ns1__WriteAreaSpeed_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__WriteAreaSpeed*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__WriteAreaSpeed, sizeof(struct __ns1__WriteAreaSpeed), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__WriteAreaSpeed(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__WriteAreaSpeed_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__WriteAreaSpeed(soap, "ns1:WriteAreaSpeed", &a->ns1__WriteAreaSpeed_, "ns1:WriteAreaSpeed"))
				{	soap_flag_ns1__WriteAreaSpeed_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__WriteAreaSpeed * SOAP_FMAC2 soap_instantiate___ns1__WriteAreaSpeed(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__WriteAreaSpeed(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__WriteAreaSpeed *p;
	size_t k = sizeof(struct __ns1__WriteAreaSpeed);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__WriteAreaSpeed, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__WriteAreaSpeed);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__WriteAreaSpeed, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__WriteAreaSpeed location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__WriteAreaSpeed(struct soap *soap, const struct __ns1__WriteAreaSpeed *a, const char *tag, const char *type)
{
	if (soap_out___ns1__WriteAreaSpeed(soap, tag ? tag : "-ns1:WriteAreaSpeed", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__WriteAreaSpeed * SOAP_FMAC4 soap_get___ns1__WriteAreaSpeed(struct soap *soap, struct __ns1__WriteAreaSpeed *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__WriteAreaSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SyncWriteAreaSpeed(struct soap *soap, struct __ns1__SyncWriteAreaSpeed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SyncWriteAreaSpeed_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SyncWriteAreaSpeed(struct soap *soap, const struct __ns1__SyncWriteAreaSpeed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SyncWriteAreaSpeed(soap, &a->ns1__SyncWriteAreaSpeed_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SyncWriteAreaSpeed(struct soap *soap, const char *tag, int id, const struct __ns1__SyncWriteAreaSpeed *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SyncWriteAreaSpeed(soap, "ns1:SyncWriteAreaSpeed", -1, &a->ns1__SyncWriteAreaSpeed_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SyncWriteAreaSpeed * SOAP_FMAC4 soap_in___ns1__SyncWriteAreaSpeed(struct soap *soap, const char *tag, struct __ns1__SyncWriteAreaSpeed *a, const char *type)
{
	size_t soap_flag_ns1__SyncWriteAreaSpeed_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SyncWriteAreaSpeed*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SyncWriteAreaSpeed, sizeof(struct __ns1__SyncWriteAreaSpeed), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SyncWriteAreaSpeed(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SyncWriteAreaSpeed_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SyncWriteAreaSpeed(soap, "ns1:SyncWriteAreaSpeed", &a->ns1__SyncWriteAreaSpeed_, "ns1:SyncWriteAreaSpeed"))
				{	soap_flag_ns1__SyncWriteAreaSpeed_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SyncWriteAreaSpeed * SOAP_FMAC2 soap_instantiate___ns1__SyncWriteAreaSpeed(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SyncWriteAreaSpeed(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SyncWriteAreaSpeed *p;
	size_t k = sizeof(struct __ns1__SyncWriteAreaSpeed);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__SyncWriteAreaSpeed, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__SyncWriteAreaSpeed);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__SyncWriteAreaSpeed, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SyncWriteAreaSpeed location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SyncWriteAreaSpeed(struct soap *soap, const struct __ns1__SyncWriteAreaSpeed *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SyncWriteAreaSpeed(soap, tag ? tag : "-ns1:SyncWriteAreaSpeed", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SyncWriteAreaSpeed * SOAP_FMAC4 soap_get___ns1__SyncWriteAreaSpeed(struct soap *soap, struct __ns1__SyncWriteAreaSpeed *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SyncWriteAreaSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__WriteVehPassInfo(struct soap *soap, struct __ns1__WriteVehPassInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__WriteVehPassInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__WriteVehPassInfo(struct soap *soap, const struct __ns1__WriteVehPassInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__WriteVehPassInfo(soap, &a->ns1__WriteVehPassInfo_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__WriteVehPassInfo(struct soap *soap, const char *tag, int id, const struct __ns1__WriteVehPassInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__WriteVehPassInfo(soap, "ns1:WriteVehPassInfo", -1, &a->ns1__WriteVehPassInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__WriteVehPassInfo * SOAP_FMAC4 soap_in___ns1__WriteVehPassInfo(struct soap *soap, const char *tag, struct __ns1__WriteVehPassInfo *a, const char *type)
{
	size_t soap_flag_ns1__WriteVehPassInfo_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__WriteVehPassInfo*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__WriteVehPassInfo, sizeof(struct __ns1__WriteVehPassInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__WriteVehPassInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__WriteVehPassInfo_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__WriteVehPassInfo(soap, "ns1:WriteVehPassInfo", &a->ns1__WriteVehPassInfo_, "ns1:WriteVehPassInfo"))
				{	soap_flag_ns1__WriteVehPassInfo_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__WriteVehPassInfo * SOAP_FMAC2 soap_instantiate___ns1__WriteVehPassInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__WriteVehPassInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__WriteVehPassInfo *p;
	size_t k = sizeof(struct __ns1__WriteVehPassInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__WriteVehPassInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__WriteVehPassInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__WriteVehPassInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__WriteVehPassInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__WriteVehPassInfo(struct soap *soap, const struct __ns1__WriteVehPassInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__WriteVehPassInfo(soap, tag ? tag : "-ns1:WriteVehPassInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__WriteVehPassInfo * SOAP_FMAC4 soap_get___ns1__WriteVehPassInfo(struct soap *soap, struct __ns1__WriteVehPassInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__WriteVehPassInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SyncWriteVehPassInfo(struct soap *soap, struct __ns1__SyncWriteVehPassInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SyncWriteVehPassInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SyncWriteVehPassInfo(struct soap *soap, const struct __ns1__SyncWriteVehPassInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SyncWriteVehPassInfo(soap, &a->ns1__SyncWriteVehPassInfo_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SyncWriteVehPassInfo(struct soap *soap, const char *tag, int id, const struct __ns1__SyncWriteVehPassInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SyncWriteVehPassInfo(soap, "ns1:SyncWriteVehPassInfo", -1, &a->ns1__SyncWriteVehPassInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SyncWriteVehPassInfo * SOAP_FMAC4 soap_in___ns1__SyncWriteVehPassInfo(struct soap *soap, const char *tag, struct __ns1__SyncWriteVehPassInfo *a, const char *type)
{
	size_t soap_flag_ns1__SyncWriteVehPassInfo_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SyncWriteVehPassInfo*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SyncWriteVehPassInfo, sizeof(struct __ns1__SyncWriteVehPassInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SyncWriteVehPassInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SyncWriteVehPassInfo_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SyncWriteVehPassInfo(soap, "ns1:SyncWriteVehPassInfo", &a->ns1__SyncWriteVehPassInfo_, "ns1:SyncWriteVehPassInfo"))
				{	soap_flag_ns1__SyncWriteVehPassInfo_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SyncWriteVehPassInfo * SOAP_FMAC2 soap_instantiate___ns1__SyncWriteVehPassInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SyncWriteVehPassInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SyncWriteVehPassInfo *p;
	size_t k = sizeof(struct __ns1__SyncWriteVehPassInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__SyncWriteVehPassInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__SyncWriteVehPassInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__SyncWriteVehPassInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SyncWriteVehPassInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SyncWriteVehPassInfo(struct soap *soap, const struct __ns1__SyncWriteVehPassInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SyncWriteVehPassInfo(soap, tag ? tag : "-ns1:SyncWriteVehPassInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SyncWriteVehPassInfo * SOAP_FMAC4 soap_get___ns1__SyncWriteVehPassInfo(struct soap *soap, struct __ns1__SyncWriteVehPassInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SyncWriteVehPassInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__NWritePassStat(struct soap *soap, struct __ns1__NWritePassStat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__NWritePassStat_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__NWritePassStat(struct soap *soap, const struct __ns1__NWritePassStat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__NWritePassStat(soap, &a->ns1__NWritePassStat_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__NWritePassStat(struct soap *soap, const char *tag, int id, const struct __ns1__NWritePassStat *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__NWritePassStat(soap, "ns1:NWritePassStat", -1, &a->ns1__NWritePassStat_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NWritePassStat * SOAP_FMAC4 soap_in___ns1__NWritePassStat(struct soap *soap, const char *tag, struct __ns1__NWritePassStat *a, const char *type)
{
	size_t soap_flag_ns1__NWritePassStat_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__NWritePassStat*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__NWritePassStat, sizeof(struct __ns1__NWritePassStat), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__NWritePassStat(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__NWritePassStat_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__NWritePassStat(soap, "ns1:NWritePassStat", &a->ns1__NWritePassStat_, "ns1:NWritePassStat"))
				{	soap_flag_ns1__NWritePassStat_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__NWritePassStat * SOAP_FMAC2 soap_instantiate___ns1__NWritePassStat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__NWritePassStat(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__NWritePassStat *p;
	size_t k = sizeof(struct __ns1__NWritePassStat);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__NWritePassStat, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__NWritePassStat);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__NWritePassStat, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__NWritePassStat location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__NWritePassStat(struct soap *soap, const struct __ns1__NWritePassStat *a, const char *tag, const char *type)
{
	if (soap_out___ns1__NWritePassStat(soap, tag ? tag : "-ns1:NWritePassStat", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NWritePassStat * SOAP_FMAC4 soap_get___ns1__NWritePassStat(struct soap *soap, struct __ns1__NWritePassStat *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__NWritePassStat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__NSyncWriteVioInfo(struct soap *soap, struct __ns1__NSyncWriteVioInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__NSyncWriteVioInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__NSyncWriteVioInfo(struct soap *soap, const struct __ns1__NSyncWriteVioInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__NSyncWriteVioInfo(soap, &a->ns1__NSyncWriteVioInfo_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__NSyncWriteVioInfo(struct soap *soap, const char *tag, int id, const struct __ns1__NSyncWriteVioInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__NSyncWriteVioInfo(soap, "ns1:NSyncWriteVioInfo", -1, &a->ns1__NSyncWriteVioInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NSyncWriteVioInfo * SOAP_FMAC4 soap_in___ns1__NSyncWriteVioInfo(struct soap *soap, const char *tag, struct __ns1__NSyncWriteVioInfo *a, const char *type)
{
	size_t soap_flag_ns1__NSyncWriteVioInfo_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__NSyncWriteVioInfo*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__NSyncWriteVioInfo, sizeof(struct __ns1__NSyncWriteVioInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__NSyncWriteVioInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__NSyncWriteVioInfo_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__NSyncWriteVioInfo(soap, "ns1:NSyncWriteVioInfo", &a->ns1__NSyncWriteVioInfo_, "ns1:NSyncWriteVioInfo"))
				{	soap_flag_ns1__NSyncWriteVioInfo_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__NSyncWriteVioInfo * SOAP_FMAC2 soap_instantiate___ns1__NSyncWriteVioInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__NSyncWriteVioInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__NSyncWriteVioInfo *p;
	size_t k = sizeof(struct __ns1__NSyncWriteVioInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__NSyncWriteVioInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__NSyncWriteVioInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__NSyncWriteVioInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__NSyncWriteVioInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__NSyncWriteVioInfo(struct soap *soap, const struct __ns1__NSyncWriteVioInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__NSyncWriteVioInfo(soap, tag ? tag : "-ns1:NSyncWriteVioInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NSyncWriteVioInfo * SOAP_FMAC4 soap_get___ns1__NSyncWriteVioInfo(struct soap *soap, struct __ns1__NSyncWriteVioInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__NSyncWriteVioInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__NSyncWriteMobileEPVInfo(struct soap *soap, struct __ns1__NSyncWriteMobileEPVInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__NSyncWriteMobileEPVInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__NSyncWriteMobileEPVInfo(struct soap *soap, const struct __ns1__NSyncWriteMobileEPVInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__NSyncWriteMobileEPVInfo(soap, &a->ns1__NSyncWriteMobileEPVInfo_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__NSyncWriteMobileEPVInfo(struct soap *soap, const char *tag, int id, const struct __ns1__NSyncWriteMobileEPVInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__NSyncWriteMobileEPVInfo(soap, "ns1:NSyncWriteMobileEPVInfo", -1, &a->ns1__NSyncWriteMobileEPVInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NSyncWriteMobileEPVInfo * SOAP_FMAC4 soap_in___ns1__NSyncWriteMobileEPVInfo(struct soap *soap, const char *tag, struct __ns1__NSyncWriteMobileEPVInfo *a, const char *type)
{
	size_t soap_flag_ns1__NSyncWriteMobileEPVInfo_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__NSyncWriteMobileEPVInfo*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__NSyncWriteMobileEPVInfo, sizeof(struct __ns1__NSyncWriteMobileEPVInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__NSyncWriteMobileEPVInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__NSyncWriteMobileEPVInfo_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__NSyncWriteMobileEPVInfo(soap, "ns1:NSyncWriteMobileEPVInfo", &a->ns1__NSyncWriteMobileEPVInfo_, "ns1:NSyncWriteMobileEPVInfo"))
				{	soap_flag_ns1__NSyncWriteMobileEPVInfo_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__NSyncWriteMobileEPVInfo * SOAP_FMAC2 soap_instantiate___ns1__NSyncWriteMobileEPVInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__NSyncWriteMobileEPVInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__NSyncWriteMobileEPVInfo *p;
	size_t k = sizeof(struct __ns1__NSyncWriteMobileEPVInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__NSyncWriteMobileEPVInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__NSyncWriteMobileEPVInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__NSyncWriteMobileEPVInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__NSyncWriteMobileEPVInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__NSyncWriteMobileEPVInfo(struct soap *soap, const struct __ns1__NSyncWriteMobileEPVInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__NSyncWriteMobileEPVInfo(soap, tag ? tag : "-ns1:NSyncWriteMobileEPVInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NSyncWriteMobileEPVInfo * SOAP_FMAC4 soap_get___ns1__NSyncWriteMobileEPVInfo(struct soap *soap, struct __ns1__NSyncWriteMobileEPVInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__NSyncWriteMobileEPVInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__NWriteDeviceStatus(struct soap *soap, struct __ns1__NWriteDeviceStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__NWriteDeviceStatus_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__NWriteDeviceStatus(struct soap *soap, const struct __ns1__NWriteDeviceStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__NWriteDeviceStatus(soap, &a->ns1__NWriteDeviceStatus_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__NWriteDeviceStatus(struct soap *soap, const char *tag, int id, const struct __ns1__NWriteDeviceStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__NWriteDeviceStatus(soap, "ns1:NWriteDeviceStatus", -1, &a->ns1__NWriteDeviceStatus_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NWriteDeviceStatus * SOAP_FMAC4 soap_in___ns1__NWriteDeviceStatus(struct soap *soap, const char *tag, struct __ns1__NWriteDeviceStatus *a, const char *type)
{
	size_t soap_flag_ns1__NWriteDeviceStatus_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__NWriteDeviceStatus*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__NWriteDeviceStatus, sizeof(struct __ns1__NWriteDeviceStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__NWriteDeviceStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__NWriteDeviceStatus_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__NWriteDeviceStatus(soap, "ns1:NWriteDeviceStatus", &a->ns1__NWriteDeviceStatus_, "ns1:NWriteDeviceStatus"))
				{	soap_flag_ns1__NWriteDeviceStatus_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__NWriteDeviceStatus * SOAP_FMAC2 soap_instantiate___ns1__NWriteDeviceStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__NWriteDeviceStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__NWriteDeviceStatus *p;
	size_t k = sizeof(struct __ns1__NWriteDeviceStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__NWriteDeviceStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__NWriteDeviceStatus);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__NWriteDeviceStatus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__NWriteDeviceStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__NWriteDeviceStatus(struct soap *soap, const struct __ns1__NWriteDeviceStatus *a, const char *tag, const char *type)
{
	if (soap_out___ns1__NWriteDeviceStatus(soap, tag ? tag : "-ns1:NWriteDeviceStatus", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NWriteDeviceStatus * SOAP_FMAC4 soap_get___ns1__NWriteDeviceStatus(struct soap *soap, struct __ns1__NWriteDeviceStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__NWriteDeviceStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__WriteFlux(struct soap *soap, struct __ns1__WriteFlux *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__WriteFlux_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__WriteFlux(struct soap *soap, const struct __ns1__WriteFlux *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__WriteFlux(soap, &a->ns1__WriteFlux_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__WriteFlux(struct soap *soap, const char *tag, int id, const struct __ns1__WriteFlux *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__WriteFlux(soap, "ns1:WriteFlux", -1, &a->ns1__WriteFlux_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__WriteFlux * SOAP_FMAC4 soap_in___ns1__WriteFlux(struct soap *soap, const char *tag, struct __ns1__WriteFlux *a, const char *type)
{
	size_t soap_flag_ns1__WriteFlux_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__WriteFlux*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__WriteFlux, sizeof(struct __ns1__WriteFlux), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__WriteFlux(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__WriteFlux_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__WriteFlux(soap, "ns1:WriteFlux", &a->ns1__WriteFlux_, "ns1:WriteFlux"))
				{	soap_flag_ns1__WriteFlux_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__WriteFlux * SOAP_FMAC2 soap_instantiate___ns1__WriteFlux(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__WriteFlux(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__WriteFlux *p;
	size_t k = sizeof(struct __ns1__WriteFlux);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__WriteFlux, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__WriteFlux);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__WriteFlux, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__WriteFlux location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__WriteFlux(struct soap *soap, const struct __ns1__WriteFlux *a, const char *tag, const char *type)
{
	if (soap_out___ns1__WriteFlux(soap, tag ? tag : "-ns1:WriteFlux", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__WriteFlux * SOAP_FMAC4 soap_get___ns1__WriteFlux(struct soap *soap, struct __ns1__WriteFlux *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__WriteFlux(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__NSyncWriteVehicleInfo(struct soap *soap, struct __ns1__NSyncWriteVehicleInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__NSyncWriteVehicleInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__NSyncWriteVehicleInfo(struct soap *soap, const struct __ns1__NSyncWriteVehicleInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__NSyncWriteVehicleInfo(soap, &a->ns1__NSyncWriteVehicleInfo_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__NSyncWriteVehicleInfo(struct soap *soap, const char *tag, int id, const struct __ns1__NSyncWriteVehicleInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__NSyncWriteVehicleInfo(soap, "ns1:NSyncWriteVehicleInfo", -1, &a->ns1__NSyncWriteVehicleInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NSyncWriteVehicleInfo * SOAP_FMAC4 soap_in___ns1__NSyncWriteVehicleInfo(struct soap *soap, const char *tag, struct __ns1__NSyncWriteVehicleInfo *a, const char *type)
{
	size_t soap_flag_ns1__NSyncWriteVehicleInfo_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__NSyncWriteVehicleInfo*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__NSyncWriteVehicleInfo, sizeof(struct __ns1__NSyncWriteVehicleInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__NSyncWriteVehicleInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__NSyncWriteVehicleInfo_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__NSyncWriteVehicleInfo(soap, "ns1:NSyncWriteVehicleInfo", &a->ns1__NSyncWriteVehicleInfo_, "ns1:NSyncWriteVehicleInfo"))
				{	soap_flag_ns1__NSyncWriteVehicleInfo_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__NSyncWriteVehicleInfo * SOAP_FMAC2 soap_instantiate___ns1__NSyncWriteVehicleInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__NSyncWriteVehicleInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__NSyncWriteVehicleInfo *p;
	size_t k = sizeof(struct __ns1__NSyncWriteVehicleInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__NSyncWriteVehicleInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__NSyncWriteVehicleInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__NSyncWriteVehicleInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__NSyncWriteVehicleInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__NSyncWriteVehicleInfo(struct soap *soap, const struct __ns1__NSyncWriteVehicleInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__NSyncWriteVehicleInfo(soap, tag ? tag : "-ns1:NSyncWriteVehicleInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NSyncWriteVehicleInfo * SOAP_FMAC4 soap_get___ns1__NSyncWriteVehicleInfo(struct soap *soap, struct __ns1__NSyncWriteVehicleInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__NSyncWriteVehicleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__NWriteVehicleInfoEx(struct soap *soap, struct __ns1__NWriteVehicleInfoEx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__NWriteVehicleInfoEx_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__NWriteVehicleInfoEx(struct soap *soap, const struct __ns1__NWriteVehicleInfoEx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__NWriteVehicleInfoEx(soap, &a->ns1__NWriteVehicleInfoEx_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__NWriteVehicleInfoEx(struct soap *soap, const char *tag, int id, const struct __ns1__NWriteVehicleInfoEx *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__NWriteVehicleInfoEx(soap, "ns1:NWriteVehicleInfoEx", -1, &a->ns1__NWriteVehicleInfoEx_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NWriteVehicleInfoEx * SOAP_FMAC4 soap_in___ns1__NWriteVehicleInfoEx(struct soap *soap, const char *tag, struct __ns1__NWriteVehicleInfoEx *a, const char *type)
{
	size_t soap_flag_ns1__NWriteVehicleInfoEx_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__NWriteVehicleInfoEx*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__NWriteVehicleInfoEx, sizeof(struct __ns1__NWriteVehicleInfoEx), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__NWriteVehicleInfoEx(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__NWriteVehicleInfoEx_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__NWriteVehicleInfoEx(soap, "ns1:NWriteVehicleInfoEx", &a->ns1__NWriteVehicleInfoEx_, "ns1:NWriteVehicleInfoEx"))
				{	soap_flag_ns1__NWriteVehicleInfoEx_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__NWriteVehicleInfoEx * SOAP_FMAC2 soap_instantiate___ns1__NWriteVehicleInfoEx(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__NWriteVehicleInfoEx(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__NWriteVehicleInfoEx *p;
	size_t k = sizeof(struct __ns1__NWriteVehicleInfoEx);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__NWriteVehicleInfoEx, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__NWriteVehicleInfoEx);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__NWriteVehicleInfoEx, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__NWriteVehicleInfoEx location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__NWriteVehicleInfoEx(struct soap *soap, const struct __ns1__NWriteVehicleInfoEx *a, const char *tag, const char *type)
{
	if (soap_out___ns1__NWriteVehicleInfoEx(soap, tag ? tag : "-ns1:NWriteVehicleInfoEx", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NWriteVehicleInfoEx * SOAP_FMAC4 soap_get___ns1__NWriteVehicleInfoEx(struct soap *soap, struct __ns1__NWriteVehicleInfoEx *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__NWriteVehicleInfoEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__NWriteVehicleInfo(struct soap *soap, struct __ns1__NWriteVehicleInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__NWriteVehicleInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__NWriteVehicleInfo(struct soap *soap, const struct __ns1__NWriteVehicleInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__NWriteVehicleInfo(soap, &a->ns1__NWriteVehicleInfo_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__NWriteVehicleInfo(struct soap *soap, const char *tag, int id, const struct __ns1__NWriteVehicleInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__NWriteVehicleInfo(soap, "ns1:NWriteVehicleInfo", -1, &a->ns1__NWriteVehicleInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NWriteVehicleInfo * SOAP_FMAC4 soap_in___ns1__NWriteVehicleInfo(struct soap *soap, const char *tag, struct __ns1__NWriteVehicleInfo *a, const char *type)
{
	size_t soap_flag_ns1__NWriteVehicleInfo_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__NWriteVehicleInfo*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__NWriteVehicleInfo, sizeof(struct __ns1__NWriteVehicleInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__NWriteVehicleInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__NWriteVehicleInfo_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__NWriteVehicleInfo(soap, "ns1:NWriteVehicleInfo", &a->ns1__NWriteVehicleInfo_, "ns1:NWriteVehicleInfo"))
				{	soap_flag_ns1__NWriteVehicleInfo_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__NWriteVehicleInfo * SOAP_FMAC2 soap_instantiate___ns1__NWriteVehicleInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__NWriteVehicleInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__NWriteVehicleInfo *p;
	size_t k = sizeof(struct __ns1__NWriteVehicleInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__NWriteVehicleInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__NWriteVehicleInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__NWriteVehicleInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__NWriteVehicleInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__NWriteVehicleInfo(struct soap *soap, const struct __ns1__NWriteVehicleInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__NWriteVehicleInfo(soap, tag ? tag : "-ns1:NWriteVehicleInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NWriteVehicleInfo * SOAP_FMAC4 soap_get___ns1__NWriteVehicleInfo(struct soap *soap, struct __ns1__NWriteVehicleInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__NWriteVehicleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__writeAlarmInfo(struct soap *soap, struct __ns1__writeAlarmInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__writeAlarmInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__writeAlarmInfo(struct soap *soap, const struct __ns1__writeAlarmInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__writeAlarmInfo(soap, &a->ns1__writeAlarmInfo_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__writeAlarmInfo(struct soap *soap, const char *tag, int id, const struct __ns1__writeAlarmInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__writeAlarmInfo(soap, "ns1:writeAlarmInfo", -1, &a->ns1__writeAlarmInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__writeAlarmInfo * SOAP_FMAC4 soap_in___ns1__writeAlarmInfo(struct soap *soap, const char *tag, struct __ns1__writeAlarmInfo *a, const char *type)
{
	size_t soap_flag_ns1__writeAlarmInfo_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__writeAlarmInfo*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__writeAlarmInfo, sizeof(struct __ns1__writeAlarmInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__writeAlarmInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__writeAlarmInfo_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__writeAlarmInfo(soap, "ns1:writeAlarmInfo", &a->ns1__writeAlarmInfo_, "ns1:writeAlarmInfo"))
				{	soap_flag_ns1__writeAlarmInfo_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__writeAlarmInfo * SOAP_FMAC2 soap_instantiate___ns1__writeAlarmInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__writeAlarmInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__writeAlarmInfo *p;
	size_t k = sizeof(struct __ns1__writeAlarmInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__writeAlarmInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__writeAlarmInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__writeAlarmInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__writeAlarmInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__writeAlarmInfo(struct soap *soap, const struct __ns1__writeAlarmInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__writeAlarmInfo(soap, tag ? tag : "-ns1:writeAlarmInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__writeAlarmInfo * SOAP_FMAC4 soap_get___ns1__writeAlarmInfo(struct soap *soap, struct __ns1__writeAlarmInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__writeAlarmInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__querySyncTime(struct soap *soap, struct __ns1__querySyncTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__querySyncTime_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__querySyncTime(struct soap *soap, const struct __ns1__querySyncTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__querySyncTime(soap, &a->ns1__querySyncTime_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__querySyncTime(struct soap *soap, const char *tag, int id, const struct __ns1__querySyncTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__querySyncTime(soap, "ns1:querySyncTime", -1, &a->ns1__querySyncTime_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__querySyncTime * SOAP_FMAC4 soap_in___ns1__querySyncTime(struct soap *soap, const char *tag, struct __ns1__querySyncTime *a, const char *type)
{
	size_t soap_flag_ns1__querySyncTime_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__querySyncTime*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__querySyncTime, sizeof(struct __ns1__querySyncTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__querySyncTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__querySyncTime_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__querySyncTime(soap, "ns1:querySyncTime", &a->ns1__querySyncTime_, "ns1:querySyncTime"))
				{	soap_flag_ns1__querySyncTime_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__querySyncTime * SOAP_FMAC2 soap_instantiate___ns1__querySyncTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__querySyncTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__querySyncTime *p;
	size_t k = sizeof(struct __ns1__querySyncTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__querySyncTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__querySyncTime);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__querySyncTime, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__querySyncTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__querySyncTime(struct soap *soap, const struct __ns1__querySyncTime *a, const char *tag, const char *type)
{
	if (soap_out___ns1__querySyncTime(soap, tag ? tag : "-ns1:querySyncTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__querySyncTime * SOAP_FMAC4 soap_get___ns1__querySyncTime(struct soap *soap, struct __ns1__querySyncTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__querySyncTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__logout(struct soap *soap, struct __ns1__logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__logout_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__logout(struct soap *soap, const struct __ns1__logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__logout(soap, &a->ns1__logout_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__logout(struct soap *soap, const char *tag, int id, const struct __ns1__logout *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__logout(soap, "ns1:logout", -1, &a->ns1__logout_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__logout * SOAP_FMAC4 soap_in___ns1__logout(struct soap *soap, const char *tag, struct __ns1__logout *a, const char *type)
{
	size_t soap_flag_ns1__logout_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__logout*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__logout, sizeof(struct __ns1__logout), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__logout(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__logout_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__logout(soap, "ns1:logout", &a->ns1__logout_, "ns1:logout"))
				{	soap_flag_ns1__logout_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__logout * SOAP_FMAC2 soap_instantiate___ns1__logout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__logout(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__logout *p;
	size_t k = sizeof(struct __ns1__logout);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__logout, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__logout);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__logout, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__logout location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__logout(struct soap *soap, const struct __ns1__logout *a, const char *tag, const char *type)
{
	if (soap_out___ns1__logout(soap, tag ? tag : "-ns1:logout", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__logout * SOAP_FMAC4 soap_get___ns1__logout(struct soap *soap, struct __ns1__logout *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__queryViolateSpeed(struct soap *soap, struct __ns1__queryViolateSpeed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__queryViolateSpeed_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__queryViolateSpeed(struct soap *soap, const struct __ns1__queryViolateSpeed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__queryViolateSpeed(soap, &a->ns1__queryViolateSpeed_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__queryViolateSpeed(struct soap *soap, const char *tag, int id, const struct __ns1__queryViolateSpeed *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__queryViolateSpeed(soap, "ns1:queryViolateSpeed", -1, &a->ns1__queryViolateSpeed_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryViolateSpeed * SOAP_FMAC4 soap_in___ns1__queryViolateSpeed(struct soap *soap, const char *tag, struct __ns1__queryViolateSpeed *a, const char *type)
{
	size_t soap_flag_ns1__queryViolateSpeed_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__queryViolateSpeed*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__queryViolateSpeed, sizeof(struct __ns1__queryViolateSpeed), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__queryViolateSpeed(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__queryViolateSpeed_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__queryViolateSpeed(soap, "ns1:queryViolateSpeed", &a->ns1__queryViolateSpeed_, "ns1:queryViolateSpeed"))
				{	soap_flag_ns1__queryViolateSpeed_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__queryViolateSpeed * SOAP_FMAC2 soap_instantiate___ns1__queryViolateSpeed(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__queryViolateSpeed(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__queryViolateSpeed *p;
	size_t k = sizeof(struct __ns1__queryViolateSpeed);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__queryViolateSpeed, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__queryViolateSpeed);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__queryViolateSpeed, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__queryViolateSpeed location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__queryViolateSpeed(struct soap *soap, const struct __ns1__queryViolateSpeed *a, const char *tag, const char *type)
{
	if (soap_out___ns1__queryViolateSpeed(soap, tag ? tag : "-ns1:queryViolateSpeed", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryViolateSpeed * SOAP_FMAC4 soap_get___ns1__queryViolateSpeed(struct soap *soap, struct __ns1__queryViolateSpeed *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__queryViolateSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__queryLimitSpeed(struct soap *soap, struct __ns1__queryLimitSpeed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__queryLimitSpeed_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__queryLimitSpeed(struct soap *soap, const struct __ns1__queryLimitSpeed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__queryLimitSpeed(soap, &a->ns1__queryLimitSpeed_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__queryLimitSpeed(struct soap *soap, const char *tag, int id, const struct __ns1__queryLimitSpeed *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__queryLimitSpeed(soap, "ns1:queryLimitSpeed", -1, &a->ns1__queryLimitSpeed_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryLimitSpeed * SOAP_FMAC4 soap_in___ns1__queryLimitSpeed(struct soap *soap, const char *tag, struct __ns1__queryLimitSpeed *a, const char *type)
{
	size_t soap_flag_ns1__queryLimitSpeed_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__queryLimitSpeed*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__queryLimitSpeed, sizeof(struct __ns1__queryLimitSpeed), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__queryLimitSpeed(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__queryLimitSpeed_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__queryLimitSpeed(soap, "ns1:queryLimitSpeed", &a->ns1__queryLimitSpeed_, "ns1:queryLimitSpeed"))
				{	soap_flag_ns1__queryLimitSpeed_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__queryLimitSpeed * SOAP_FMAC2 soap_instantiate___ns1__queryLimitSpeed(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__queryLimitSpeed(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__queryLimitSpeed *p;
	size_t k = sizeof(struct __ns1__queryLimitSpeed);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__queryLimitSpeed, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__queryLimitSpeed);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__queryLimitSpeed, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__queryLimitSpeed location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__queryLimitSpeed(struct soap *soap, const struct __ns1__queryLimitSpeed *a, const char *tag, const char *type)
{
	if (soap_out___ns1__queryLimitSpeed(soap, tag ? tag : "-ns1:queryLimitSpeed", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryLimitSpeed * SOAP_FMAC4 soap_get___ns1__queryLimitSpeed(struct soap *soap, struct __ns1__queryLimitSpeed *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__queryLimitSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__login(struct soap *soap, struct __ns1__login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__login_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__login(struct soap *soap, const struct __ns1__login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__login(soap, &a->ns1__login_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__login(struct soap *soap, const char *tag, int id, const struct __ns1__login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__login(soap, "ns1:login", -1, &a->ns1__login_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__login * SOAP_FMAC4 soap_in___ns1__login(struct soap *soap, const char *tag, struct __ns1__login *a, const char *type)
{
	size_t soap_flag_ns1__login_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__login*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__login, sizeof(struct __ns1__login), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__login(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__login_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__login(soap, "ns1:login", &a->ns1__login_, "ns1:login"))
				{	soap_flag_ns1__login_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__login * SOAP_FMAC2 soap_instantiate___ns1__login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__login(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__login *p;
	size_t k = sizeof(struct __ns1__login);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__login, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__login);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__login, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__login location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__login(struct soap *soap, const struct __ns1__login *a, const char *tag, const char *type)
{
	if (soap_out___ns1__login(soap, tag ? tag : "-ns1:login", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__login * SOAP_FMAC4 soap_get___ns1__login(struct soap *soap, struct __ns1__login *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__writeVehicleInfo(struct soap *soap, struct __ns1__writeVehicleInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__writeVehicleInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__writeVehicleInfo(struct soap *soap, const struct __ns1__writeVehicleInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__writeVehicleInfo(soap, &a->ns1__writeVehicleInfo_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__writeVehicleInfo(struct soap *soap, const char *tag, int id, const struct __ns1__writeVehicleInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__writeVehicleInfo(soap, "ns1:writeVehicleInfo", -1, &a->ns1__writeVehicleInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__writeVehicleInfo * SOAP_FMAC4 soap_in___ns1__writeVehicleInfo(struct soap *soap, const char *tag, struct __ns1__writeVehicleInfo *a, const char *type)
{
	size_t soap_flag_ns1__writeVehicleInfo_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__writeVehicleInfo*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__writeVehicleInfo, sizeof(struct __ns1__writeVehicleInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__writeVehicleInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__writeVehicleInfo_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__writeVehicleInfo(soap, "ns1:writeVehicleInfo", &a->ns1__writeVehicleInfo_, "ns1:writeVehicleInfo"))
				{	soap_flag_ns1__writeVehicleInfo_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__writeVehicleInfo * SOAP_FMAC2 soap_instantiate___ns1__writeVehicleInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__writeVehicleInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__writeVehicleInfo *p;
	size_t k = sizeof(struct __ns1__writeVehicleInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__writeVehicleInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__writeVehicleInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__writeVehicleInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__writeVehicleInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__writeVehicleInfo(struct soap *soap, const struct __ns1__writeVehicleInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__writeVehicleInfo(soap, tag ? tag : "-ns1:writeVehicleInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__writeVehicleInfo * SOAP_FMAC4 soap_get___ns1__writeVehicleInfo(struct soap *soap, struct __ns1__writeVehicleInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__writeVehicleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__syncWriteVehicleInfo(struct soap *soap, struct __ns1__syncWriteVehicleInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__syncWriteVehicleInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__syncWriteVehicleInfo(struct soap *soap, const struct __ns1__syncWriteVehicleInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__syncWriteVehicleInfo(soap, &a->ns1__syncWriteVehicleInfo_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__syncWriteVehicleInfo(struct soap *soap, const char *tag, int id, const struct __ns1__syncWriteVehicleInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__syncWriteVehicleInfo(soap, "ns1:syncWriteVehicleInfo", -1, &a->ns1__syncWriteVehicleInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__syncWriteVehicleInfo * SOAP_FMAC4 soap_in___ns1__syncWriteVehicleInfo(struct soap *soap, const char *tag, struct __ns1__syncWriteVehicleInfo *a, const char *type)
{
	size_t soap_flag_ns1__syncWriteVehicleInfo_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__syncWriteVehicleInfo*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__syncWriteVehicleInfo, sizeof(struct __ns1__syncWriteVehicleInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__syncWriteVehicleInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__syncWriteVehicleInfo_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__syncWriteVehicleInfo(soap, "ns1:syncWriteVehicleInfo", &a->ns1__syncWriteVehicleInfo_, "ns1:syncWriteVehicleInfo"))
				{	soap_flag_ns1__syncWriteVehicleInfo_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__syncWriteVehicleInfo * SOAP_FMAC2 soap_instantiate___ns1__syncWriteVehicleInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__syncWriteVehicleInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__syncWriteVehicleInfo *p;
	size_t k = sizeof(struct __ns1__syncWriteVehicleInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__syncWriteVehicleInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__syncWriteVehicleInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__syncWriteVehicleInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__syncWriteVehicleInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__syncWriteVehicleInfo(struct soap *soap, const struct __ns1__syncWriteVehicleInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__syncWriteVehicleInfo(soap, tag ? tag : "-ns1:syncWriteVehicleInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__syncWriteVehicleInfo * SOAP_FMAC4 soap_get___ns1__syncWriteVehicleInfo(struct soap *soap, struct __ns1__syncWriteVehicleInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__syncWriteVehicleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__WriteAreaSpeed(struct soap *soap, ns1__WriteAreaSpeed *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__WriteAreaSpeed))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__WriteAreaSpeed(struct soap *soap, const char *tag, int id, ns1__WriteAreaSpeed *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__WriteAreaSpeed, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__WriteAreaSpeed ? type : NULL);
}

SOAP_FMAC3 ns1__WriteAreaSpeed ** SOAP_FMAC4 soap_in_PointerTons1__WriteAreaSpeed(struct soap *soap, const char *tag, ns1__WriteAreaSpeed **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__WriteAreaSpeed **)soap_malloc(soap, sizeof(ns1__WriteAreaSpeed *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__WriteAreaSpeed *)soap_instantiate_ns1__WriteAreaSpeed(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__WriteAreaSpeed **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__WriteAreaSpeed, sizeof(ns1__WriteAreaSpeed), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__WriteAreaSpeed(struct soap *soap, ns1__WriteAreaSpeed *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__WriteAreaSpeed(soap, tag ? tag : "ns1:WriteAreaSpeed", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__WriteAreaSpeed ** SOAP_FMAC4 soap_get_PointerTons1__WriteAreaSpeed(struct soap *soap, ns1__WriteAreaSpeed **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__WriteAreaSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SyncWriteAreaSpeed(struct soap *soap, ns1__SyncWriteAreaSpeed *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SyncWriteAreaSpeed))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SyncWriteAreaSpeed(struct soap *soap, const char *tag, int id, ns1__SyncWriteAreaSpeed *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SyncWriteAreaSpeed, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__SyncWriteAreaSpeed ? type : NULL);
}

SOAP_FMAC3 ns1__SyncWriteAreaSpeed ** SOAP_FMAC4 soap_in_PointerTons1__SyncWriteAreaSpeed(struct soap *soap, const char *tag, ns1__SyncWriteAreaSpeed **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SyncWriteAreaSpeed **)soap_malloc(soap, sizeof(ns1__SyncWriteAreaSpeed *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SyncWriteAreaSpeed *)soap_instantiate_ns1__SyncWriteAreaSpeed(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SyncWriteAreaSpeed **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SyncWriteAreaSpeed, sizeof(ns1__SyncWriteAreaSpeed), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SyncWriteAreaSpeed(struct soap *soap, ns1__SyncWriteAreaSpeed *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SyncWriteAreaSpeed(soap, tag ? tag : "ns1:SyncWriteAreaSpeed", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SyncWriteAreaSpeed ** SOAP_FMAC4 soap_get_PointerTons1__SyncWriteAreaSpeed(struct soap *soap, ns1__SyncWriteAreaSpeed **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SyncWriteAreaSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__WriteVehPassInfo(struct soap *soap, ns1__WriteVehPassInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__WriteVehPassInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__WriteVehPassInfo(struct soap *soap, const char *tag, int id, ns1__WriteVehPassInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__WriteVehPassInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__WriteVehPassInfo ? type : NULL);
}

SOAP_FMAC3 ns1__WriteVehPassInfo ** SOAP_FMAC4 soap_in_PointerTons1__WriteVehPassInfo(struct soap *soap, const char *tag, ns1__WriteVehPassInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__WriteVehPassInfo **)soap_malloc(soap, sizeof(ns1__WriteVehPassInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__WriteVehPassInfo *)soap_instantiate_ns1__WriteVehPassInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__WriteVehPassInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__WriteVehPassInfo, sizeof(ns1__WriteVehPassInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__WriteVehPassInfo(struct soap *soap, ns1__WriteVehPassInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__WriteVehPassInfo(soap, tag ? tag : "ns1:WriteVehPassInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__WriteVehPassInfo ** SOAP_FMAC4 soap_get_PointerTons1__WriteVehPassInfo(struct soap *soap, ns1__WriteVehPassInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__WriteVehPassInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SyncWriteVehPassInfo(struct soap *soap, ns1__SyncWriteVehPassInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SyncWriteVehPassInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SyncWriteVehPassInfo(struct soap *soap, const char *tag, int id, ns1__SyncWriteVehPassInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SyncWriteVehPassInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__SyncWriteVehPassInfo ? type : NULL);
}

SOAP_FMAC3 ns1__SyncWriteVehPassInfo ** SOAP_FMAC4 soap_in_PointerTons1__SyncWriteVehPassInfo(struct soap *soap, const char *tag, ns1__SyncWriteVehPassInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SyncWriteVehPassInfo **)soap_malloc(soap, sizeof(ns1__SyncWriteVehPassInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SyncWriteVehPassInfo *)soap_instantiate_ns1__SyncWriteVehPassInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SyncWriteVehPassInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SyncWriteVehPassInfo, sizeof(ns1__SyncWriteVehPassInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SyncWriteVehPassInfo(struct soap *soap, ns1__SyncWriteVehPassInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SyncWriteVehPassInfo(soap, tag ? tag : "ns1:SyncWriteVehPassInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SyncWriteVehPassInfo ** SOAP_FMAC4 soap_get_PointerTons1__SyncWriteVehPassInfo(struct soap *soap, ns1__SyncWriteVehPassInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SyncWriteVehPassInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__NWritePassStat(struct soap *soap, ns1__NWritePassStat *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__NWritePassStat))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__NWritePassStat(struct soap *soap, const char *tag, int id, ns1__NWritePassStat *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__NWritePassStat, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__NWritePassStat ? type : NULL);
}

SOAP_FMAC3 ns1__NWritePassStat ** SOAP_FMAC4 soap_in_PointerTons1__NWritePassStat(struct soap *soap, const char *tag, ns1__NWritePassStat **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__NWritePassStat **)soap_malloc(soap, sizeof(ns1__NWritePassStat *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__NWritePassStat *)soap_instantiate_ns1__NWritePassStat(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__NWritePassStat **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__NWritePassStat, sizeof(ns1__NWritePassStat), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__NWritePassStat(struct soap *soap, ns1__NWritePassStat *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__NWritePassStat(soap, tag ? tag : "ns1:NWritePassStat", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__NWritePassStat ** SOAP_FMAC4 soap_get_PointerTons1__NWritePassStat(struct soap *soap, ns1__NWritePassStat **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__NWritePassStat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__NSyncWriteVioInfo(struct soap *soap, ns1__NSyncWriteVioInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__NSyncWriteVioInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__NSyncWriteVioInfo(struct soap *soap, const char *tag, int id, ns1__NSyncWriteVioInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__NSyncWriteVioInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__NSyncWriteVioInfo ? type : NULL);
}

SOAP_FMAC3 ns1__NSyncWriteVioInfo ** SOAP_FMAC4 soap_in_PointerTons1__NSyncWriteVioInfo(struct soap *soap, const char *tag, ns1__NSyncWriteVioInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__NSyncWriteVioInfo **)soap_malloc(soap, sizeof(ns1__NSyncWriteVioInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__NSyncWriteVioInfo *)soap_instantiate_ns1__NSyncWriteVioInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__NSyncWriteVioInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__NSyncWriteVioInfo, sizeof(ns1__NSyncWriteVioInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__NSyncWriteVioInfo(struct soap *soap, ns1__NSyncWriteVioInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__NSyncWriteVioInfo(soap, tag ? tag : "ns1:NSyncWriteVioInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__NSyncWriteVioInfo ** SOAP_FMAC4 soap_get_PointerTons1__NSyncWriteVioInfo(struct soap *soap, ns1__NSyncWriteVioInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__NSyncWriteVioInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__NSyncWriteMobileEPVInfo(struct soap *soap, ns1__NSyncWriteMobileEPVInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__NSyncWriteMobileEPVInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__NSyncWriteMobileEPVInfo(struct soap *soap, const char *tag, int id, ns1__NSyncWriteMobileEPVInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__NSyncWriteMobileEPVInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__NSyncWriteMobileEPVInfo ? type : NULL);
}

SOAP_FMAC3 ns1__NSyncWriteMobileEPVInfo ** SOAP_FMAC4 soap_in_PointerTons1__NSyncWriteMobileEPVInfo(struct soap *soap, const char *tag, ns1__NSyncWriteMobileEPVInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__NSyncWriteMobileEPVInfo **)soap_malloc(soap, sizeof(ns1__NSyncWriteMobileEPVInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__NSyncWriteMobileEPVInfo *)soap_instantiate_ns1__NSyncWriteMobileEPVInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__NSyncWriteMobileEPVInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__NSyncWriteMobileEPVInfo, sizeof(ns1__NSyncWriteMobileEPVInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__NSyncWriteMobileEPVInfo(struct soap *soap, ns1__NSyncWriteMobileEPVInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__NSyncWriteMobileEPVInfo(soap, tag ? tag : "ns1:NSyncWriteMobileEPVInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__NSyncWriteMobileEPVInfo ** SOAP_FMAC4 soap_get_PointerTons1__NSyncWriteMobileEPVInfo(struct soap *soap, ns1__NSyncWriteMobileEPVInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__NSyncWriteMobileEPVInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__NWriteDeviceStatus(struct soap *soap, ns1__NWriteDeviceStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__NWriteDeviceStatus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__NWriteDeviceStatus(struct soap *soap, const char *tag, int id, ns1__NWriteDeviceStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__NWriteDeviceStatus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__NWriteDeviceStatus ? type : NULL);
}

SOAP_FMAC3 ns1__NWriteDeviceStatus ** SOAP_FMAC4 soap_in_PointerTons1__NWriteDeviceStatus(struct soap *soap, const char *tag, ns1__NWriteDeviceStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__NWriteDeviceStatus **)soap_malloc(soap, sizeof(ns1__NWriteDeviceStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__NWriteDeviceStatus *)soap_instantiate_ns1__NWriteDeviceStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__NWriteDeviceStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__NWriteDeviceStatus, sizeof(ns1__NWriteDeviceStatus), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__NWriteDeviceStatus(struct soap *soap, ns1__NWriteDeviceStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__NWriteDeviceStatus(soap, tag ? tag : "ns1:NWriteDeviceStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__NWriteDeviceStatus ** SOAP_FMAC4 soap_get_PointerTons1__NWriteDeviceStatus(struct soap *soap, ns1__NWriteDeviceStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__NWriteDeviceStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__WriteFlux(struct soap *soap, ns1__WriteFlux *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__WriteFlux))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__WriteFlux(struct soap *soap, const char *tag, int id, ns1__WriteFlux *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__WriteFlux, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__WriteFlux ? type : NULL);
}

SOAP_FMAC3 ns1__WriteFlux ** SOAP_FMAC4 soap_in_PointerTons1__WriteFlux(struct soap *soap, const char *tag, ns1__WriteFlux **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__WriteFlux **)soap_malloc(soap, sizeof(ns1__WriteFlux *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__WriteFlux *)soap_instantiate_ns1__WriteFlux(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__WriteFlux **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__WriteFlux, sizeof(ns1__WriteFlux), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__WriteFlux(struct soap *soap, ns1__WriteFlux *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__WriteFlux(soap, tag ? tag : "ns1:WriteFlux", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__WriteFlux ** SOAP_FMAC4 soap_get_PointerTons1__WriteFlux(struct soap *soap, ns1__WriteFlux **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__WriteFlux(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__NSyncWriteVehicleInfo(struct soap *soap, ns1__NSyncWriteVehicleInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__NSyncWriteVehicleInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__NSyncWriteVehicleInfo(struct soap *soap, const char *tag, int id, ns1__NSyncWriteVehicleInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__NSyncWriteVehicleInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__NSyncWriteVehicleInfo ? type : NULL);
}

SOAP_FMAC3 ns1__NSyncWriteVehicleInfo ** SOAP_FMAC4 soap_in_PointerTons1__NSyncWriteVehicleInfo(struct soap *soap, const char *tag, ns1__NSyncWriteVehicleInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__NSyncWriteVehicleInfo **)soap_malloc(soap, sizeof(ns1__NSyncWriteVehicleInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__NSyncWriteVehicleInfo *)soap_instantiate_ns1__NSyncWriteVehicleInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__NSyncWriteVehicleInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__NSyncWriteVehicleInfo, sizeof(ns1__NSyncWriteVehicleInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__NSyncWriteVehicleInfo(struct soap *soap, ns1__NSyncWriteVehicleInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__NSyncWriteVehicleInfo(soap, tag ? tag : "ns1:NSyncWriteVehicleInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__NSyncWriteVehicleInfo ** SOAP_FMAC4 soap_get_PointerTons1__NSyncWriteVehicleInfo(struct soap *soap, ns1__NSyncWriteVehicleInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__NSyncWriteVehicleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__NWriteVehicleInfoEx(struct soap *soap, ns1__NWriteVehicleInfoEx *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__NWriteVehicleInfoEx))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__NWriteVehicleInfoEx(struct soap *soap, const char *tag, int id, ns1__NWriteVehicleInfoEx *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__NWriteVehicleInfoEx, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__NWriteVehicleInfoEx ? type : NULL);
}

SOAP_FMAC3 ns1__NWriteVehicleInfoEx ** SOAP_FMAC4 soap_in_PointerTons1__NWriteVehicleInfoEx(struct soap *soap, const char *tag, ns1__NWriteVehicleInfoEx **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__NWriteVehicleInfoEx **)soap_malloc(soap, sizeof(ns1__NWriteVehicleInfoEx *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__NWriteVehicleInfoEx *)soap_instantiate_ns1__NWriteVehicleInfoEx(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__NWriteVehicleInfoEx **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__NWriteVehicleInfoEx, sizeof(ns1__NWriteVehicleInfoEx), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__NWriteVehicleInfoEx(struct soap *soap, ns1__NWriteVehicleInfoEx *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__NWriteVehicleInfoEx(soap, tag ? tag : "ns1:NWriteVehicleInfoEx", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__NWriteVehicleInfoEx ** SOAP_FMAC4 soap_get_PointerTons1__NWriteVehicleInfoEx(struct soap *soap, ns1__NWriteVehicleInfoEx **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__NWriteVehicleInfoEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__NWriteVehicleInfo(struct soap *soap, ns1__NWriteVehicleInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__NWriteVehicleInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__NWriteVehicleInfo(struct soap *soap, const char *tag, int id, ns1__NWriteVehicleInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__NWriteVehicleInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__NWriteVehicleInfo ? type : NULL);
}

SOAP_FMAC3 ns1__NWriteVehicleInfo ** SOAP_FMAC4 soap_in_PointerTons1__NWriteVehicleInfo(struct soap *soap, const char *tag, ns1__NWriteVehicleInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__NWriteVehicleInfo **)soap_malloc(soap, sizeof(ns1__NWriteVehicleInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__NWriteVehicleInfo *)soap_instantiate_ns1__NWriteVehicleInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__NWriteVehicleInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__NWriteVehicleInfo, sizeof(ns1__NWriteVehicleInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__NWriteVehicleInfo(struct soap *soap, ns1__NWriteVehicleInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__NWriteVehicleInfo(soap, tag ? tag : "ns1:NWriteVehicleInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__NWriteVehicleInfo ** SOAP_FMAC4 soap_get_PointerTons1__NWriteVehicleInfo(struct soap *soap, ns1__NWriteVehicleInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__NWriteVehicleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__writeAlarmInfo(struct soap *soap, ns1__writeAlarmInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__writeAlarmInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__writeAlarmInfo(struct soap *soap, const char *tag, int id, ns1__writeAlarmInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__writeAlarmInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__writeAlarmInfo ? type : NULL);
}

SOAP_FMAC3 ns1__writeAlarmInfo ** SOAP_FMAC4 soap_in_PointerTons1__writeAlarmInfo(struct soap *soap, const char *tag, ns1__writeAlarmInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__writeAlarmInfo **)soap_malloc(soap, sizeof(ns1__writeAlarmInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__writeAlarmInfo *)soap_instantiate_ns1__writeAlarmInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__writeAlarmInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__writeAlarmInfo, sizeof(ns1__writeAlarmInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__writeAlarmInfo(struct soap *soap, ns1__writeAlarmInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__writeAlarmInfo(soap, tag ? tag : "ns1:writeAlarmInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__writeAlarmInfo ** SOAP_FMAC4 soap_get_PointerTons1__writeAlarmInfo(struct soap *soap, ns1__writeAlarmInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__writeAlarmInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__querySyncTime(struct soap *soap, ns1__querySyncTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__querySyncTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__querySyncTime(struct soap *soap, const char *tag, int id, ns1__querySyncTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__querySyncTime, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__querySyncTime ? type : NULL);
}

SOAP_FMAC3 ns1__querySyncTime ** SOAP_FMAC4 soap_in_PointerTons1__querySyncTime(struct soap *soap, const char *tag, ns1__querySyncTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__querySyncTime **)soap_malloc(soap, sizeof(ns1__querySyncTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__querySyncTime *)soap_instantiate_ns1__querySyncTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__querySyncTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__querySyncTime, sizeof(ns1__querySyncTime), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__querySyncTime(struct soap *soap, ns1__querySyncTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__querySyncTime(soap, tag ? tag : "ns1:querySyncTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__querySyncTime ** SOAP_FMAC4 soap_get_PointerTons1__querySyncTime(struct soap *soap, ns1__querySyncTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__querySyncTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__logout(struct soap *soap, ns1__logout *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__logout))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__logout(struct soap *soap, const char *tag, int id, ns1__logout *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__logout, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__logout ? type : NULL);
}

SOAP_FMAC3 ns1__logout ** SOAP_FMAC4 soap_in_PointerTons1__logout(struct soap *soap, const char *tag, ns1__logout **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__logout **)soap_malloc(soap, sizeof(ns1__logout *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__logout *)soap_instantiate_ns1__logout(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__logout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__logout, sizeof(ns1__logout), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__logout(struct soap *soap, ns1__logout *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__logout(soap, tag ? tag : "ns1:logout", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__logout ** SOAP_FMAC4 soap_get_PointerTons1__logout(struct soap *soap, ns1__logout **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__queryViolateSpeed(struct soap *soap, ns1__queryViolateSpeed *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__queryViolateSpeed))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__queryViolateSpeed(struct soap *soap, const char *tag, int id, ns1__queryViolateSpeed *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__queryViolateSpeed, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__queryViolateSpeed ? type : NULL);
}

SOAP_FMAC3 ns1__queryViolateSpeed ** SOAP_FMAC4 soap_in_PointerTons1__queryViolateSpeed(struct soap *soap, const char *tag, ns1__queryViolateSpeed **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__queryViolateSpeed **)soap_malloc(soap, sizeof(ns1__queryViolateSpeed *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__queryViolateSpeed *)soap_instantiate_ns1__queryViolateSpeed(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__queryViolateSpeed **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__queryViolateSpeed, sizeof(ns1__queryViolateSpeed), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__queryViolateSpeed(struct soap *soap, ns1__queryViolateSpeed *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__queryViolateSpeed(soap, tag ? tag : "ns1:queryViolateSpeed", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__queryViolateSpeed ** SOAP_FMAC4 soap_get_PointerTons1__queryViolateSpeed(struct soap *soap, ns1__queryViolateSpeed **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__queryViolateSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__queryLimitSpeed(struct soap *soap, ns1__queryLimitSpeed *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__queryLimitSpeed))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__queryLimitSpeed(struct soap *soap, const char *tag, int id, ns1__queryLimitSpeed *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__queryLimitSpeed, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__queryLimitSpeed ? type : NULL);
}

SOAP_FMAC3 ns1__queryLimitSpeed ** SOAP_FMAC4 soap_in_PointerTons1__queryLimitSpeed(struct soap *soap, const char *tag, ns1__queryLimitSpeed **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__queryLimitSpeed **)soap_malloc(soap, sizeof(ns1__queryLimitSpeed *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__queryLimitSpeed *)soap_instantiate_ns1__queryLimitSpeed(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__queryLimitSpeed **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__queryLimitSpeed, sizeof(ns1__queryLimitSpeed), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__queryLimitSpeed(struct soap *soap, ns1__queryLimitSpeed *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__queryLimitSpeed(soap, tag ? tag : "ns1:queryLimitSpeed", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__queryLimitSpeed ** SOAP_FMAC4 soap_get_PointerTons1__queryLimitSpeed(struct soap *soap, ns1__queryLimitSpeed **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__queryLimitSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__login(struct soap *soap, ns1__login *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__login))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__login(struct soap *soap, const char *tag, int id, ns1__login *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__login, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__login ? type : NULL);
}

SOAP_FMAC3 ns1__login ** SOAP_FMAC4 soap_in_PointerTons1__login(struct soap *soap, const char *tag, ns1__login **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__login **)soap_malloc(soap, sizeof(ns1__login *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__login *)soap_instantiate_ns1__login(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__login **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__login, sizeof(ns1__login), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__login(struct soap *soap, ns1__login *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__login(soap, tag ? tag : "ns1:login", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__login ** SOAP_FMAC4 soap_get_PointerTons1__login(struct soap *soap, ns1__login **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__writeVehicleInfo(struct soap *soap, ns1__writeVehicleInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__writeVehicleInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__writeVehicleInfo(struct soap *soap, const char *tag, int id, ns1__writeVehicleInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__writeVehicleInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__writeVehicleInfo ? type : NULL);
}

SOAP_FMAC3 ns1__writeVehicleInfo ** SOAP_FMAC4 soap_in_PointerTons1__writeVehicleInfo(struct soap *soap, const char *tag, ns1__writeVehicleInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__writeVehicleInfo **)soap_malloc(soap, sizeof(ns1__writeVehicleInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__writeVehicleInfo *)soap_instantiate_ns1__writeVehicleInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__writeVehicleInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__writeVehicleInfo, sizeof(ns1__writeVehicleInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__writeVehicleInfo(struct soap *soap, ns1__writeVehicleInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__writeVehicleInfo(soap, tag ? tag : "ns1:writeVehicleInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__writeVehicleInfo ** SOAP_FMAC4 soap_get_PointerTons1__writeVehicleInfo(struct soap *soap, ns1__writeVehicleInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__writeVehicleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__syncWriteVehicleInfo(struct soap *soap, ns1__syncWriteVehicleInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__syncWriteVehicleInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__syncWriteVehicleInfo(struct soap *soap, const char *tag, int id, ns1__syncWriteVehicleInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__syncWriteVehicleInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__syncWriteVehicleInfo ? type : NULL);
}

SOAP_FMAC3 ns1__syncWriteVehicleInfo ** SOAP_FMAC4 soap_in_PointerTons1__syncWriteVehicleInfo(struct soap *soap, const char *tag, ns1__syncWriteVehicleInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__syncWriteVehicleInfo **)soap_malloc(soap, sizeof(ns1__syncWriteVehicleInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__syncWriteVehicleInfo *)soap_instantiate_ns1__syncWriteVehicleInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__syncWriteVehicleInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__syncWriteVehicleInfo, sizeof(ns1__syncWriteVehicleInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__syncWriteVehicleInfo(struct soap *soap, ns1__syncWriteVehicleInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__syncWriteVehicleInfo(soap, tag ? tag : "ns1:syncWriteVehicleInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__syncWriteVehicleInfo ** SOAP_FMAC4 soap_get_PointerTons1__syncWriteVehicleInfo(struct soap *soap, ns1__syncWriteVehicleInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__syncWriteVehicleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTounsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
